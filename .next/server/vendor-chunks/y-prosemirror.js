"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/y-prosemirror";
exports.ids = ["vendor-chunks/y-prosemirror"];
exports.modules = {

/***/ "(ssr)/./node_modules/y-prosemirror/src/lib.js":
/*!***********************************************!*\
  !*** ./node_modules/y-prosemirror/src/lib.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   absolutePositionToRelativePosition: () => (/* binding */ absolutePositionToRelativePosition),\n/* harmony export */   initProseMirrorDoc: () => (/* binding */ initProseMirrorDoc),\n/* harmony export */   prosemirrorJSONToYDoc: () => (/* binding */ prosemirrorJSONToYDoc),\n/* harmony export */   prosemirrorJSONToYXmlFragment: () => (/* binding */ prosemirrorJSONToYXmlFragment),\n/* harmony export */   prosemirrorToYDoc: () => (/* binding */ prosemirrorToYDoc),\n/* harmony export */   prosemirrorToYXmlFragment: () => (/* binding */ prosemirrorToYXmlFragment),\n/* harmony export */   relativePositionToAbsolutePosition: () => (/* binding */ relativePositionToAbsolutePosition),\n/* harmony export */   setMeta: () => (/* binding */ setMeta),\n/* harmony export */   yDocToProsemirror: () => (/* binding */ yDocToProsemirror),\n/* harmony export */   yDocToProsemirrorJSON: () => (/* binding */ yDocToProsemirrorJSON),\n/* harmony export */   yXmlFragmentToProseMirrorFragment: () => (/* binding */ yXmlFragmentToProseMirrorFragment),\n/* harmony export */   yXmlFragmentToProseMirrorRootNode: () => (/* binding */ yXmlFragmentToProseMirrorRootNode),\n/* harmony export */   yXmlFragmentToProsemirror: () => (/* binding */ yXmlFragmentToProsemirror),\n/* harmony export */   yXmlFragmentToProsemirrorJSON: () => (/* binding */ yXmlFragmentToProsemirrorJSON)\n/* harmony export */ });\n/* harmony import */ var _plugins_sync_plugin_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./plugins/sync-plugin.js */ \"(ssr)/./node_modules/y-prosemirror/src/plugins/sync-plugin.js\");\n/* harmony import */ var _plugins_keys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./plugins/keys.js */ \"(ssr)/./node_modules/y-prosemirror/src/plugins/keys.js\");\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! yjs */ \"(ssr)/./node_modules/yjs/dist/yjs.mjs\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var lib0_error__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lib0/error */ \"(ssr)/./node_modules/lib0/error.js\");\n/* harmony import */ var lib0_map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lib0/map */ \"(ssr)/./node_modules/lib0/map.js\");\n/* harmony import */ var lib0_eventloop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lib0/eventloop */ \"(ssr)/./node_modules/lib0/eventloop.js\");\n // eslint-disable-line\n\n\n // eslint-disable-line\n // eslint-disable-line\n\n\n\n\n/**\n * Either a node if type is YXmlElement or an Array of text nodes if YXmlText\n * @typedef {Map<Y.AbstractType, Node | Array<Node>>} ProsemirrorMapping\n */\n\n/**\n * Is null if no timeout is in progress.\n * Is defined if a timeout is in progress.\n * Maps from view\n * @type {Map<EditorView, Map<any, any>>|null}\n */\nlet viewsToUpdate = null\n\nconst updateMetas = () => {\n  const ups = /** @type {Map<EditorView, Map<any, any>>} */ (viewsToUpdate)\n  viewsToUpdate = null\n  ups.forEach((metas, view) => {\n    const tr = view.state.tr\n    const syncState = _plugins_keys_js__WEBPACK_IMPORTED_MODULE_0__.ySyncPluginKey.getState(view.state)\n    if (syncState && syncState.binding && !syncState.binding.isDestroyed) {\n      metas.forEach((val, key) => {\n        tr.setMeta(key, val)\n      })\n      view.dispatch(tr)\n    }\n  })\n}\n\nconst setMeta = (view, key, value) => {\n  if (!viewsToUpdate) {\n    viewsToUpdate = new Map()\n    lib0_eventloop__WEBPACK_IMPORTED_MODULE_1__.timeout(0, updateMetas)\n  }\n  lib0_map__WEBPACK_IMPORTED_MODULE_2__.setIfUndefined(viewsToUpdate, view, lib0_map__WEBPACK_IMPORTED_MODULE_2__.create).set(key, value)\n}\n\n/**\n * Transforms a Prosemirror based absolute position to a Yjs Cursor (relative position in the Yjs model).\n *\n * @param {number} pos\n * @param {Y.XmlFragment} type\n * @param {ProsemirrorMapping} mapping\n * @return {any} relative position\n */\nconst absolutePositionToRelativePosition = (pos, type, mapping) => {\n  if (pos === 0) {\n    return yjs__WEBPACK_IMPORTED_MODULE_3__.createRelativePositionFromTypeIndex(type, 0, -1)\n  }\n  /**\n   * @type {any}\n   */\n  let n = type._first === null ? null : /** @type {Y.ContentType} */ (type._first.content).type\n  while (n !== null && type !== n) {\n    if (n instanceof yjs__WEBPACK_IMPORTED_MODULE_3__.XmlText) {\n      if (n._length >= pos) {\n        return yjs__WEBPACK_IMPORTED_MODULE_3__.createRelativePositionFromTypeIndex(n, pos, -1)\n      } else {\n        pos -= n._length\n      }\n      if (n._item !== null && n._item.next !== null) {\n        n = /** @type {Y.ContentType} */ (n._item.next.content).type\n      } else {\n        do {\n          n = n._item === null ? null : n._item.parent\n          pos--\n        } while (n !== type && n !== null && n._item !== null && n._item.next === null)\n        if (n !== null && n !== type) {\n          // @ts-gnore we know that n.next !== null because of above loop conditition\n          n = n._item === null ? null : /** @type {Y.ContentType} */ (/** @type Y.Item */ (n._item.next).content).type\n        }\n      }\n    } else {\n      const pNodeSize = /** @type {any} */ (mapping.get(n) || { nodeSize: 0 }).nodeSize\n      if (n._first !== null && pos < pNodeSize) {\n        n = /** @type {Y.ContentType} */ (n._first.content).type\n        pos--\n      } else {\n        if (pos === 1 && n._length === 0 && pNodeSize > 1) {\n          // edge case, should end in this paragraph\n          return new yjs__WEBPACK_IMPORTED_MODULE_3__.RelativePosition(n._item === null ? null : n._item.id, n._item === null ? yjs__WEBPACK_IMPORTED_MODULE_3__.findRootTypeKey(n) : null, null)\n        }\n        pos -= pNodeSize\n        if (n._item !== null && n._item.next !== null) {\n          n = /** @type {Y.ContentType} */ (n._item.next.content).type\n        } else {\n          if (pos === 0) {\n            // set to end of n.parent\n            n = n._item === null ? n : n._item.parent\n            return new yjs__WEBPACK_IMPORTED_MODULE_3__.RelativePosition(n._item === null ? null : n._item.id, n._item === null ? yjs__WEBPACK_IMPORTED_MODULE_3__.findRootTypeKey(n) : null, null)\n          }\n          do {\n            n = /** @type {Y.Item} */ (n._item).parent\n            pos--\n          } while (n !== type && /** @type {Y.Item} */ (n._item).next === null)\n          // if n is null at this point, we have an unexpected case\n          if (n !== type) {\n            // We know that n._item.next is defined because of above loop condition\n            n = /** @type {Y.ContentType} */ (/** @type {Y.Item} */ (/** @type {Y.Item} */ (n._item).next).content).type\n          }\n        }\n      }\n    }\n    if (n === null) {\n      throw lib0_error__WEBPACK_IMPORTED_MODULE_4__.unexpectedCase()\n    }\n    if (pos === 0 && n.constructor !== yjs__WEBPACK_IMPORTED_MODULE_3__.XmlText && n !== type) { // TODO: set to <= 0\n      return createRelativePosition(n._item.parent, n._item)\n    }\n  }\n  return yjs__WEBPACK_IMPORTED_MODULE_3__.createRelativePositionFromTypeIndex(type, type._length, -1)\n}\n\nconst createRelativePosition = (type, item) => {\n  let typeid = null\n  let tname = null\n  if (type._item === null) {\n    tname = yjs__WEBPACK_IMPORTED_MODULE_3__.findRootTypeKey(type)\n  } else {\n    typeid = yjs__WEBPACK_IMPORTED_MODULE_3__.createID(type._item.id.client, type._item.id.clock)\n  }\n  return new yjs__WEBPACK_IMPORTED_MODULE_3__.RelativePosition(typeid, tname, item.id)\n}\n\n/**\n * @param {Y.Doc} y\n * @param {Y.XmlFragment} documentType Top level type that is bound to pView\n * @param {any} relPos Encoded Yjs based relative position\n * @param {ProsemirrorMapping} mapping\n * @return {null|number}\n */\nconst relativePositionToAbsolutePosition = (y, documentType, relPos, mapping) => {\n  const decodedPos = yjs__WEBPACK_IMPORTED_MODULE_3__.createAbsolutePositionFromRelativePosition(relPos, y)\n  if (decodedPos === null || (decodedPos.type !== documentType && !yjs__WEBPACK_IMPORTED_MODULE_3__.isParentOf(documentType, decodedPos.type._item))) {\n    return null\n  }\n  let type = decodedPos.type\n  let pos = 0\n  if (type.constructor === yjs__WEBPACK_IMPORTED_MODULE_3__.XmlText) {\n    pos = decodedPos.index\n  } else if (type._item === null || !type._item.deleted) {\n    let n = type._first\n    let i = 0\n    while (i < type._length && i < decodedPos.index && n !== null) {\n      if (!n.deleted) {\n        const t = /** @type {Y.ContentType} */ (n.content).type\n        i++\n        if (t instanceof yjs__WEBPACK_IMPORTED_MODULE_3__.XmlText) {\n          pos += t._length\n        } else {\n          pos += /** @type {any} */ (mapping.get(t)).nodeSize\n        }\n      }\n      n = /** @type {Y.Item} */ (n.right)\n    }\n    pos += 1 // increase because we go out of n\n  }\n  while (type !== documentType && type._item !== null) {\n    // @ts-ignore\n    const parent = type._item.parent\n    // @ts-ignore\n    if (parent._item === null || !parent._item.deleted) {\n      pos += 1 // the start tag\n      let n = /** @type {Y.AbstractType} */ (parent)._first\n      // now iterate until we found type\n      while (n !== null) {\n        const contentType = /** @type {Y.ContentType} */ (n.content).type\n        if (contentType === type) {\n          break\n        }\n        if (!n.deleted) {\n          if (contentType instanceof yjs__WEBPACK_IMPORTED_MODULE_3__.XmlText) {\n            pos += contentType._length\n          } else {\n            pos += /** @type {any} */ (mapping.get(contentType)).nodeSize\n          }\n        }\n        n = n.right\n      }\n    }\n    type = /** @type {Y.AbstractType} */ (parent)\n  }\n  return pos - 1 // we don't count the most outer tag, because it is a fragment\n}\n\n/**\n * Utility function for converting an Y.Fragment to a ProseMirror fragment.\n *\n * @param {Y.XmlFragment} yXmlFragment\n * @param {Schema} schema\n */\nconst yXmlFragmentToProseMirrorFragment = (yXmlFragment, schema) => {\n  const fragmentContent = yXmlFragment.toArray().map((t) =>\n    (0,_plugins_sync_plugin_js__WEBPACK_IMPORTED_MODULE_5__.createNodeFromYElement)(\n      /** @type {Y.XmlElement} */ (t),\n      schema,\n      new Map()\n    )\n  ).filter((n) => n !== null)\n  return prosemirror_model__WEBPACK_IMPORTED_MODULE_6__.Fragment.fromArray(fragmentContent)\n}\n\n/**\n * Utility function for converting an Y.Fragment to a ProseMirror node.\n *\n * @param {Y.XmlFragment} yXmlFragment\n * @param {Schema} schema\n */\nconst yXmlFragmentToProseMirrorRootNode = (yXmlFragment, schema) =>\n  schema.topNodeType.create(null, yXmlFragmentToProseMirrorFragment(yXmlFragment, schema))\n\n/**\n * The initial ProseMirror content should be supplied by Yjs. This function transforms a Y.Fragment\n * to a ProseMirror Doc node and creates a mapping that is used by the sync plugin.\n *\n * @param {Y.XmlFragment} yXmlFragment\n * @param {Schema} schema\n */\nconst initProseMirrorDoc = (yXmlFragment, schema) => {\n  /**\n   * @type {ProsemirrorMapping}\n   */\n  const mapping = new Map()\n  const fragmentContent = yXmlFragment.toArray().map((t) =>\n    (0,_plugins_sync_plugin_js__WEBPACK_IMPORTED_MODULE_5__.createNodeFromYElement)(\n      /** @type {Y.XmlElement} */ (t),\n      schema,\n      mapping\n    )\n  ).filter((n) => n !== null)\n  const doc = schema.topNodeType.create(null, prosemirror_model__WEBPACK_IMPORTED_MODULE_6__.Fragment.fromArray(fragmentContent))\n  return { doc, mapping }\n}\n\n/**\n * Utility method to convert a Prosemirror Doc Node into a Y.Doc.\n *\n * This can be used when importing existing content to Y.Doc for the first time,\n * note that this should not be used to rehydrate a Y.Doc from a database once\n * collaboration has begun as all history will be lost\n *\n * @param {Node} doc\n * @param {string} xmlFragment\n * @return {Y.Doc}\n */\nfunction prosemirrorToYDoc (doc, xmlFragment = 'prosemirror') {\n  const ydoc = new yjs__WEBPACK_IMPORTED_MODULE_3__.Doc()\n  const type = /** @type {Y.XmlFragment} */ (ydoc.get(xmlFragment, yjs__WEBPACK_IMPORTED_MODULE_3__.XmlFragment))\n  if (!type.doc) {\n    return ydoc\n  }\n\n  prosemirrorToYXmlFragment(doc, type)\n  return type.doc\n}\n\n/**\n * Utility method to update an empty Y.XmlFragment with content from a Prosemirror Doc Node.\n *\n * This can be used when importing existing content to Y.Doc for the first time,\n * note that this should not be used to rehydrate a Y.Doc from a database once\n * collaboration has begun as all history will be lost\n *\n * Note: The Y.XmlFragment does not need to be part of a Y.Doc document at the time that this\n * method is called, but it must be added before any other operations are performed on it.\n *\n * @param {Node} doc prosemirror document.\n * @param {Y.XmlFragment} [xmlFragment] If supplied, an xml fragment to be\n *   populated from the prosemirror state; otherwise a new XmlFragment will be created.\n * @return {Y.XmlFragment}\n */\nfunction prosemirrorToYXmlFragment (doc, xmlFragment) {\n  const type = xmlFragment || new yjs__WEBPACK_IMPORTED_MODULE_3__.XmlFragment()\n  const ydoc = type.doc ? type.doc : { transact: (transaction) => transaction(undefined) }\n  ;(0,_plugins_sync_plugin_js__WEBPACK_IMPORTED_MODULE_5__.updateYFragment)(ydoc, type, doc, new Map())\n  return type\n}\n\n/**\n * Utility method to convert Prosemirror compatible JSON into a Y.Doc.\n *\n * This can be used when importing existing content to Y.Doc for the first time,\n * note that this should not be used to rehydrate a Y.Doc from a database once\n * collaboration has begun as all history will be lost\n *\n * @param {Schema} schema\n * @param {any} state\n * @param {string} xmlFragment\n * @return {Y.Doc}\n */\nfunction prosemirrorJSONToYDoc (schema, state, xmlFragment = 'prosemirror') {\n  const doc = prosemirror_model__WEBPACK_IMPORTED_MODULE_6__.Node.fromJSON(schema, state)\n  return prosemirrorToYDoc(doc, xmlFragment)\n}\n\n/**\n * Utility method to convert Prosemirror compatible JSON to a Y.XmlFragment\n *\n * This can be used when importing existing content to Y.Doc for the first time,\n * note that this should not be used to rehydrate a Y.Doc from a database once\n * collaboration has begun as all history will be lost\n *\n * @param {Schema} schema\n * @param {any} state\n * @param {Y.XmlFragment} [xmlFragment] If supplied, an xml fragment to be\n *   populated from the prosemirror state; otherwise a new XmlFragment will be created.\n * @return {Y.XmlFragment}\n */\nfunction prosemirrorJSONToYXmlFragment (schema, state, xmlFragment) {\n  const doc = prosemirror_model__WEBPACK_IMPORTED_MODULE_6__.Node.fromJSON(schema, state)\n  return prosemirrorToYXmlFragment(doc, xmlFragment)\n}\n\n/**\n * @deprecated Use `yXmlFragmentToProseMirrorRootNode` instead\n *\n * Utility method to convert a Y.Doc to a Prosemirror Doc node.\n *\n * @param {Schema} schema\n * @param {Y.Doc} ydoc\n * @return {Node}\n */\nfunction yDocToProsemirror (schema, ydoc) {\n  const state = yDocToProsemirrorJSON(ydoc)\n  return prosemirror_model__WEBPACK_IMPORTED_MODULE_6__.Node.fromJSON(schema, state)\n}\n\n/**\n *\n * @deprecated Use `yXmlFragmentToProseMirrorRootNode` instead\n *\n * Utility method to convert a Y.XmlFragment to a Prosemirror Doc node.\n *\n * @param {Schema} schema\n * @param {Y.XmlFragment} xmlFragment\n * @return {Node}\n */\nfunction yXmlFragmentToProsemirror (schema, xmlFragment) {\n  const state = yXmlFragmentToProsemirrorJSON(xmlFragment)\n  return prosemirror_model__WEBPACK_IMPORTED_MODULE_6__.Node.fromJSON(schema, state)\n}\n\n/**\n *\n * @deprecated Use `yXmlFragmentToProseMirrorRootNode` instead\n *\n * Utility method to convert a Y.Doc to Prosemirror compatible JSON.\n *\n * @param {Y.Doc} ydoc\n * @param {string} xmlFragment\n * @return {Record<string, any>}\n */\nfunction yDocToProsemirrorJSON (\n  ydoc,\n  xmlFragment = 'prosemirror'\n) {\n  return yXmlFragmentToProsemirrorJSON(ydoc.getXmlFragment(xmlFragment))\n}\n\n/**\n * @deprecated Use `yXmlFragmentToProseMirrorRootNode` instead\n *\n * Utility method to convert a Y.Doc to Prosemirror compatible JSON.\n *\n * @param {Y.XmlFragment} xmlFragment The fragment, which must be part of a Y.Doc.\n * @return {Record<string, any>}\n */\nfunction yXmlFragmentToProsemirrorJSON (xmlFragment) {\n  const items = xmlFragment.toArray()\n\n  function serialize (item) {\n    /**\n     * @type {Object} NodeObject\n     * @property {string} NodeObject.type\n     * @property {Record<string, string>=} NodeObject.attrs\n     * @property {Array<NodeObject>=} NodeObject.content\n     */\n    let response\n\n    // TODO: Must be a better way to detect text nodes than this\n    if (!item.nodeName) {\n      const delta = item.toDelta()\n      response = delta.map((d) => {\n        const text = {\n          type: 'text',\n          text: d.insert\n        }\n\n        if (d.attributes) {\n          text.marks = Object.keys(d.attributes).map((type) => {\n            const attrs = d.attributes[type]\n            const mark = {\n              type\n            }\n\n            if (Object.keys(attrs)) {\n              mark.attrs = attrs\n            }\n\n            return mark\n          })\n        }\n        return text\n      })\n    } else {\n      response = {\n        type: item.nodeName\n      }\n\n      const attrs = item.getAttributes()\n      if (Object.keys(attrs).length) {\n        response.attrs = attrs\n      }\n\n      const children = item.toArray()\n      if (children.length) {\n        response.content = children.map(serialize).flat()\n      }\n    }\n\n    return response\n  }\n\n  return {\n    type: 'doc',\n    content: items.map(serialize)\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveS1wcm9zZW1pcnJvci9zcmMvbGliLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFrRjtBQUNoQztBQUMxQjtBQUNxQjtBQUNhO0FBQ3ZCO0FBQ0o7QUFDWTs7QUFFM0M7QUFDQTtBQUNBLGFBQWEseUNBQXlDO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsZ0NBQWdDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0REFBYztBQUNwQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFTztBQUNQO0FBQ0E7QUFDQSxJQUFJLG1EQUFpQjtBQUNyQjtBQUNBLEVBQUUsb0RBQWtCLHNCQUFzQiw0Q0FBVTtBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsb0JBQW9CO0FBQy9CLFlBQVksS0FBSztBQUNqQjtBQUNPO0FBQ1A7QUFDQSxXQUFXLG9FQUFxQztBQUNoRDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsbURBQW1ELGVBQWU7QUFDbEU7QUFDQSxxQkFBcUIsd0NBQVM7QUFDOUI7QUFDQSxlQUFlLG9FQUFxQztBQUNwRCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGVBQWU7QUFDdEMsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsbURBQW1ELGVBQWU7QUFDbEU7QUFDQTtBQUNBLE1BQU07QUFDTixtQ0FBbUMsS0FBSyx3QkFBd0IsYUFBYTtBQUM3RTtBQUNBLHVCQUF1QixlQUFlO0FBQ3RDO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxxQkFBcUIsaURBQWtCLDBEQUEwRCxnREFBaUI7QUFDbEg7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGVBQWU7QUFDeEMsVUFBVTtBQUNW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LFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsZUFBZTtBQUMxQiwyQ0FBMkM7QUFDM0MsWUFBWTtBQUNaO0FBQ087QUFDUCxjQUFjLG1EQUFJO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBLFNBQVMsbURBQUk7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxlQUFlO0FBQzFCLFlBQVk7QUFDWjtBQUNPO0FBQ1A7QUFDQSxTQUFTLG1EQUFJO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixZQUFZO0FBQ1o7QUFDTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsa0JBQWtCLFFBQVE7QUFDMUIsa0JBQWtCLHlCQUF5QjtBQUMzQyxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLzI4X25vdGlvbi1jbG9uZS8uL25vZGVfbW9kdWxlcy95LXByb3NlbWlycm9yL3NyYy9saWIuanM/YTZiYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1cGRhdGVZRnJhZ21lbnQsIGNyZWF0ZU5vZGVGcm9tWUVsZW1lbnQgfSBmcm9tICcuL3BsdWdpbnMvc3luYy1wbHVnaW4uanMnIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbmltcG9ydCB7IHlTeW5jUGx1Z2luS2V5IH0gZnJvbSAnLi9wbHVnaW5zL2tleXMuanMnXG5pbXBvcnQgKiBhcyBZIGZyb20gJ3lqcydcbmltcG9ydCB7IEVkaXRvclZpZXcgfSBmcm9tICdwcm9zZW1pcnJvci12aWV3JyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5pbXBvcnQgeyBOb2RlLCBTY2hlbWEsIEZyYWdtZW50IH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbmltcG9ydCAqIGFzIGVycm9yIGZyb20gJ2xpYjAvZXJyb3InXG5pbXBvcnQgKiBhcyBtYXAgZnJvbSAnbGliMC9tYXAnXG5pbXBvcnQgKiBhcyBldmVudGxvb3AgZnJvbSAnbGliMC9ldmVudGxvb3AnXG5cbi8qKlxuICogRWl0aGVyIGEgbm9kZSBpZiB0eXBlIGlzIFlYbWxFbGVtZW50IG9yIGFuIEFycmF5IG9mIHRleHQgbm9kZXMgaWYgWVhtbFRleHRcbiAqIEB0eXBlZGVmIHtNYXA8WS5BYnN0cmFjdFR5cGUsIE5vZGUgfCBBcnJheTxOb2RlPj59IFByb3NlbWlycm9yTWFwcGluZ1xuICovXG5cbi8qKlxuICogSXMgbnVsbCBpZiBubyB0aW1lb3V0IGlzIGluIHByb2dyZXNzLlxuICogSXMgZGVmaW5lZCBpZiBhIHRpbWVvdXQgaXMgaW4gcHJvZ3Jlc3MuXG4gKiBNYXBzIGZyb20gdmlld1xuICogQHR5cGUge01hcDxFZGl0b3JWaWV3LCBNYXA8YW55LCBhbnk+PnxudWxsfVxuICovXG5sZXQgdmlld3NUb1VwZGF0ZSA9IG51bGxcblxuY29uc3QgdXBkYXRlTWV0YXMgPSAoKSA9PiB7XG4gIGNvbnN0IHVwcyA9IC8qKiBAdHlwZSB7TWFwPEVkaXRvclZpZXcsIE1hcDxhbnksIGFueT4+fSAqLyAodmlld3NUb1VwZGF0ZSlcbiAgdmlld3NUb1VwZGF0ZSA9IG51bGxcbiAgdXBzLmZvckVhY2goKG1ldGFzLCB2aWV3KSA9PiB7XG4gICAgY29uc3QgdHIgPSB2aWV3LnN0YXRlLnRyXG4gICAgY29uc3Qgc3luY1N0YXRlID0geVN5bmNQbHVnaW5LZXkuZ2V0U3RhdGUodmlldy5zdGF0ZSlcbiAgICBpZiAoc3luY1N0YXRlICYmIHN5bmNTdGF0ZS5iaW5kaW5nICYmICFzeW5jU3RhdGUuYmluZGluZy5pc0Rlc3Ryb3llZCkge1xuICAgICAgbWV0YXMuZm9yRWFjaCgodmFsLCBrZXkpID0+IHtcbiAgICAgICAgdHIuc2V0TWV0YShrZXksIHZhbClcbiAgICAgIH0pXG4gICAgICB2aWV3LmRpc3BhdGNoKHRyKVxuICAgIH1cbiAgfSlcbn1cblxuZXhwb3J0IGNvbnN0IHNldE1ldGEgPSAodmlldywga2V5LCB2YWx1ZSkgPT4ge1xuICBpZiAoIXZpZXdzVG9VcGRhdGUpIHtcbiAgICB2aWV3c1RvVXBkYXRlID0gbmV3IE1hcCgpXG4gICAgZXZlbnRsb29wLnRpbWVvdXQoMCwgdXBkYXRlTWV0YXMpXG4gIH1cbiAgbWFwLnNldElmVW5kZWZpbmVkKHZpZXdzVG9VcGRhdGUsIHZpZXcsIG1hcC5jcmVhdGUpLnNldChrZXksIHZhbHVlKVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybXMgYSBQcm9zZW1pcnJvciBiYXNlZCBhYnNvbHV0ZSBwb3NpdGlvbiB0byBhIFlqcyBDdXJzb3IgKHJlbGF0aXZlIHBvc2l0aW9uIGluIHRoZSBZanMgbW9kZWwpLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3NcbiAqIEBwYXJhbSB7WS5YbWxGcmFnbWVudH0gdHlwZVxuICogQHBhcmFtIHtQcm9zZW1pcnJvck1hcHBpbmd9IG1hcHBpbmdcbiAqIEByZXR1cm4ge2FueX0gcmVsYXRpdmUgcG9zaXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGFic29sdXRlUG9zaXRpb25Ub1JlbGF0aXZlUG9zaXRpb24gPSAocG9zLCB0eXBlLCBtYXBwaW5nKSA9PiB7XG4gIGlmIChwb3MgPT09IDApIHtcbiAgICByZXR1cm4gWS5jcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbVR5cGVJbmRleCh0eXBlLCAwLCAtMSlcbiAgfVxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIGxldCBuID0gdHlwZS5fZmlyc3QgPT09IG51bGwgPyBudWxsIDogLyoqIEB0eXBlIHtZLkNvbnRlbnRUeXBlfSAqLyAodHlwZS5fZmlyc3QuY29udGVudCkudHlwZVxuICB3aGlsZSAobiAhPT0gbnVsbCAmJiB0eXBlICE9PSBuKSB7XG4gICAgaWYgKG4gaW5zdGFuY2VvZiBZLlhtbFRleHQpIHtcbiAgICAgIGlmIChuLl9sZW5ndGggPj0gcG9zKSB7XG4gICAgICAgIHJldHVybiBZLmNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tVHlwZUluZGV4KG4sIHBvcywgLTEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3MgLT0gbi5fbGVuZ3RoXG4gICAgICB9XG4gICAgICBpZiAobi5faXRlbSAhPT0gbnVsbCAmJiBuLl9pdGVtLm5leHQgIT09IG51bGwpIHtcbiAgICAgICAgbiA9IC8qKiBAdHlwZSB7WS5Db250ZW50VHlwZX0gKi8gKG4uX2l0ZW0ubmV4dC5jb250ZW50KS50eXBlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkbyB7XG4gICAgICAgICAgbiA9IG4uX2l0ZW0gPT09IG51bGwgPyBudWxsIDogbi5faXRlbS5wYXJlbnRcbiAgICAgICAgICBwb3MtLVxuICAgICAgICB9IHdoaWxlIChuICE9PSB0eXBlICYmIG4gIT09IG51bGwgJiYgbi5faXRlbSAhPT0gbnVsbCAmJiBuLl9pdGVtLm5leHQgPT09IG51bGwpXG4gICAgICAgIGlmIChuICE9PSBudWxsICYmIG4gIT09IHR5cGUpIHtcbiAgICAgICAgICAvLyBAdHMtZ25vcmUgd2Uga25vdyB0aGF0IG4ubmV4dCAhPT0gbnVsbCBiZWNhdXNlIG9mIGFib3ZlIGxvb3AgY29uZGl0aXRpb25cbiAgICAgICAgICBuID0gbi5faXRlbSA9PT0gbnVsbCA/IG51bGwgOiAvKiogQHR5cGUge1kuQ29udGVudFR5cGV9ICovICgvKiogQHR5cGUgWS5JdGVtICovIChuLl9pdGVtLm5leHQpLmNvbnRlbnQpLnR5cGVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwTm9kZVNpemUgPSAvKiogQHR5cGUge2FueX0gKi8gKG1hcHBpbmcuZ2V0KG4pIHx8IHsgbm9kZVNpemU6IDAgfSkubm9kZVNpemVcbiAgICAgIGlmIChuLl9maXJzdCAhPT0gbnVsbCAmJiBwb3MgPCBwTm9kZVNpemUpIHtcbiAgICAgICAgbiA9IC8qKiBAdHlwZSB7WS5Db250ZW50VHlwZX0gKi8gKG4uX2ZpcnN0LmNvbnRlbnQpLnR5cGVcbiAgICAgICAgcG9zLS1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwb3MgPT09IDEgJiYgbi5fbGVuZ3RoID09PSAwICYmIHBOb2RlU2l6ZSA+IDEpIHtcbiAgICAgICAgICAvLyBlZGdlIGNhc2UsIHNob3VsZCBlbmQgaW4gdGhpcyBwYXJhZ3JhcGhcbiAgICAgICAgICByZXR1cm4gbmV3IFkuUmVsYXRpdmVQb3NpdGlvbihuLl9pdGVtID09PSBudWxsID8gbnVsbCA6IG4uX2l0ZW0uaWQsIG4uX2l0ZW0gPT09IG51bGwgPyBZLmZpbmRSb290VHlwZUtleShuKSA6IG51bGwsIG51bGwpXG4gICAgICAgIH1cbiAgICAgICAgcG9zIC09IHBOb2RlU2l6ZVxuICAgICAgICBpZiAobi5faXRlbSAhPT0gbnVsbCAmJiBuLl9pdGVtLm5leHQgIT09IG51bGwpIHtcbiAgICAgICAgICBuID0gLyoqIEB0eXBlIHtZLkNvbnRlbnRUeXBlfSAqLyAobi5faXRlbS5uZXh0LmNvbnRlbnQpLnR5cGVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocG9zID09PSAwKSB7XG4gICAgICAgICAgICAvLyBzZXQgdG8gZW5kIG9mIG4ucGFyZW50XG4gICAgICAgICAgICBuID0gbi5faXRlbSA9PT0gbnVsbCA/IG4gOiBuLl9pdGVtLnBhcmVudFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBZLlJlbGF0aXZlUG9zaXRpb24obi5faXRlbSA9PT0gbnVsbCA/IG51bGwgOiBuLl9pdGVtLmlkLCBuLl9pdGVtID09PSBudWxsID8gWS5maW5kUm9vdFR5cGVLZXkobikgOiBudWxsLCBudWxsKVxuICAgICAgICAgIH1cbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBuID0gLyoqIEB0eXBlIHtZLkl0ZW19ICovIChuLl9pdGVtKS5wYXJlbnRcbiAgICAgICAgICAgIHBvcy0tXG4gICAgICAgICAgfSB3aGlsZSAobiAhPT0gdHlwZSAmJiAvKiogQHR5cGUge1kuSXRlbX0gKi8gKG4uX2l0ZW0pLm5leHQgPT09IG51bGwpXG4gICAgICAgICAgLy8gaWYgbiBpcyBudWxsIGF0IHRoaXMgcG9pbnQsIHdlIGhhdmUgYW4gdW5leHBlY3RlZCBjYXNlXG4gICAgICAgICAgaWYgKG4gIT09IHR5cGUpIHtcbiAgICAgICAgICAgIC8vIFdlIGtub3cgdGhhdCBuLl9pdGVtLm5leHQgaXMgZGVmaW5lZCBiZWNhdXNlIG9mIGFib3ZlIGxvb3AgY29uZGl0aW9uXG4gICAgICAgICAgICBuID0gLyoqIEB0eXBlIHtZLkNvbnRlbnRUeXBlfSAqLyAoLyoqIEB0eXBlIHtZLkl0ZW19ICovICgvKiogQHR5cGUge1kuSXRlbX0gKi8gKG4uX2l0ZW0pLm5leHQpLmNvbnRlbnQpLnR5cGVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG4gPT09IG51bGwpIHtcbiAgICAgIHRocm93IGVycm9yLnVuZXhwZWN0ZWRDYXNlKClcbiAgICB9XG4gICAgaWYgKHBvcyA9PT0gMCAmJiBuLmNvbnN0cnVjdG9yICE9PSBZLlhtbFRleHQgJiYgbiAhPT0gdHlwZSkgeyAvLyBUT0RPOiBzZXQgdG8gPD0gMFxuICAgICAgcmV0dXJuIGNyZWF0ZVJlbGF0aXZlUG9zaXRpb24obi5faXRlbS5wYXJlbnQsIG4uX2l0ZW0pXG4gICAgfVxuICB9XG4gIHJldHVybiBZLmNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tVHlwZUluZGV4KHR5cGUsIHR5cGUuX2xlbmd0aCwgLTEpXG59XG5cbmNvbnN0IGNyZWF0ZVJlbGF0aXZlUG9zaXRpb24gPSAodHlwZSwgaXRlbSkgPT4ge1xuICBsZXQgdHlwZWlkID0gbnVsbFxuICBsZXQgdG5hbWUgPSBudWxsXG4gIGlmICh0eXBlLl9pdGVtID09PSBudWxsKSB7XG4gICAgdG5hbWUgPSBZLmZpbmRSb290VHlwZUtleSh0eXBlKVxuICB9IGVsc2Uge1xuICAgIHR5cGVpZCA9IFkuY3JlYXRlSUQodHlwZS5faXRlbS5pZC5jbGllbnQsIHR5cGUuX2l0ZW0uaWQuY2xvY2spXG4gIH1cbiAgcmV0dXJuIG5ldyBZLlJlbGF0aXZlUG9zaXRpb24odHlwZWlkLCB0bmFtZSwgaXRlbS5pZClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1kuRG9jfSB5XG4gKiBAcGFyYW0ge1kuWG1sRnJhZ21lbnR9IGRvY3VtZW50VHlwZSBUb3AgbGV2ZWwgdHlwZSB0aGF0IGlzIGJvdW5kIHRvIHBWaWV3XG4gKiBAcGFyYW0ge2FueX0gcmVsUG9zIEVuY29kZWQgWWpzIGJhc2VkIHJlbGF0aXZlIHBvc2l0aW9uXG4gKiBAcGFyYW0ge1Byb3NlbWlycm9yTWFwcGluZ30gbWFwcGluZ1xuICogQHJldHVybiB7bnVsbHxudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCByZWxhdGl2ZVBvc2l0aW9uVG9BYnNvbHV0ZVBvc2l0aW9uID0gKHksIGRvY3VtZW50VHlwZSwgcmVsUG9zLCBtYXBwaW5nKSA9PiB7XG4gIGNvbnN0IGRlY29kZWRQb3MgPSBZLmNyZWF0ZUFic29sdXRlUG9zaXRpb25Gcm9tUmVsYXRpdmVQb3NpdGlvbihyZWxQb3MsIHkpXG4gIGlmIChkZWNvZGVkUG9zID09PSBudWxsIHx8IChkZWNvZGVkUG9zLnR5cGUgIT09IGRvY3VtZW50VHlwZSAmJiAhWS5pc1BhcmVudE9mKGRvY3VtZW50VHlwZSwgZGVjb2RlZFBvcy50eXBlLl9pdGVtKSkpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIGxldCB0eXBlID0gZGVjb2RlZFBvcy50eXBlXG4gIGxldCBwb3MgPSAwXG4gIGlmICh0eXBlLmNvbnN0cnVjdG9yID09PSBZLlhtbFRleHQpIHtcbiAgICBwb3MgPSBkZWNvZGVkUG9zLmluZGV4XG4gIH0gZWxzZSBpZiAodHlwZS5faXRlbSA9PT0gbnVsbCB8fCAhdHlwZS5faXRlbS5kZWxldGVkKSB7XG4gICAgbGV0IG4gPSB0eXBlLl9maXJzdFxuICAgIGxldCBpID0gMFxuICAgIHdoaWxlIChpIDwgdHlwZS5fbGVuZ3RoICYmIGkgPCBkZWNvZGVkUG9zLmluZGV4ICYmIG4gIT09IG51bGwpIHtcbiAgICAgIGlmICghbi5kZWxldGVkKSB7XG4gICAgICAgIGNvbnN0IHQgPSAvKiogQHR5cGUge1kuQ29udGVudFR5cGV9ICovIChuLmNvbnRlbnQpLnR5cGVcbiAgICAgICAgaSsrXG4gICAgICAgIGlmICh0IGluc3RhbmNlb2YgWS5YbWxUZXh0KSB7XG4gICAgICAgICAgcG9zICs9IHQuX2xlbmd0aFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBvcyArPSAvKiogQHR5cGUge2FueX0gKi8gKG1hcHBpbmcuZ2V0KHQpKS5ub2RlU2l6ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBuID0gLyoqIEB0eXBlIHtZLkl0ZW19ICovIChuLnJpZ2h0KVxuICAgIH1cbiAgICBwb3MgKz0gMSAvLyBpbmNyZWFzZSBiZWNhdXNlIHdlIGdvIG91dCBvZiBuXG4gIH1cbiAgd2hpbGUgKHR5cGUgIT09IGRvY3VtZW50VHlwZSAmJiB0eXBlLl9pdGVtICE9PSBudWxsKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IHBhcmVudCA9IHR5cGUuX2l0ZW0ucGFyZW50XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmIChwYXJlbnQuX2l0ZW0gPT09IG51bGwgfHwgIXBhcmVudC5faXRlbS5kZWxldGVkKSB7XG4gICAgICBwb3MgKz0gMSAvLyB0aGUgc3RhcnQgdGFnXG4gICAgICBsZXQgbiA9IC8qKiBAdHlwZSB7WS5BYnN0cmFjdFR5cGV9ICovIChwYXJlbnQpLl9maXJzdFxuICAgICAgLy8gbm93IGl0ZXJhdGUgdW50aWwgd2UgZm91bmQgdHlwZVxuICAgICAgd2hpbGUgKG4gIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgY29udGVudFR5cGUgPSAvKiogQHR5cGUge1kuQ29udGVudFR5cGV9ICovIChuLmNvbnRlbnQpLnR5cGVcbiAgICAgICAgaWYgKGNvbnRlbnRUeXBlID09PSB0eXBlKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW4uZGVsZXRlZCkge1xuICAgICAgICAgIGlmIChjb250ZW50VHlwZSBpbnN0YW5jZW9mIFkuWG1sVGV4dCkge1xuICAgICAgICAgICAgcG9zICs9IGNvbnRlbnRUeXBlLl9sZW5ndGhcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9zICs9IC8qKiBAdHlwZSB7YW55fSAqLyAobWFwcGluZy5nZXQoY29udGVudFR5cGUpKS5ub2RlU2l6ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuID0gbi5yaWdodFxuICAgICAgfVxuICAgIH1cbiAgICB0eXBlID0gLyoqIEB0eXBlIHtZLkFic3RyYWN0VHlwZX0gKi8gKHBhcmVudClcbiAgfVxuICByZXR1cm4gcG9zIC0gMSAvLyB3ZSBkb24ndCBjb3VudCB0aGUgbW9zdCBvdXRlciB0YWcsIGJlY2F1c2UgaXQgaXMgYSBmcmFnbWVudFxufVxuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIGNvbnZlcnRpbmcgYW4gWS5GcmFnbWVudCB0byBhIFByb3NlTWlycm9yIGZyYWdtZW50LlxuICpcbiAqIEBwYXJhbSB7WS5YbWxGcmFnbWVudH0geVhtbEZyYWdtZW50XG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKi9cbmV4cG9ydCBjb25zdCB5WG1sRnJhZ21lbnRUb1Byb3NlTWlycm9yRnJhZ21lbnQgPSAoeVhtbEZyYWdtZW50LCBzY2hlbWEpID0+IHtcbiAgY29uc3QgZnJhZ21lbnRDb250ZW50ID0geVhtbEZyYWdtZW50LnRvQXJyYXkoKS5tYXAoKHQpID0+XG4gICAgY3JlYXRlTm9kZUZyb21ZRWxlbWVudChcbiAgICAgIC8qKiBAdHlwZSB7WS5YbWxFbGVtZW50fSAqLyAodCksXG4gICAgICBzY2hlbWEsXG4gICAgICBuZXcgTWFwKClcbiAgICApXG4gICkuZmlsdGVyKChuKSA9PiBuICE9PSBudWxsKVxuICByZXR1cm4gRnJhZ21lbnQuZnJvbUFycmF5KGZyYWdtZW50Q29udGVudClcbn1cblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciBjb252ZXJ0aW5nIGFuIFkuRnJhZ21lbnQgdG8gYSBQcm9zZU1pcnJvciBub2RlLlxuICpcbiAqIEBwYXJhbSB7WS5YbWxGcmFnbWVudH0geVhtbEZyYWdtZW50XG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKi9cbmV4cG9ydCBjb25zdCB5WG1sRnJhZ21lbnRUb1Byb3NlTWlycm9yUm9vdE5vZGUgPSAoeVhtbEZyYWdtZW50LCBzY2hlbWEpID0+XG4gIHNjaGVtYS50b3BOb2RlVHlwZS5jcmVhdGUobnVsbCwgeVhtbEZyYWdtZW50VG9Qcm9zZU1pcnJvckZyYWdtZW50KHlYbWxGcmFnbWVudCwgc2NoZW1hKSlcblxuLyoqXG4gKiBUaGUgaW5pdGlhbCBQcm9zZU1pcnJvciBjb250ZW50IHNob3VsZCBiZSBzdXBwbGllZCBieSBZanMuIFRoaXMgZnVuY3Rpb24gdHJhbnNmb3JtcyBhIFkuRnJhZ21lbnRcbiAqIHRvIGEgUHJvc2VNaXJyb3IgRG9jIG5vZGUgYW5kIGNyZWF0ZXMgYSBtYXBwaW5nIHRoYXQgaXMgdXNlZCBieSB0aGUgc3luYyBwbHVnaW4uXG4gKlxuICogQHBhcmFtIHtZLlhtbEZyYWdtZW50fSB5WG1sRnJhZ21lbnRcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqL1xuZXhwb3J0IGNvbnN0IGluaXRQcm9zZU1pcnJvckRvYyA9ICh5WG1sRnJhZ21lbnQsIHNjaGVtYSkgPT4ge1xuICAvKipcbiAgICogQHR5cGUge1Byb3NlbWlycm9yTWFwcGluZ31cbiAgICovXG4gIGNvbnN0IG1hcHBpbmcgPSBuZXcgTWFwKClcbiAgY29uc3QgZnJhZ21lbnRDb250ZW50ID0geVhtbEZyYWdtZW50LnRvQXJyYXkoKS5tYXAoKHQpID0+XG4gICAgY3JlYXRlTm9kZUZyb21ZRWxlbWVudChcbiAgICAgIC8qKiBAdHlwZSB7WS5YbWxFbGVtZW50fSAqLyAodCksXG4gICAgICBzY2hlbWEsXG4gICAgICBtYXBwaW5nXG4gICAgKVxuICApLmZpbHRlcigobikgPT4gbiAhPT0gbnVsbClcbiAgY29uc3QgZG9jID0gc2NoZW1hLnRvcE5vZGVUeXBlLmNyZWF0ZShudWxsLCBGcmFnbWVudC5mcm9tQXJyYXkoZnJhZ21lbnRDb250ZW50KSlcbiAgcmV0dXJuIHsgZG9jLCBtYXBwaW5nIH1cbn1cblxuLyoqXG4gKiBVdGlsaXR5IG1ldGhvZCB0byBjb252ZXJ0IGEgUHJvc2VtaXJyb3IgRG9jIE5vZGUgaW50byBhIFkuRG9jLlxuICpcbiAqIFRoaXMgY2FuIGJlIHVzZWQgd2hlbiBpbXBvcnRpbmcgZXhpc3RpbmcgY29udGVudCB0byBZLkRvYyBmb3IgdGhlIGZpcnN0IHRpbWUsXG4gKiBub3RlIHRoYXQgdGhpcyBzaG91bGQgbm90IGJlIHVzZWQgdG8gcmVoeWRyYXRlIGEgWS5Eb2MgZnJvbSBhIGRhdGFiYXNlIG9uY2VcbiAqIGNvbGxhYm9yYXRpb24gaGFzIGJlZ3VuIGFzIGFsbCBoaXN0b3J5IHdpbGwgYmUgbG9zdFxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gZG9jXG4gKiBAcGFyYW0ge3N0cmluZ30geG1sRnJhZ21lbnRcbiAqIEByZXR1cm4ge1kuRG9jfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvc2VtaXJyb3JUb1lEb2MgKGRvYywgeG1sRnJhZ21lbnQgPSAncHJvc2VtaXJyb3InKSB7XG4gIGNvbnN0IHlkb2MgPSBuZXcgWS5Eb2MoKVxuICBjb25zdCB0eXBlID0gLyoqIEB0eXBlIHtZLlhtbEZyYWdtZW50fSAqLyAoeWRvYy5nZXQoeG1sRnJhZ21lbnQsIFkuWG1sRnJhZ21lbnQpKVxuICBpZiAoIXR5cGUuZG9jKSB7XG4gICAgcmV0dXJuIHlkb2NcbiAgfVxuXG4gIHByb3NlbWlycm9yVG9ZWG1sRnJhZ21lbnQoZG9jLCB0eXBlKVxuICByZXR1cm4gdHlwZS5kb2Ncbn1cblxuLyoqXG4gKiBVdGlsaXR5IG1ldGhvZCB0byB1cGRhdGUgYW4gZW1wdHkgWS5YbWxGcmFnbWVudCB3aXRoIGNvbnRlbnQgZnJvbSBhIFByb3NlbWlycm9yIERvYyBOb2RlLlxuICpcbiAqIFRoaXMgY2FuIGJlIHVzZWQgd2hlbiBpbXBvcnRpbmcgZXhpc3RpbmcgY29udGVudCB0byBZLkRvYyBmb3IgdGhlIGZpcnN0IHRpbWUsXG4gKiBub3RlIHRoYXQgdGhpcyBzaG91bGQgbm90IGJlIHVzZWQgdG8gcmVoeWRyYXRlIGEgWS5Eb2MgZnJvbSBhIGRhdGFiYXNlIG9uY2VcbiAqIGNvbGxhYm9yYXRpb24gaGFzIGJlZ3VuIGFzIGFsbCBoaXN0b3J5IHdpbGwgYmUgbG9zdFxuICpcbiAqIE5vdGU6IFRoZSBZLlhtbEZyYWdtZW50IGRvZXMgbm90IG5lZWQgdG8gYmUgcGFydCBvZiBhIFkuRG9jIGRvY3VtZW50IGF0IHRoZSB0aW1lIHRoYXQgdGhpc1xuICogbWV0aG9kIGlzIGNhbGxlZCwgYnV0IGl0IG11c3QgYmUgYWRkZWQgYmVmb3JlIGFueSBvdGhlciBvcGVyYXRpb25zIGFyZSBwZXJmb3JtZWQgb24gaXQuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBkb2MgcHJvc2VtaXJyb3IgZG9jdW1lbnQuXG4gKiBAcGFyYW0ge1kuWG1sRnJhZ21lbnR9IFt4bWxGcmFnbWVudF0gSWYgc3VwcGxpZWQsIGFuIHhtbCBmcmFnbWVudCB0byBiZVxuICogICBwb3B1bGF0ZWQgZnJvbSB0aGUgcHJvc2VtaXJyb3Igc3RhdGU7IG90aGVyd2lzZSBhIG5ldyBYbWxGcmFnbWVudCB3aWxsIGJlIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHtZLlhtbEZyYWdtZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvc2VtaXJyb3JUb1lYbWxGcmFnbWVudCAoZG9jLCB4bWxGcmFnbWVudCkge1xuICBjb25zdCB0eXBlID0geG1sRnJhZ21lbnQgfHwgbmV3IFkuWG1sRnJhZ21lbnQoKVxuICBjb25zdCB5ZG9jID0gdHlwZS5kb2MgPyB0eXBlLmRvYyA6IHsgdHJhbnNhY3Q6ICh0cmFuc2FjdGlvbikgPT4gdHJhbnNhY3Rpb24odW5kZWZpbmVkKSB9XG4gIHVwZGF0ZVlGcmFnbWVudCh5ZG9jLCB0eXBlLCBkb2MsIG5ldyBNYXAoKSlcbiAgcmV0dXJuIHR5cGVcbn1cblxuLyoqXG4gKiBVdGlsaXR5IG1ldGhvZCB0byBjb252ZXJ0IFByb3NlbWlycm9yIGNvbXBhdGlibGUgSlNPTiBpbnRvIGEgWS5Eb2MuXG4gKlxuICogVGhpcyBjYW4gYmUgdXNlZCB3aGVuIGltcG9ydGluZyBleGlzdGluZyBjb250ZW50IHRvIFkuRG9jIGZvciB0aGUgZmlyc3QgdGltZSxcbiAqIG5vdGUgdGhhdCB0aGlzIHNob3VsZCBub3QgYmUgdXNlZCB0byByZWh5ZHJhdGUgYSBZLkRvYyBmcm9tIGEgZGF0YWJhc2Ugb25jZVxuICogY29sbGFib3JhdGlvbiBoYXMgYmVndW4gYXMgYWxsIGhpc3Rvcnkgd2lsbCBiZSBsb3N0XG4gKlxuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYVxuICogQHBhcmFtIHthbnl9IHN0YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30geG1sRnJhZ21lbnRcbiAqIEByZXR1cm4ge1kuRG9jfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvc2VtaXJyb3JKU09OVG9ZRG9jIChzY2hlbWEsIHN0YXRlLCB4bWxGcmFnbWVudCA9ICdwcm9zZW1pcnJvcicpIHtcbiAgY29uc3QgZG9jID0gTm9kZS5mcm9tSlNPTihzY2hlbWEsIHN0YXRlKVxuICByZXR1cm4gcHJvc2VtaXJyb3JUb1lEb2MoZG9jLCB4bWxGcmFnbWVudClcbn1cblxuLyoqXG4gKiBVdGlsaXR5IG1ldGhvZCB0byBjb252ZXJ0IFByb3NlbWlycm9yIGNvbXBhdGlibGUgSlNPTiB0byBhIFkuWG1sRnJhZ21lbnRcbiAqXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHdoZW4gaW1wb3J0aW5nIGV4aXN0aW5nIGNvbnRlbnQgdG8gWS5Eb2MgZm9yIHRoZSBmaXJzdCB0aW1lLFxuICogbm90ZSB0aGF0IHRoaXMgc2hvdWxkIG5vdCBiZSB1c2VkIHRvIHJlaHlkcmF0ZSBhIFkuRG9jIGZyb20gYSBkYXRhYmFzZSBvbmNlXG4gKiBjb2xsYWJvcmF0aW9uIGhhcyBiZWd1biBhcyBhbGwgaGlzdG9yeSB3aWxsIGJlIGxvc3RcbiAqXG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKiBAcGFyYW0ge2FueX0gc3RhdGVcbiAqIEBwYXJhbSB7WS5YbWxGcmFnbWVudH0gW3htbEZyYWdtZW50XSBJZiBzdXBwbGllZCwgYW4geG1sIGZyYWdtZW50IHRvIGJlXG4gKiAgIHBvcHVsYXRlZCBmcm9tIHRoZSBwcm9zZW1pcnJvciBzdGF0ZTsgb3RoZXJ3aXNlIGEgbmV3IFhtbEZyYWdtZW50IHdpbGwgYmUgY3JlYXRlZC5cbiAqIEByZXR1cm4ge1kuWG1sRnJhZ21lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9zZW1pcnJvckpTT05Ub1lYbWxGcmFnbWVudCAoc2NoZW1hLCBzdGF0ZSwgeG1sRnJhZ21lbnQpIHtcbiAgY29uc3QgZG9jID0gTm9kZS5mcm9tSlNPTihzY2hlbWEsIHN0YXRlKVxuICByZXR1cm4gcHJvc2VtaXJyb3JUb1lYbWxGcmFnbWVudChkb2MsIHhtbEZyYWdtZW50KVxufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSBgeVhtbEZyYWdtZW50VG9Qcm9zZU1pcnJvclJvb3ROb2RlYCBpbnN0ZWFkXG4gKlxuICogVXRpbGl0eSBtZXRob2QgdG8gY29udmVydCBhIFkuRG9jIHRvIGEgUHJvc2VtaXJyb3IgRG9jIG5vZGUuXG4gKlxuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYVxuICogQHBhcmFtIHtZLkRvY30geWRvY1xuICogQHJldHVybiB7Tm9kZX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHlEb2NUb1Byb3NlbWlycm9yIChzY2hlbWEsIHlkb2MpIHtcbiAgY29uc3Qgc3RhdGUgPSB5RG9jVG9Qcm9zZW1pcnJvckpTT04oeWRvYylcbiAgcmV0dXJuIE5vZGUuZnJvbUpTT04oc2NoZW1hLCBzdGF0ZSlcbn1cblxuLyoqXG4gKlxuICogQGRlcHJlY2F0ZWQgVXNlIGB5WG1sRnJhZ21lbnRUb1Byb3NlTWlycm9yUm9vdE5vZGVgIGluc3RlYWRcbiAqXG4gKiBVdGlsaXR5IG1ldGhvZCB0byBjb252ZXJ0IGEgWS5YbWxGcmFnbWVudCB0byBhIFByb3NlbWlycm9yIERvYyBub2RlLlxuICpcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqIEBwYXJhbSB7WS5YbWxGcmFnbWVudH0geG1sRnJhZ21lbnRcbiAqIEByZXR1cm4ge05vZGV9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB5WG1sRnJhZ21lbnRUb1Byb3NlbWlycm9yIChzY2hlbWEsIHhtbEZyYWdtZW50KSB7XG4gIGNvbnN0IHN0YXRlID0geVhtbEZyYWdtZW50VG9Qcm9zZW1pcnJvckpTT04oeG1sRnJhZ21lbnQpXG4gIHJldHVybiBOb2RlLmZyb21KU09OKHNjaGVtYSwgc3RhdGUpXG59XG5cbi8qKlxuICpcbiAqIEBkZXByZWNhdGVkIFVzZSBgeVhtbEZyYWdtZW50VG9Qcm9zZU1pcnJvclJvb3ROb2RlYCBpbnN0ZWFkXG4gKlxuICogVXRpbGl0eSBtZXRob2QgdG8gY29udmVydCBhIFkuRG9jIHRvIFByb3NlbWlycm9yIGNvbXBhdGlibGUgSlNPTi5cbiAqXG4gKiBAcGFyYW0ge1kuRG9jfSB5ZG9jXG4gKiBAcGFyYW0ge3N0cmluZ30geG1sRnJhZ21lbnRcbiAqIEByZXR1cm4ge1JlY29yZDxzdHJpbmcsIGFueT59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB5RG9jVG9Qcm9zZW1pcnJvckpTT04gKFxuICB5ZG9jLFxuICB4bWxGcmFnbWVudCA9ICdwcm9zZW1pcnJvcidcbikge1xuICByZXR1cm4geVhtbEZyYWdtZW50VG9Qcm9zZW1pcnJvckpTT04oeWRvYy5nZXRYbWxGcmFnbWVudCh4bWxGcmFnbWVudCkpXG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIGB5WG1sRnJhZ21lbnRUb1Byb3NlTWlycm9yUm9vdE5vZGVgIGluc3RlYWRcbiAqXG4gKiBVdGlsaXR5IG1ldGhvZCB0byBjb252ZXJ0IGEgWS5Eb2MgdG8gUHJvc2VtaXJyb3IgY29tcGF0aWJsZSBKU09OLlxuICpcbiAqIEBwYXJhbSB7WS5YbWxGcmFnbWVudH0geG1sRnJhZ21lbnQgVGhlIGZyYWdtZW50LCB3aGljaCBtdXN0IGJlIHBhcnQgb2YgYSBZLkRvYy5cbiAqIEByZXR1cm4ge1JlY29yZDxzdHJpbmcsIGFueT59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB5WG1sRnJhZ21lbnRUb1Byb3NlbWlycm9ySlNPTiAoeG1sRnJhZ21lbnQpIHtcbiAgY29uc3QgaXRlbXMgPSB4bWxGcmFnbWVudC50b0FycmF5KClcblxuICBmdW5jdGlvbiBzZXJpYWxpemUgKGl0ZW0pIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7T2JqZWN0fSBOb2RlT2JqZWN0XG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IE5vZGVPYmplY3QudHlwZVxuICAgICAqIEBwcm9wZXJ0eSB7UmVjb3JkPHN0cmluZywgc3RyaW5nPj19IE5vZGVPYmplY3QuYXR0cnNcbiAgICAgKiBAcHJvcGVydHkge0FycmF5PE5vZGVPYmplY3Q+PX0gTm9kZU9iamVjdC5jb250ZW50XG4gICAgICovXG4gICAgbGV0IHJlc3BvbnNlXG5cbiAgICAvLyBUT0RPOiBNdXN0IGJlIGEgYmV0dGVyIHdheSB0byBkZXRlY3QgdGV4dCBub2RlcyB0aGFuIHRoaXNcbiAgICBpZiAoIWl0ZW0ubm9kZU5hbWUpIHtcbiAgICAgIGNvbnN0IGRlbHRhID0gaXRlbS50b0RlbHRhKClcbiAgICAgIHJlc3BvbnNlID0gZGVsdGEubWFwKChkKSA9PiB7XG4gICAgICAgIGNvbnN0IHRleHQgPSB7XG4gICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgIHRleHQ6IGQuaW5zZXJ0XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZC5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgdGV4dC5tYXJrcyA9IE9iamVjdC5rZXlzKGQuYXR0cmlidXRlcykubWFwKCh0eXBlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhdHRycyA9IGQuYXR0cmlidXRlc1t0eXBlXVxuICAgICAgICAgICAgY29uc3QgbWFyayA9IHtcbiAgICAgICAgICAgICAgdHlwZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoYXR0cnMpKSB7XG4gICAgICAgICAgICAgIG1hcmsuYXR0cnMgPSBhdHRyc1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbWFya1xuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHRcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3BvbnNlID0ge1xuICAgICAgICB0eXBlOiBpdGVtLm5vZGVOYW1lXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGF0dHJzID0gaXRlbS5nZXRBdHRyaWJ1dGVzKClcbiAgICAgIGlmIChPYmplY3Qua2V5cyhhdHRycykubGVuZ3RoKSB7XG4gICAgICAgIHJlc3BvbnNlLmF0dHJzID0gYXR0cnNcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2hpbGRyZW4gPSBpdGVtLnRvQXJyYXkoKVxuICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICByZXNwb25zZS5jb250ZW50ID0gY2hpbGRyZW4ubWFwKHNlcmlhbGl6ZSkuZmxhdCgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGU6ICdkb2MnLFxuICAgIGNvbnRlbnQ6IGl0ZW1zLm1hcChzZXJpYWxpemUpXG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/y-prosemirror/src/lib.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/y-prosemirror/src/plugins/cursor-plugin.js":
/*!*****************************************************************!*\
  !*** ./node_modules/y-prosemirror/src/plugins/cursor-plugin.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createDecorations: () => (/* binding */ createDecorations),\n/* harmony export */   defaultAwarenessStateFilter: () => (/* binding */ defaultAwarenessStateFilter),\n/* harmony export */   defaultCursorBuilder: () => (/* binding */ defaultCursorBuilder),\n/* harmony export */   defaultSelectionBuilder: () => (/* binding */ defaultSelectionBuilder),\n/* harmony export */   yCursorPlugin: () => (/* binding */ yCursorPlugin)\n/* harmony export */ });\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! yjs */ \"(ssr)/./node_modules/yjs/dist/yjs.mjs\");\n/* harmony import */ var prosemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-view */ \"(ssr)/./node_modules/prosemirror-view/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var y_protocols_awareness__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! y-protocols/awareness */ \"(ssr)/./node_modules/y-protocols/awareness.js\");\n/* harmony import */ var _lib_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib.js */ \"(ssr)/./node_modules/y-prosemirror/src/lib.js\");\n/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keys.js */ \"(ssr)/./node_modules/y-prosemirror/src/plugins/keys.js\");\n/* harmony import */ var lib0_math__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lib0/math */ \"(ssr)/./node_modules/lib0/math.js\");\n\n // eslint-disable-line\n // eslint-disable-line\n // eslint-disable-line\n\n\n\n\n\n/**\n * Default awareness state filter\n *\n * @param {number} currentClientId current client id\n * @param {number} userClientId user client id\n * @param {any} _user user data\n * @return {boolean}\n */\nconst defaultAwarenessStateFilter = (currentClientId, userClientId, _user) => currentClientId !== userClientId\n\n/**\n * Default generator for a cursor element\n *\n * @param {any} user user data\n * @return {HTMLElement}\n */\nconst defaultCursorBuilder = (user) => {\n  const cursor = document.createElement('span')\n  cursor.classList.add('ProseMirror-yjs-cursor')\n  cursor.setAttribute('style', `border-color: ${user.color}`)\n  const userDiv = document.createElement('div')\n  userDiv.setAttribute('style', `background-color: ${user.color}`)\n  userDiv.insertBefore(document.createTextNode(user.name), null)\n  const nonbreakingSpace1 = document.createTextNode('\\u2060')\n  const nonbreakingSpace2 = document.createTextNode('\\u2060')\n  cursor.insertBefore(nonbreakingSpace1, null)\n  cursor.insertBefore(userDiv, null)\n  cursor.insertBefore(nonbreakingSpace2, null)\n  return cursor\n}\n\n/**\n * Default generator for the selection attributes\n *\n * @param {any} user user data\n * @return {import('prosemirror-view').DecorationAttrs}\n */\nconst defaultSelectionBuilder = (user) => {\n  return {\n    style: `background-color: ${user.color}70`,\n    class: 'ProseMirror-yjs-selection'\n  }\n}\n\nconst rxValidColor = /^#[0-9a-fA-F]{6}$/\n\n/**\n * @param {any} state\n * @param {Awareness} awareness\n * @param {function(number, number, any):boolean} awarenessFilter\n * @param {function({ name: string, color: string }):Element} createCursor\n * @param {function({ name: string, color: string }):import('prosemirror-view').DecorationAttrs} createSelection\n * @return {any} DecorationSet\n */\nconst createDecorations = (\n  state,\n  awareness,\n  awarenessFilter,\n  createCursor,\n  createSelection\n) => {\n  const ystate = _keys_js__WEBPACK_IMPORTED_MODULE_1__.ySyncPluginKey.getState(state)\n  const y = ystate.doc\n  const decorations = []\n  if (\n    ystate.snapshot != null || ystate.prevSnapshot != null ||\n    ystate.binding.mapping.size === 0\n  ) {\n    // do not render cursors while snapshot is active\n    return prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.DecorationSet.create(state.doc, [])\n  }\n  awareness.getStates().forEach((aw, clientId) => {\n    if (!awarenessFilter(y.clientID, clientId, aw)) {\n      return\n    }\n\n    if (aw.cursor != null) {\n      const user = aw.user || {}\n      if (user.color == null) {\n        user.color = '#ffa500'\n      } else if (!rxValidColor.test(user.color)) {\n        // We only support 6-digit RGB colors in y-prosemirror\n        console.warn('A user uses an unsupported color format', user)\n      }\n      if (user.name == null) {\n        user.name = `User: ${clientId}`\n      }\n      let anchor = (0,_lib_js__WEBPACK_IMPORTED_MODULE_3__.relativePositionToAbsolutePosition)(\n        y,\n        ystate.type,\n        yjs__WEBPACK_IMPORTED_MODULE_4__.createRelativePositionFromJSON(aw.cursor.anchor),\n        ystate.binding.mapping\n      )\n      let head = (0,_lib_js__WEBPACK_IMPORTED_MODULE_3__.relativePositionToAbsolutePosition)(\n        y,\n        ystate.type,\n        yjs__WEBPACK_IMPORTED_MODULE_4__.createRelativePositionFromJSON(aw.cursor.head),\n        ystate.binding.mapping\n      )\n      if (anchor !== null && head !== null) {\n        const maxsize = lib0_math__WEBPACK_IMPORTED_MODULE_5__.max(state.doc.content.size - 1, 0)\n        anchor = lib0_math__WEBPACK_IMPORTED_MODULE_5__.min(anchor, maxsize)\n        head = lib0_math__WEBPACK_IMPORTED_MODULE_5__.min(head, maxsize)\n        decorations.push(\n          prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.widget(head, () => createCursor(user), {\n            key: clientId + '',\n            side: 10\n          })\n        )\n        const from = lib0_math__WEBPACK_IMPORTED_MODULE_5__.min(anchor, head)\n        const to = lib0_math__WEBPACK_IMPORTED_MODULE_5__.max(anchor, head)\n        decorations.push(\n          prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.inline(from, to, createSelection(user), {\n            inclusiveEnd: true,\n            inclusiveStart: false\n          })\n        )\n      }\n    }\n  })\n  return prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.DecorationSet.create(state.doc, decorations)\n}\n\n/**\n * A prosemirror plugin that listens to awareness information on Yjs.\n * This requires that a `prosemirrorPlugin` is also bound to the prosemirror.\n *\n * @public\n * @param {Awareness} awareness\n * @param {object} opts\n * @param {function(any, any, any):boolean} [opts.awarenessStateFilter]\n * @param {function(any):HTMLElement} [opts.cursorBuilder]\n * @param {function(any):import('prosemirror-view').DecorationAttrs} [opts.selectionBuilder]\n * @param {function(any):any} [opts.getSelection]\n * @param {string} [cursorStateField] By default all editor bindings use the awareness 'cursor' field to propagate cursor information.\n * @return {any}\n */\nconst yCursorPlugin = (\n  awareness,\n  {\n    awarenessStateFilter = defaultAwarenessStateFilter,\n    cursorBuilder = defaultCursorBuilder,\n    selectionBuilder = defaultSelectionBuilder,\n    getSelection = (state) => state.selection\n  } = {},\n  cursorStateField = 'cursor'\n) =>\n  new prosemirror_state__WEBPACK_IMPORTED_MODULE_6__.Plugin({\n    key: _keys_js__WEBPACK_IMPORTED_MODULE_1__.yCursorPluginKey,\n    state: {\n      init (_, state) {\n        return createDecorations(\n          state,\n          awareness,\n          awarenessStateFilter,\n          cursorBuilder,\n          selectionBuilder\n        )\n      },\n      apply (tr, prevState, _oldState, newState) {\n        const ystate = _keys_js__WEBPACK_IMPORTED_MODULE_1__.ySyncPluginKey.getState(newState)\n        const yCursorState = tr.getMeta(_keys_js__WEBPACK_IMPORTED_MODULE_1__.yCursorPluginKey)\n        if (\n          (ystate && ystate.isChangeOrigin) ||\n          (yCursorState && yCursorState.awarenessUpdated)\n        ) {\n          return createDecorations(\n            newState,\n            awareness,\n            awarenessStateFilter,\n            cursorBuilder,\n            selectionBuilder\n          )\n        }\n        return prevState.map(tr.mapping, tr.doc)\n      }\n    },\n    props: {\n      decorations: (state) => {\n        return _keys_js__WEBPACK_IMPORTED_MODULE_1__.yCursorPluginKey.getState(state)\n      }\n    },\n    view: (view) => {\n      const awarenessListener = () => {\n        // @ts-ignore\n        if (view.docView) {\n          (0,_lib_js__WEBPACK_IMPORTED_MODULE_3__.setMeta)(view, _keys_js__WEBPACK_IMPORTED_MODULE_1__.yCursorPluginKey, { awarenessUpdated: true })\n        }\n      }\n      const updateCursorInfo = () => {\n        const ystate = _keys_js__WEBPACK_IMPORTED_MODULE_1__.ySyncPluginKey.getState(view.state)\n        // @note We make implicit checks when checking for the cursor property\n        const current = awareness.getLocalState() || {}\n        if (view.hasFocus()) {\n          const selection = getSelection(view.state)\n          /**\n           * @type {Y.RelativePosition}\n           */\n          const anchor = (0,_lib_js__WEBPACK_IMPORTED_MODULE_3__.absolutePositionToRelativePosition)(\n            selection.anchor,\n            ystate.type,\n            ystate.binding.mapping\n          )\n          /**\n           * @type {Y.RelativePosition}\n           */\n          const head = (0,_lib_js__WEBPACK_IMPORTED_MODULE_3__.absolutePositionToRelativePosition)(\n            selection.head,\n            ystate.type,\n            ystate.binding.mapping\n          )\n          if (\n            current.cursor == null ||\n            !yjs__WEBPACK_IMPORTED_MODULE_4__.compareRelativePositions(\n              yjs__WEBPACK_IMPORTED_MODULE_4__.createRelativePositionFromJSON(current.cursor.anchor),\n              anchor\n            ) ||\n            !yjs__WEBPACK_IMPORTED_MODULE_4__.compareRelativePositions(\n              yjs__WEBPACK_IMPORTED_MODULE_4__.createRelativePositionFromJSON(current.cursor.head),\n              head\n            )\n          ) {\n            awareness.setLocalStateField(cursorStateField, {\n              anchor,\n              head\n            })\n          }\n        } else if (\n          current.cursor != null &&\n          (0,_lib_js__WEBPACK_IMPORTED_MODULE_3__.relativePositionToAbsolutePosition)(\n            ystate.doc,\n            ystate.type,\n            yjs__WEBPACK_IMPORTED_MODULE_4__.createRelativePositionFromJSON(current.cursor.anchor),\n            ystate.binding.mapping\n          ) !== null\n        ) {\n          // delete cursor information if current cursor information is owned by this editor binding\n          awareness.setLocalStateField(cursorStateField, null)\n        }\n      }\n      awareness.on('change', awarenessListener)\n      view.dom.addEventListener('focusin', updateCursorInfo)\n      view.dom.addEventListener('focusout', updateCursorInfo)\n      return {\n        update: updateCursorInfo,\n        destroy: () => {\n          view.dom.removeEventListener('focusin', updateCursorInfo)\n          view.dom.removeEventListener('focusout', updateCursorInfo)\n          awareness.off('change', awarenessListener)\n          awareness.setLocalStateField(cursorStateField, null)\n        }\n      }\n    }\n  })\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveS1wcm9zZW1pcnJvci9zcmMvcGx1Z2lucy9jdXJzb3ItcGx1Z2luLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUF3QjtBQUNxQyxDQUFDO0FBQ25CLENBQUM7QUFDTSxDQUFDO0FBS2pDO0FBQzBDOztBQUUzQjs7QUFFakM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLEtBQUs7QUFDaEIsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFlBQVk7QUFDWjtBQUNPO0FBQ1A7QUFDQTtBQUNBLGdEQUFnRCxXQUFXO0FBQzNEO0FBQ0EscURBQXFELFdBQVc7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBLGdDQUFnQyxXQUFXO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0MsRUFBRTs7QUFFdEM7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsdUNBQXVDO0FBQ2xELFdBQVcsV0FBVyw2QkFBNkIsV0FBVztBQUM5RCxXQUFXLFdBQVcsNkJBQTZCLDhDQUE4QztBQUNqRyxZQUFZLEtBQUs7QUFDakI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixvREFBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMkRBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixTQUFTO0FBQ3RDO0FBQ0EsbUJBQW1CLDJFQUFrQztBQUNyRDtBQUNBO0FBQ0EsUUFBUSwrREFBZ0M7QUFDeEM7QUFDQTtBQUNBLGlCQUFpQiwyRUFBa0M7QUFDbkQ7QUFDQTtBQUNBLFFBQVEsK0RBQWdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwQ0FBUTtBQUNoQyxpQkFBaUIsMENBQVE7QUFDekIsZUFBZSwwQ0FBUTtBQUN2QjtBQUNBLFVBQVUsd0RBQVU7QUFDcEI7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLHFCQUFxQiwwQ0FBUTtBQUM3QixtQkFBbUIsMENBQVE7QUFDM0I7QUFDQSxVQUFVLHdEQUFVO0FBQ3BCO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFNBQVMsMkRBQWE7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQ0FBaUM7QUFDNUMsV0FBVywyQkFBMkI7QUFDdEMsV0FBVywwREFBMEQ7QUFDckUsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBLE1BQU0scURBQU07QUFDWixTQUFTLHNEQUFnQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSx1QkFBdUIsb0RBQWM7QUFDckMsd0NBQXdDLHNEQUFnQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxlQUFlLHNEQUFnQjtBQUMvQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0RBQU8sT0FBTyxzREFBZ0IsSUFBSSx3QkFBd0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9EQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSx5QkFBeUIsMkVBQWtDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSx1QkFBdUIsMkVBQWtDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEseURBQTBCO0FBQ3ZDLGNBQWMsK0RBQWdDO0FBQzlDO0FBQ0E7QUFDQSxhQUFhLHlEQUEwQjtBQUN2QyxjQUFjLCtEQUFnQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVLDJFQUFrQztBQUM1QztBQUNBO0FBQ0EsWUFBWSwrREFBZ0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8yOF9ub3Rpb24tY2xvbmUvLi9ub2RlX21vZHVsZXMveS1wcm9zZW1pcnJvci9zcmMvcGx1Z2lucy9jdXJzb3ItcGx1Z2luLmpzPzdjMmQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgWSBmcm9tICd5anMnXG5pbXBvcnQgeyBEZWNvcmF0aW9uLCBEZWNvcmF0aW9uU2V0IH0gZnJvbSBcInByb3NlbWlycm9yLXZpZXdcIjsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuaW1wb3J0IHsgUGx1Z2luIH0gZnJvbSBcInByb3NlbWlycm9yLXN0YXRlXCI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbmltcG9ydCB7IEF3YXJlbmVzcyB9IGZyb20gXCJ5LXByb3RvY29scy9hd2FyZW5lc3NcIjsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuaW1wb3J0IHtcbiAgYWJzb2x1dGVQb3NpdGlvblRvUmVsYXRpdmVQb3NpdGlvbixcbiAgcmVsYXRpdmVQb3NpdGlvblRvQWJzb2x1dGVQb3NpdGlvbixcbiAgc2V0TWV0YVxufSBmcm9tICcuLi9saWIuanMnXG5pbXBvcnQgeyB5Q3Vyc29yUGx1Z2luS2V5LCB5U3luY1BsdWdpbktleSB9IGZyb20gJy4va2V5cy5qcydcblxuaW1wb3J0ICogYXMgbWF0aCBmcm9tICdsaWIwL21hdGgnXG5cbi8qKlxuICogRGVmYXVsdCBhd2FyZW5lc3Mgc3RhdGUgZmlsdGVyXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGN1cnJlbnRDbGllbnRJZCBjdXJyZW50IGNsaWVudCBpZFxuICogQHBhcmFtIHtudW1iZXJ9IHVzZXJDbGllbnRJZCB1c2VyIGNsaWVudCBpZFxuICogQHBhcmFtIHthbnl9IF91c2VyIHVzZXIgZGF0YVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRBd2FyZW5lc3NTdGF0ZUZpbHRlciA9IChjdXJyZW50Q2xpZW50SWQsIHVzZXJDbGllbnRJZCwgX3VzZXIpID0+IGN1cnJlbnRDbGllbnRJZCAhPT0gdXNlckNsaWVudElkXG5cbi8qKlxuICogRGVmYXVsdCBnZW5lcmF0b3IgZm9yIGEgY3Vyc29yIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0ge2FueX0gdXNlciB1c2VyIGRhdGFcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICovXG5leHBvcnQgY29uc3QgZGVmYXVsdEN1cnNvckJ1aWxkZXIgPSAodXNlcikgPT4ge1xuICBjb25zdCBjdXJzb3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJylcbiAgY3Vyc29yLmNsYXNzTGlzdC5hZGQoJ1Byb3NlTWlycm9yLXlqcy1jdXJzb3InKVxuICBjdXJzb3Iuc2V0QXR0cmlidXRlKCdzdHlsZScsIGBib3JkZXItY29sb3I6ICR7dXNlci5jb2xvcn1gKVxuICBjb25zdCB1c2VyRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgdXNlckRpdi5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgYGJhY2tncm91bmQtY29sb3I6ICR7dXNlci5jb2xvcn1gKVxuICB1c2VyRGl2Lmluc2VydEJlZm9yZShkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh1c2VyLm5hbWUpLCBudWxsKVxuICBjb25zdCBub25icmVha2luZ1NwYWNlMSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdcXHUyMDYwJylcbiAgY29uc3Qgbm9uYnJlYWtpbmdTcGFjZTIgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnXFx1MjA2MCcpXG4gIGN1cnNvci5pbnNlcnRCZWZvcmUobm9uYnJlYWtpbmdTcGFjZTEsIG51bGwpXG4gIGN1cnNvci5pbnNlcnRCZWZvcmUodXNlckRpdiwgbnVsbClcbiAgY3Vyc29yLmluc2VydEJlZm9yZShub25icmVha2luZ1NwYWNlMiwgbnVsbClcbiAgcmV0dXJuIGN1cnNvclxufVxuXG4vKipcbiAqIERlZmF1bHQgZ2VuZXJhdG9yIGZvciB0aGUgc2VsZWN0aW9uIGF0dHJpYnV0ZXNcbiAqXG4gKiBAcGFyYW0ge2FueX0gdXNlciB1c2VyIGRhdGFcbiAqIEByZXR1cm4ge2ltcG9ydCgncHJvc2VtaXJyb3ItdmlldycpLkRlY29yYXRpb25BdHRyc31cbiAqL1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRTZWxlY3Rpb25CdWlsZGVyID0gKHVzZXIpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBzdHlsZTogYGJhY2tncm91bmQtY29sb3I6ICR7dXNlci5jb2xvcn03MGAsXG4gICAgY2xhc3M6ICdQcm9zZU1pcnJvci15anMtc2VsZWN0aW9uJ1xuICB9XG59XG5cbmNvbnN0IHJ4VmFsaWRDb2xvciA9IC9eI1swLTlhLWZBLUZdezZ9JC9cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gc3RhdGVcbiAqIEBwYXJhbSB7QXdhcmVuZXNzfSBhd2FyZW5lc3NcbiAqIEBwYXJhbSB7ZnVuY3Rpb24obnVtYmVyLCBudW1iZXIsIGFueSk6Ym9vbGVhbn0gYXdhcmVuZXNzRmlsdGVyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHsgbmFtZTogc3RyaW5nLCBjb2xvcjogc3RyaW5nIH0pOkVsZW1lbnR9IGNyZWF0ZUN1cnNvclxuICogQHBhcmFtIHtmdW5jdGlvbih7IG5hbWU6IHN0cmluZywgY29sb3I6IHN0cmluZyB9KTppbXBvcnQoJ3Byb3NlbWlycm9yLXZpZXcnKS5EZWNvcmF0aW9uQXR0cnN9IGNyZWF0ZVNlbGVjdGlvblxuICogQHJldHVybiB7YW55fSBEZWNvcmF0aW9uU2V0XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVEZWNvcmF0aW9ucyA9IChcbiAgc3RhdGUsXG4gIGF3YXJlbmVzcyxcbiAgYXdhcmVuZXNzRmlsdGVyLFxuICBjcmVhdGVDdXJzb3IsXG4gIGNyZWF0ZVNlbGVjdGlvblxuKSA9PiB7XG4gIGNvbnN0IHlzdGF0ZSA9IHlTeW5jUGx1Z2luS2V5LmdldFN0YXRlKHN0YXRlKVxuICBjb25zdCB5ID0geXN0YXRlLmRvY1xuICBjb25zdCBkZWNvcmF0aW9ucyA9IFtdXG4gIGlmIChcbiAgICB5c3RhdGUuc25hcHNob3QgIT0gbnVsbCB8fCB5c3RhdGUucHJldlNuYXBzaG90ICE9IG51bGwgfHxcbiAgICB5c3RhdGUuYmluZGluZy5tYXBwaW5nLnNpemUgPT09IDBcbiAgKSB7XG4gICAgLy8gZG8gbm90IHJlbmRlciBjdXJzb3JzIHdoaWxlIHNuYXBzaG90IGlzIGFjdGl2ZVxuICAgIHJldHVybiBEZWNvcmF0aW9uU2V0LmNyZWF0ZShzdGF0ZS5kb2MsIFtdKVxuICB9XG4gIGF3YXJlbmVzcy5nZXRTdGF0ZXMoKS5mb3JFYWNoKChhdywgY2xpZW50SWQpID0+IHtcbiAgICBpZiAoIWF3YXJlbmVzc0ZpbHRlcih5LmNsaWVudElELCBjbGllbnRJZCwgYXcpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoYXcuY3Vyc29yICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHVzZXIgPSBhdy51c2VyIHx8IHt9XG4gICAgICBpZiAodXNlci5jb2xvciA9PSBudWxsKSB7XG4gICAgICAgIHVzZXIuY29sb3IgPSAnI2ZmYTUwMCdcbiAgICAgIH0gZWxzZSBpZiAoIXJ4VmFsaWRDb2xvci50ZXN0KHVzZXIuY29sb3IpKSB7XG4gICAgICAgIC8vIFdlIG9ubHkgc3VwcG9ydCA2LWRpZ2l0IFJHQiBjb2xvcnMgaW4geS1wcm9zZW1pcnJvclxuICAgICAgICBjb25zb2xlLndhcm4oJ0EgdXNlciB1c2VzIGFuIHVuc3VwcG9ydGVkIGNvbG9yIGZvcm1hdCcsIHVzZXIpXG4gICAgICB9XG4gICAgICBpZiAodXNlci5uYW1lID09IG51bGwpIHtcbiAgICAgICAgdXNlci5uYW1lID0gYFVzZXI6ICR7Y2xpZW50SWR9YFxuICAgICAgfVxuICAgICAgbGV0IGFuY2hvciA9IHJlbGF0aXZlUG9zaXRpb25Ub0Fic29sdXRlUG9zaXRpb24oXG4gICAgICAgIHksXG4gICAgICAgIHlzdGF0ZS50eXBlLFxuICAgICAgICBZLmNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tSlNPTihhdy5jdXJzb3IuYW5jaG9yKSxcbiAgICAgICAgeXN0YXRlLmJpbmRpbmcubWFwcGluZ1xuICAgICAgKVxuICAgICAgbGV0IGhlYWQgPSByZWxhdGl2ZVBvc2l0aW9uVG9BYnNvbHV0ZVBvc2l0aW9uKFxuICAgICAgICB5LFxuICAgICAgICB5c3RhdGUudHlwZSxcbiAgICAgICAgWS5jcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbUpTT04oYXcuY3Vyc29yLmhlYWQpLFxuICAgICAgICB5c3RhdGUuYmluZGluZy5tYXBwaW5nXG4gICAgICApXG4gICAgICBpZiAoYW5jaG9yICE9PSBudWxsICYmIGhlYWQgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgbWF4c2l6ZSA9IG1hdGgubWF4KHN0YXRlLmRvYy5jb250ZW50LnNpemUgLSAxLCAwKVxuICAgICAgICBhbmNob3IgPSBtYXRoLm1pbihhbmNob3IsIG1heHNpemUpXG4gICAgICAgIGhlYWQgPSBtYXRoLm1pbihoZWFkLCBtYXhzaXplKVxuICAgICAgICBkZWNvcmF0aW9ucy5wdXNoKFxuICAgICAgICAgIERlY29yYXRpb24ud2lkZ2V0KGhlYWQsICgpID0+IGNyZWF0ZUN1cnNvcih1c2VyKSwge1xuICAgICAgICAgICAga2V5OiBjbGllbnRJZCArICcnLFxuICAgICAgICAgICAgc2lkZTogMTBcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICAgIGNvbnN0IGZyb20gPSBtYXRoLm1pbihhbmNob3IsIGhlYWQpXG4gICAgICAgIGNvbnN0IHRvID0gbWF0aC5tYXgoYW5jaG9yLCBoZWFkKVxuICAgICAgICBkZWNvcmF0aW9ucy5wdXNoKFxuICAgICAgICAgIERlY29yYXRpb24uaW5saW5lKGZyb20sIHRvLCBjcmVhdGVTZWxlY3Rpb24odXNlciksIHtcbiAgICAgICAgICAgIGluY2x1c2l2ZUVuZDogdHJ1ZSxcbiAgICAgICAgICAgIGluY2x1c2l2ZVN0YXJ0OiBmYWxzZVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBEZWNvcmF0aW9uU2V0LmNyZWF0ZShzdGF0ZS5kb2MsIGRlY29yYXRpb25zKVxufVxuXG4vKipcbiAqIEEgcHJvc2VtaXJyb3IgcGx1Z2luIHRoYXQgbGlzdGVucyB0byBhd2FyZW5lc3MgaW5mb3JtYXRpb24gb24gWWpzLlxuICogVGhpcyByZXF1aXJlcyB0aGF0IGEgYHByb3NlbWlycm9yUGx1Z2luYCBpcyBhbHNvIGJvdW5kIHRvIHRoZSBwcm9zZW1pcnJvci5cbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge0F3YXJlbmVzc30gYXdhcmVuZXNzXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0c1xuICogQHBhcmFtIHtmdW5jdGlvbihhbnksIGFueSwgYW55KTpib29sZWFufSBbb3B0cy5hd2FyZW5lc3NTdGF0ZUZpbHRlcl1cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oYW55KTpIVE1MRWxlbWVudH0gW29wdHMuY3Vyc29yQnVpbGRlcl1cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oYW55KTppbXBvcnQoJ3Byb3NlbWlycm9yLXZpZXcnKS5EZWNvcmF0aW9uQXR0cnN9IFtvcHRzLnNlbGVjdGlvbkJ1aWxkZXJdXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGFueSk6YW55fSBbb3B0cy5nZXRTZWxlY3Rpb25dXG4gKiBAcGFyYW0ge3N0cmluZ30gW2N1cnNvclN0YXRlRmllbGRdIEJ5IGRlZmF1bHQgYWxsIGVkaXRvciBiaW5kaW5ncyB1c2UgdGhlIGF3YXJlbmVzcyAnY3Vyc29yJyBmaWVsZCB0byBwcm9wYWdhdGUgY3Vyc29yIGluZm9ybWF0aW9uLlxuICogQHJldHVybiB7YW55fVxuICovXG5leHBvcnQgY29uc3QgeUN1cnNvclBsdWdpbiA9IChcbiAgYXdhcmVuZXNzLFxuICB7XG4gICAgYXdhcmVuZXNzU3RhdGVGaWx0ZXIgPSBkZWZhdWx0QXdhcmVuZXNzU3RhdGVGaWx0ZXIsXG4gICAgY3Vyc29yQnVpbGRlciA9IGRlZmF1bHRDdXJzb3JCdWlsZGVyLFxuICAgIHNlbGVjdGlvbkJ1aWxkZXIgPSBkZWZhdWx0U2VsZWN0aW9uQnVpbGRlcixcbiAgICBnZXRTZWxlY3Rpb24gPSAoc3RhdGUpID0+IHN0YXRlLnNlbGVjdGlvblxuICB9ID0ge30sXG4gIGN1cnNvclN0YXRlRmllbGQgPSAnY3Vyc29yJ1xuKSA9PlxuICBuZXcgUGx1Z2luKHtcbiAgICBrZXk6IHlDdXJzb3JQbHVnaW5LZXksXG4gICAgc3RhdGU6IHtcbiAgICAgIGluaXQgKF8sIHN0YXRlKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEZWNvcmF0aW9ucyhcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICBhd2FyZW5lc3MsXG4gICAgICAgICAgYXdhcmVuZXNzU3RhdGVGaWx0ZXIsXG4gICAgICAgICAgY3Vyc29yQnVpbGRlcixcbiAgICAgICAgICBzZWxlY3Rpb25CdWlsZGVyXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICBhcHBseSAodHIsIHByZXZTdGF0ZSwgX29sZFN0YXRlLCBuZXdTdGF0ZSkge1xuICAgICAgICBjb25zdCB5c3RhdGUgPSB5U3luY1BsdWdpbktleS5nZXRTdGF0ZShuZXdTdGF0ZSlcbiAgICAgICAgY29uc3QgeUN1cnNvclN0YXRlID0gdHIuZ2V0TWV0YSh5Q3Vyc29yUGx1Z2luS2V5KVxuICAgICAgICBpZiAoXG4gICAgICAgICAgKHlzdGF0ZSAmJiB5c3RhdGUuaXNDaGFuZ2VPcmlnaW4pIHx8XG4gICAgICAgICAgKHlDdXJzb3JTdGF0ZSAmJiB5Q3Vyc29yU3RhdGUuYXdhcmVuZXNzVXBkYXRlZClcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZURlY29yYXRpb25zKFxuICAgICAgICAgICAgbmV3U3RhdGUsXG4gICAgICAgICAgICBhd2FyZW5lc3MsXG4gICAgICAgICAgICBhd2FyZW5lc3NTdGF0ZUZpbHRlcixcbiAgICAgICAgICAgIGN1cnNvckJ1aWxkZXIsXG4gICAgICAgICAgICBzZWxlY3Rpb25CdWlsZGVyXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmV2U3RhdGUubWFwKHRyLm1hcHBpbmcsIHRyLmRvYylcbiAgICAgIH1cbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICBkZWNvcmF0aW9uczogKHN0YXRlKSA9PiB7XG4gICAgICAgIHJldHVybiB5Q3Vyc29yUGx1Z2luS2V5LmdldFN0YXRlKHN0YXRlKVxuICAgICAgfVxuICAgIH0sXG4gICAgdmlldzogKHZpZXcpID0+IHtcbiAgICAgIGNvbnN0IGF3YXJlbmVzc0xpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmICh2aWV3LmRvY1ZpZXcpIHtcbiAgICAgICAgICBzZXRNZXRhKHZpZXcsIHlDdXJzb3JQbHVnaW5LZXksIHsgYXdhcmVuZXNzVXBkYXRlZDogdHJ1ZSB9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCB1cGRhdGVDdXJzb3JJbmZvID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB5c3RhdGUgPSB5U3luY1BsdWdpbktleS5nZXRTdGF0ZSh2aWV3LnN0YXRlKVxuICAgICAgICAvLyBAbm90ZSBXZSBtYWtlIGltcGxpY2l0IGNoZWNrcyB3aGVuIGNoZWNraW5nIGZvciB0aGUgY3Vyc29yIHByb3BlcnR5XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSBhd2FyZW5lc3MuZ2V0TG9jYWxTdGF0ZSgpIHx8IHt9XG4gICAgICAgIGlmICh2aWV3Lmhhc0ZvY3VzKCkpIHtcbiAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBnZXRTZWxlY3Rpb24odmlldy5zdGF0ZSlcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBAdHlwZSB7WS5SZWxhdGl2ZVBvc2l0aW9ufVxuICAgICAgICAgICAqL1xuICAgICAgICAgIGNvbnN0IGFuY2hvciA9IGFic29sdXRlUG9zaXRpb25Ub1JlbGF0aXZlUG9zaXRpb24oXG4gICAgICAgICAgICBzZWxlY3Rpb24uYW5jaG9yLFxuICAgICAgICAgICAgeXN0YXRlLnR5cGUsXG4gICAgICAgICAgICB5c3RhdGUuYmluZGluZy5tYXBwaW5nXG4gICAgICAgICAgKVxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEB0eXBlIHtZLlJlbGF0aXZlUG9zaXRpb259XG4gICAgICAgICAgICovXG4gICAgICAgICAgY29uc3QgaGVhZCA9IGFic29sdXRlUG9zaXRpb25Ub1JlbGF0aXZlUG9zaXRpb24oXG4gICAgICAgICAgICBzZWxlY3Rpb24uaGVhZCxcbiAgICAgICAgICAgIHlzdGF0ZS50eXBlLFxuICAgICAgICAgICAgeXN0YXRlLmJpbmRpbmcubWFwcGluZ1xuICAgICAgICAgIClcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBjdXJyZW50LmN1cnNvciA9PSBudWxsIHx8XG4gICAgICAgICAgICAhWS5jb21wYXJlUmVsYXRpdmVQb3NpdGlvbnMoXG4gICAgICAgICAgICAgIFkuY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21KU09OKGN1cnJlbnQuY3Vyc29yLmFuY2hvciksXG4gICAgICAgICAgICAgIGFuY2hvclxuICAgICAgICAgICAgKSB8fFxuICAgICAgICAgICAgIVkuY29tcGFyZVJlbGF0aXZlUG9zaXRpb25zKFxuICAgICAgICAgICAgICBZLmNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tSlNPTihjdXJyZW50LmN1cnNvci5oZWFkKSxcbiAgICAgICAgICAgICAgaGVhZFxuICAgICAgICAgICAgKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgYXdhcmVuZXNzLnNldExvY2FsU3RhdGVGaWVsZChjdXJzb3JTdGF0ZUZpZWxkLCB7XG4gICAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgICAgaGVhZFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgY3VycmVudC5jdXJzb3IgIT0gbnVsbCAmJlxuICAgICAgICAgIHJlbGF0aXZlUG9zaXRpb25Ub0Fic29sdXRlUG9zaXRpb24oXG4gICAgICAgICAgICB5c3RhdGUuZG9jLFxuICAgICAgICAgICAgeXN0YXRlLnR5cGUsXG4gICAgICAgICAgICBZLmNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tSlNPTihjdXJyZW50LmN1cnNvci5hbmNob3IpLFxuICAgICAgICAgICAgeXN0YXRlLmJpbmRpbmcubWFwcGluZ1xuICAgICAgICAgICkgIT09IG51bGxcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gZGVsZXRlIGN1cnNvciBpbmZvcm1hdGlvbiBpZiBjdXJyZW50IGN1cnNvciBpbmZvcm1hdGlvbiBpcyBvd25lZCBieSB0aGlzIGVkaXRvciBiaW5kaW5nXG4gICAgICAgICAgYXdhcmVuZXNzLnNldExvY2FsU3RhdGVGaWVsZChjdXJzb3JTdGF0ZUZpZWxkLCBudWxsKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhd2FyZW5lc3Mub24oJ2NoYW5nZScsIGF3YXJlbmVzc0xpc3RlbmVyKVxuICAgICAgdmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIHVwZGF0ZUN1cnNvckluZm8pXG4gICAgICB2aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIHVwZGF0ZUN1cnNvckluZm8pXG4gICAgICByZXR1cm4ge1xuICAgICAgICB1cGRhdGU6IHVwZGF0ZUN1cnNvckluZm8sXG4gICAgICAgIGRlc3Ryb3k6ICgpID0+IHtcbiAgICAgICAgICB2aWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c2luJywgdXBkYXRlQ3Vyc29ySW5mbylcbiAgICAgICAgICB2aWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIHVwZGF0ZUN1cnNvckluZm8pXG4gICAgICAgICAgYXdhcmVuZXNzLm9mZignY2hhbmdlJywgYXdhcmVuZXNzTGlzdGVuZXIpXG4gICAgICAgICAgYXdhcmVuZXNzLnNldExvY2FsU3RhdGVGaWVsZChjdXJzb3JTdGF0ZUZpZWxkLCBudWxsKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/y-prosemirror/src/plugins/cursor-plugin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/y-prosemirror/src/plugins/keys.js":
/*!********************************************************!*\
  !*** ./node_modules/y-prosemirror/src/plugins/keys.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   yCursorPluginKey: () => (/* binding */ yCursorPluginKey),\n/* harmony export */   ySyncPluginKey: () => (/* binding */ ySyncPluginKey),\n/* harmony export */   yUndoPluginKey: () => (/* binding */ yUndoPluginKey)\n/* harmony export */ });\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n // eslint-disable-line\n\n/**\n * The unique prosemirror plugin key for syncPlugin\n *\n * @public\n */\nconst ySyncPluginKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('y-sync')\n\n/**\n * The unique prosemirror plugin key for undoPlugin\n *\n * @public\n */\nconst yUndoPluginKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('y-undo')\n\n/**\n * The unique prosemirror plugin key for cursorPlugin\n *\n * @public\n */\nconst yCursorPluginKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('yjs-cursor')\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveS1wcm9zZW1pcnJvci9zcmMvcGx1Z2lucy9rZXlzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBNkM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywyQkFBMkIsd0RBQVM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywyQkFBMkIsd0RBQVM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyw2QkFBNkIsd0RBQVMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8yOF9ub3Rpb24tY2xvbmUvLi9ub2RlX21vZHVsZXMveS1wcm9zZW1pcnJvci9zcmMvcGx1Z2lucy9rZXlzLmpzPzZhNGIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGx1Z2luS2V5IH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuLyoqXG4gKiBUaGUgdW5pcXVlIHByb3NlbWlycm9yIHBsdWdpbiBrZXkgZm9yIHN5bmNQbHVnaW5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCB5U3luY1BsdWdpbktleSA9IG5ldyBQbHVnaW5LZXkoJ3ktc3luYycpXG5cbi8qKlxuICogVGhlIHVuaXF1ZSBwcm9zZW1pcnJvciBwbHVnaW4ga2V5IGZvciB1bmRvUGx1Z2luXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgeVVuZG9QbHVnaW5LZXkgPSBuZXcgUGx1Z2luS2V5KCd5LXVuZG8nKVxuXG4vKipcbiAqIFRoZSB1bmlxdWUgcHJvc2VtaXJyb3IgcGx1Z2luIGtleSBmb3IgY3Vyc29yUGx1Z2luXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgeUN1cnNvclBsdWdpbktleSA9IG5ldyBQbHVnaW5LZXkoJ3lqcy1jdXJzb3InKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/y-prosemirror/src/plugins/keys.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/y-prosemirror/src/plugins/sync-plugin.js":
/*!***************************************************************!*\
  !*** ./node_modules/y-prosemirror/src/plugins/sync-plugin.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ProsemirrorBinding: () => (/* binding */ ProsemirrorBinding),\n/* harmony export */   createNodeFromYElement: () => (/* binding */ createNodeFromYElement),\n/* harmony export */   getRelativeSelection: () => (/* binding */ getRelativeSelection),\n/* harmony export */   isVisible: () => (/* binding */ isVisible),\n/* harmony export */   updateYFragment: () => (/* binding */ updateYFragment),\n/* harmony export */   ySyncPlugin: () => (/* binding */ ySyncPlugin)\n/* harmony export */ });\n/* harmony import */ var lib0_mutex__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lib0/mutex */ \"(ssr)/./node_modules/lib0/mutex.js\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var lib0_math__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! lib0/math */ \"(ssr)/./node_modules/lib0/math.js\");\n/* harmony import */ var lib0_object__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! lib0/object */ \"(ssr)/./node_modules/lib0/object.js\");\n/* harmony import */ var lib0_set__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lib0/set */ \"(ssr)/./node_modules/lib0/set.js\");\n/* harmony import */ var lib0_diff__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! lib0/diff */ \"(ssr)/./node_modules/lib0/diff.js\");\n/* harmony import */ var lib0_error__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! lib0/error */ \"(ssr)/./node_modules/lib0/error.js\");\n/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./keys.js */ \"(ssr)/./node_modules/y-prosemirror/src/plugins/keys.js\");\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! yjs */ \"(ssr)/./node_modules/yjs/dist/yjs.mjs\");\n/* harmony import */ var _lib_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../lib.js */ \"(ssr)/./node_modules/y-prosemirror/src/lib.js\");\n/* harmony import */ var lib0_random__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lib0/random */ \"(ssr)/./node_modules/lib0/random.js\");\n/* harmony import */ var lib0_environment__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lib0/environment */ \"(ssr)/./node_modules/lib0/environment.js\");\n/* harmony import */ var lib0_dom__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lib0/dom */ \"(ssr)/./node_modules/lib0/dom.js\");\n/* harmony import */ var lib0_eventloop__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lib0/eventloop */ \"(ssr)/./node_modules/lib0/eventloop.js\");\n/**\n * @module bindings/prosemirror\n */\n\n\n\n // eslint-disable-line\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @param {Y.Item} item\n * @param {Y.Snapshot} [snapshot]\n */\nconst isVisible = (item, snapshot) =>\n  snapshot === undefined\n    ? !item.deleted\n    : (snapshot.sv.has(item.id.client) && /** @type {number} */\n      (snapshot.sv.get(item.id.client)) > item.id.clock &&\n      !yjs__WEBPACK_IMPORTED_MODULE_0__.isDeleted(snapshot.ds, item.id))\n\n/**\n * Either a node if type is YXmlElement or an Array of text nodes if YXmlText\n * @typedef {Map<Y.AbstractType<any>, PModel.Node | Array<PModel.Node>>} ProsemirrorMapping\n */\n\n/**\n * @typedef {Object} ColorDef\n * @property {string} ColorDef.light\n * @property {string} ColorDef.dark\n */\n\n/**\n * @typedef {Object} YSyncOpts\n * @property {Array<ColorDef>} [YSyncOpts.colors]\n * @property {Map<string,ColorDef>} [YSyncOpts.colorMapping]\n * @property {Y.PermanentUserData|null} [YSyncOpts.permanentUserData]\n * @property {ProsemirrorMapping} [YSyncOpts.mapping]\n * @property {function} [YSyncOpts.onFirstRender] Fired when the content from Yjs is initially rendered to ProseMirror\n */\n\n/**\n * @type {Array<ColorDef>}\n */\nconst defaultColors = [{ light: '#ecd44433', dark: '#ecd444' }]\n\n/**\n * @param {Map<string,ColorDef>} colorMapping\n * @param {Array<ColorDef>} colors\n * @param {string} user\n * @return {ColorDef}\n */\nconst getUserColor = (colorMapping, colors, user) => {\n  // @todo do not hit the same color twice if possible\n  if (!colorMapping.has(user)) {\n    if (colorMapping.size < colors.length) {\n      const usedColors = lib0_set__WEBPACK_IMPORTED_MODULE_1__.create()\n      colorMapping.forEach((color) => usedColors.add(color))\n      colors = colors.filter((color) => !usedColors.has(color))\n    }\n    colorMapping.set(user, lib0_random__WEBPACK_IMPORTED_MODULE_2__.oneOf(colors))\n  }\n  return /** @type {ColorDef} */ (colorMapping.get(user))\n}\n\n/**\n * This plugin listens to changes in prosemirror view and keeps yXmlState and view in sync.\n *\n * This plugin also keeps references to the type and the shared document so other plugins can access it.\n * @param {Y.XmlFragment} yXmlFragment\n * @param {YSyncOpts} opts\n * @return {any} Returns a prosemirror plugin that binds to this type\n */\nconst ySyncPlugin = (yXmlFragment, {\n  colors = defaultColors,\n  colorMapping = new Map(),\n  permanentUserData = null,\n  onFirstRender = () => {},\n  mapping\n} = {}) => {\n  let initialContentChanged = false\n  const binding = new ProsemirrorBinding(yXmlFragment, mapping)\n  const plugin = new prosemirror_state__WEBPACK_IMPORTED_MODULE_3__.Plugin({\n    props: {\n      editable: (state) => {\n        const syncState = _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey.getState(state)\n        return syncState.snapshot == null && syncState.prevSnapshot == null\n      }\n    },\n    key: _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey,\n    state: {\n      /**\n       * @returns {any}\n       */\n      init: (_initargs, _state) => {\n        return {\n          type: yXmlFragment,\n          doc: yXmlFragment.doc,\n          binding,\n          snapshot: null,\n          prevSnapshot: null,\n          isChangeOrigin: false,\n          isUndoRedoOperation: false,\n          addToHistory: true,\n          colors,\n          colorMapping,\n          permanentUserData\n        }\n      },\n      apply: (tr, pluginState) => {\n        const change = tr.getMeta(_keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey)\n        if (change !== undefined) {\n          pluginState = Object.assign({}, pluginState)\n          for (const key in change) {\n            pluginState[key] = change[key]\n          }\n        }\n        pluginState.addToHistory = tr.getMeta('addToHistory') !== false\n        // always set isChangeOrigin. If undefined, this is not change origin.\n        pluginState.isChangeOrigin = change !== undefined &&\n          !!change.isChangeOrigin\n        pluginState.isUndoRedoOperation = change !== undefined && !!change.isChangeOrigin && !!change.isUndoRedoOperation\n        if (binding.prosemirrorView !== null) {\n          if (\n            change !== undefined &&\n            (change.snapshot != null || change.prevSnapshot != null)\n          ) {\n            // snapshot changed, rerender next\n            lib0_eventloop__WEBPACK_IMPORTED_MODULE_5__.timeout(0, () => {\n              if (binding.prosemirrorView == null) {\n                return\n              }\n              if (change.restore == null) {\n                binding._renderSnapshot(\n                  change.snapshot,\n                  change.prevSnapshot,\n                  pluginState\n                )\n              } else {\n                binding._renderSnapshot(\n                  change.snapshot,\n                  change.snapshot,\n                  pluginState\n                )\n                // reset to current prosemirror state\n                delete pluginState.restore\n                delete pluginState.snapshot\n                delete pluginState.prevSnapshot\n                binding.mux(() => {\n                  binding._prosemirrorChanged(\n                    binding.prosemirrorView.state.doc\n                  )\n                })\n              }\n            })\n          }\n        }\n        return pluginState\n      }\n    },\n    view: (view) => {\n      binding.initView(view)\n      if (mapping == null) {\n        // force rerender to update the bindings mapping\n        binding._forceRerender()\n      }\n      onFirstRender()\n      return {\n        update: () => {\n          const pluginState = plugin.getState(view.state)\n          if (\n            pluginState.snapshot == null && pluginState.prevSnapshot == null\n          ) {\n            if (\n              // If the content doesn't change initially, we don't render anything to Yjs\n              // If the content was cleared by a user action, we want to catch the change and\n              // represent it in Yjs\n              initialContentChanged ||\n              view.state.doc.content.findDiffStart(\n                view.state.doc.type.createAndFill().content\n              ) !== null\n            ) {\n              initialContentChanged = true\n              if (\n                pluginState.addToHistory === false &&\n                !pluginState.isChangeOrigin\n              ) {\n                const yUndoPluginState = _keys_js__WEBPACK_IMPORTED_MODULE_4__.yUndoPluginKey.getState(view.state)\n                /**\n                 * @type {Y.UndoManager}\n                 */\n                const um = yUndoPluginState && yUndoPluginState.undoManager\n                if (um) {\n                  um.stopCapturing()\n                }\n              }\n              binding.mux(() => {\n                /** @type {Y.Doc} */ (pluginState.doc).transact((tr) => {\n                  tr.meta.set('addToHistory', pluginState.addToHistory)\n                  binding._prosemirrorChanged(view.state.doc)\n                }, _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey)\n              })\n            }\n          }\n        },\n        destroy: () => {\n          binding.destroy()\n        }\n      }\n    }\n  })\n  return plugin\n}\n\n/**\n * @param {any} tr\n * @param {any} relSel\n * @param {ProsemirrorBinding} binding\n */\nconst restoreRelativeSelection = (tr, relSel, binding) => {\n  if (relSel !== null && relSel.anchor !== null && relSel.head !== null) {\n    const anchor = (0,_lib_js__WEBPACK_IMPORTED_MODULE_6__.relativePositionToAbsolutePosition)(\n      binding.doc,\n      binding.type,\n      relSel.anchor,\n      binding.mapping\n    )\n    const head = (0,_lib_js__WEBPACK_IMPORTED_MODULE_6__.relativePositionToAbsolutePosition)(\n      binding.doc,\n      binding.type,\n      relSel.head,\n      binding.mapping\n    )\n    if (anchor !== null && head !== null) {\n      tr = tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_3__.TextSelection.create(tr.doc, anchor, head))\n    }\n  }\n}\n\nconst getRelativeSelection = (pmbinding, state) => ({\n  anchor: (0,_lib_js__WEBPACK_IMPORTED_MODULE_6__.absolutePositionToRelativePosition)(\n    state.selection.anchor,\n    pmbinding.type,\n    pmbinding.mapping\n  ),\n  head: (0,_lib_js__WEBPACK_IMPORTED_MODULE_6__.absolutePositionToRelativePosition)(\n    state.selection.head,\n    pmbinding.type,\n    pmbinding.mapping\n  )\n})\n\n/**\n * Binding for prosemirror.\n *\n * @protected\n */\nclass ProsemirrorBinding {\n  /**\n   * @param {Y.XmlFragment} yXmlFragment The bind source\n   * @param {ProsemirrorMapping} mapping\n   */\n  constructor (yXmlFragment, mapping = new Map()) {\n    this.type = yXmlFragment\n    /**\n     * this will be set once the view is created\n     * @type {any}\n     */\n    this.prosemirrorView = null\n    this.mux = (0,lib0_mutex__WEBPACK_IMPORTED_MODULE_7__.createMutex)()\n    this.mapping = mapping\n    this._observeFunction = this._typeChanged.bind(this)\n    /**\n     * @type {Y.Doc}\n     */\n    // @ts-ignore\n    this.doc = yXmlFragment.doc\n    /**\n     * current selection as relative positions in the Yjs model\n     */\n    this.beforeTransactionSelection = null\n    this.beforeAllTransactions = () => {\n      if (this.beforeTransactionSelection === null && this.prosemirrorView != null) {\n        this.beforeTransactionSelection = getRelativeSelection(\n          this,\n          this.prosemirrorView.state\n        )\n      }\n    }\n    this.afterAllTransactions = () => {\n      this.beforeTransactionSelection = null\n    }\n    this._domSelectionInView = null\n  }\n\n  /**\n   * Create a transaction for changing the prosemirror state.\n   *\n   * @returns\n   */\n  get _tr () {\n    return this.prosemirrorView.state.tr.setMeta('addToHistory', false)\n  }\n\n  _isLocalCursorInView () {\n    if (!this.prosemirrorView.hasFocus()) return false\n    if (lib0_environment__WEBPACK_IMPORTED_MODULE_8__.isBrowser && this._domSelectionInView === null) {\n      // Calculate the domSelectionInView and clear by next tick after all events are finished\n      lib0_eventloop__WEBPACK_IMPORTED_MODULE_5__.timeout(0, () => {\n        this._domSelectionInView = null\n      })\n      this._domSelectionInView = this._isDomSelectionInView()\n    }\n    return this._domSelectionInView\n  }\n\n  _isDomSelectionInView () {\n    const selection = this.prosemirrorView._root.getSelection()\n\n    const range = this.prosemirrorView._root.createRange()\n    range.setStart(selection.anchorNode, selection.anchorOffset)\n    range.setEnd(selection.focusNode, selection.focusOffset)\n\n    // This is a workaround for an edgecase where getBoundingClientRect will\n    // return zero values if the selection is collapsed at the start of a newline\n    // see reference here: https://stackoverflow.com/a/59780954\n    const rects = range.getClientRects()\n    if (rects.length === 0) {\n      // probably buggy newline behavior, explicitly select the node contents\n      if (range.startContainer && range.collapsed) {\n        range.selectNodeContents(range.startContainer)\n      }\n    }\n\n    const bounding = range.getBoundingClientRect()\n    const documentElement = lib0_dom__WEBPACK_IMPORTED_MODULE_9__.doc.documentElement\n\n    return bounding.bottom >= 0 && bounding.right >= 0 &&\n      bounding.left <=\n        (window.innerWidth || documentElement.clientWidth || 0) &&\n      bounding.top <= (window.innerHeight || documentElement.clientHeight || 0)\n  }\n\n  /**\n   * @param {Y.Snapshot} snapshot\n   * @param {Y.Snapshot} prevSnapshot\n   */\n  renderSnapshot (snapshot, prevSnapshot) {\n    if (!prevSnapshot) {\n      prevSnapshot = yjs__WEBPACK_IMPORTED_MODULE_0__.createSnapshot(yjs__WEBPACK_IMPORTED_MODULE_0__.createDeleteSet(), new Map())\n    }\n    this.prosemirrorView.dispatch(\n      this._tr.setMeta(_keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey, { snapshot, prevSnapshot })\n    )\n  }\n\n  unrenderSnapshot () {\n    this.mapping.clear()\n    this.mux(() => {\n      const fragmentContent = this.type.toArray().map((t) =>\n        createNodeFromYElement(\n          /** @type {Y.XmlElement} */ (t),\n          this.prosemirrorView.state.schema,\n          this.mapping\n        )\n      ).filter((n) => n !== null)\n      // @ts-ignore\n      const tr = this._tr.replace(\n        0,\n        this.prosemirrorView.state.doc.content.size,\n        new prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Fragment.from(fragmentContent), 0, 0)\n      )\n      tr.setMeta(_keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey, { snapshot: null, prevSnapshot: null })\n      this.prosemirrorView.dispatch(tr)\n    })\n  }\n\n  _forceRerender () {\n    this.mapping.clear()\n    this.mux(() => {\n      // If this is a forced rerender, this might neither happen as a pm change nor within a Yjs\n      // transaction. Then the \"before selection\" doesn't exist. In this case, we need to create a\n      // relative position before replacing content. Fixes #126\n      const sel = this.beforeTransactionSelection !== null ? null : this.prosemirrorView.state.selection\n      const fragmentContent = this.type.toArray().map((t) =>\n        createNodeFromYElement(\n          /** @type {Y.XmlElement} */ (t),\n          this.prosemirrorView.state.schema,\n          this.mapping\n        )\n      ).filter((n) => n !== null)\n      // @ts-ignore\n      const tr = this._tr.replace(\n        0,\n        this.prosemirrorView.state.doc.content.size,\n        new prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Fragment.from(fragmentContent), 0, 0)\n      )\n      if (sel) {\n        tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_3__.TextSelection.create(tr.doc, sel.anchor, sel.head))\n      }\n      this.prosemirrorView.dispatch(\n        tr.setMeta(_keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey, { isChangeOrigin: true, binding: this })\n      )\n    })\n  }\n\n  /**\n   * @param {Y.Snapshot|Uint8Array} snapshot\n   * @param {Y.Snapshot|Uint8Array} prevSnapshot\n   * @param {Object} pluginState\n   */\n  _renderSnapshot (snapshot, prevSnapshot, pluginState) {\n    /**\n     * The document that contains the full history of this document.\n     * @type {Y.Doc}\n     */\n    let historyDoc = this.doc\n    if (!snapshot) {\n      snapshot = yjs__WEBPACK_IMPORTED_MODULE_0__.snapshot(this.doc)\n    }\n    if (snapshot instanceof Uint8Array || prevSnapshot instanceof Uint8Array) {\n      if (!(snapshot instanceof Uint8Array) || !(prevSnapshot instanceof Uint8Array)) {\n        // expected both snapshots to be v2 updates\n        lib0_error__WEBPACK_IMPORTED_MODULE_11__.unexpectedCase()\n      }\n      historyDoc = new yjs__WEBPACK_IMPORTED_MODULE_0__.Doc({ gc: false })\n      yjs__WEBPACK_IMPORTED_MODULE_0__.applyUpdateV2(historyDoc, prevSnapshot)\n      prevSnapshot = yjs__WEBPACK_IMPORTED_MODULE_0__.snapshot(historyDoc)\n      yjs__WEBPACK_IMPORTED_MODULE_0__.applyUpdateV2(historyDoc, snapshot)\n      snapshot = yjs__WEBPACK_IMPORTED_MODULE_0__.snapshot(historyDoc)\n    }\n    // clear mapping because we are going to rerender\n    this.mapping.clear()\n    this.mux(() => {\n      historyDoc.transact((transaction) => {\n        // before rendering, we are going to sanitize ops and split deleted ops\n        // if they were deleted by seperate users.\n        const pud = pluginState.permanentUserData\n        if (pud) {\n          pud.dss.forEach((ds) => {\n            yjs__WEBPACK_IMPORTED_MODULE_0__.iterateDeletedStructs(transaction, ds, (_item) => {})\n          })\n        }\n        /**\n         * @param {'removed'|'added'} type\n         * @param {Y.ID} id\n         */\n        const computeYChange = (type, id) => {\n          const user = type === 'added'\n            ? pud.getUserByClientId(id.client)\n            : pud.getUserByDeletedId(id)\n          return {\n            user,\n            type,\n            color: getUserColor(\n              pluginState.colorMapping,\n              pluginState.colors,\n              user\n            )\n          }\n        }\n        // Create document fragment and render\n        const fragmentContent = yjs__WEBPACK_IMPORTED_MODULE_0__.typeListToArraySnapshot(\n          this.type,\n          new yjs__WEBPACK_IMPORTED_MODULE_0__.Snapshot(prevSnapshot.ds, snapshot.sv)\n        ).map((t) => {\n          if (\n            !t._item.deleted || isVisible(t._item, snapshot) ||\n            isVisible(t._item, prevSnapshot)\n          ) {\n            return createNodeFromYElement(\n              t,\n              this.prosemirrorView.state.schema,\n              new Map(),\n              snapshot,\n              prevSnapshot,\n              computeYChange\n            )\n          } else {\n            // No need to render elements that are not visible by either snapshot.\n            // If a client adds and deletes content in the same snapshot the element is not visible by either snapshot.\n            return null\n          }\n        }).filter((n) => n !== null)\n        // @ts-ignore\n        const tr = this._tr.replace(\n          0,\n          this.prosemirrorView.state.doc.content.size,\n          new prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Fragment.from(fragmentContent), 0, 0)\n        )\n        this.prosemirrorView.dispatch(\n          tr.setMeta(_keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey, { isChangeOrigin: true })\n        )\n      }, _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey)\n    })\n  }\n\n  /**\n   * @param {Array<Y.YEvent<any>>} events\n   * @param {Y.Transaction} transaction\n   */\n  _typeChanged (events, transaction) {\n    if (this.prosemirrorView == null) return\n    const syncState = _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey.getState(this.prosemirrorView.state)\n    if (\n      events.length === 0 || syncState.snapshot != null ||\n      syncState.prevSnapshot != null\n    ) {\n      // drop out if snapshot is active\n      this.renderSnapshot(syncState.snapshot, syncState.prevSnapshot)\n      return\n    }\n    this.mux(() => {\n      /**\n       * @param {any} _\n       * @param {Y.AbstractType<any>} type\n       */\n      const delType = (_, type) => this.mapping.delete(type)\n      yjs__WEBPACK_IMPORTED_MODULE_0__.iterateDeletedStructs(\n        transaction,\n        transaction.deleteSet,\n        (struct) => {\n          if (struct.constructor === yjs__WEBPACK_IMPORTED_MODULE_0__.Item) {\n            const type = /** @type {Y.ContentType} */ (/** @type {Y.Item} */ (struct).content).type\n            type && this.mapping.delete(type)\n          }\n        }\n      )\n      transaction.changed.forEach(delType)\n      transaction.changedParentTypes.forEach(delType)\n      const fragmentContent = this.type.toArray().map((t) =>\n        createNodeIfNotExists(\n          /** @type {Y.XmlElement | Y.XmlHook} */ (t),\n          this.prosemirrorView.state.schema,\n          this.mapping\n        )\n      ).filter((n) => n !== null)\n      // @ts-ignore\n      let tr = this._tr.replace(\n        0,\n        this.prosemirrorView.state.doc.content.size,\n        new prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Fragment.from(fragmentContent), 0, 0)\n      )\n      restoreRelativeSelection(tr, this.beforeTransactionSelection, this)\n      tr = tr.setMeta(_keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey, { isChangeOrigin: true, isUndoRedoOperation: transaction.origin instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.UndoManager })\n      if (\n        this.beforeTransactionSelection !== null && this._isLocalCursorInView()\n      ) {\n        tr.scrollIntoView()\n      }\n      this.prosemirrorView.dispatch(tr)\n    })\n  }\n\n  _prosemirrorChanged (doc) {\n    this.doc.transact(() => {\n      updateYFragment(this.doc, this.type, doc, this.mapping)\n      this.beforeTransactionSelection = getRelativeSelection(\n        this,\n        this.prosemirrorView.state\n      )\n    }, _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey)\n  }\n\n  /**\n   * View is ready to listen to changes. Register observers.\n   * @param {any} prosemirrorView\n   */\n  initView (prosemirrorView) {\n    if (this.prosemirrorView != null) this.destroy()\n    this.prosemirrorView = prosemirrorView\n    this.doc.on('beforeAllTransactions', this.beforeAllTransactions)\n    this.doc.on('afterAllTransactions', this.afterAllTransactions)\n    this.type.observeDeep(this._observeFunction)\n  }\n\n  destroy () {\n    if (this.prosemirrorView == null) return\n    this.prosemirrorView = null\n    this.type.unobserveDeep(this._observeFunction)\n    this.doc.off('beforeAllTransactions', this.beforeAllTransactions)\n    this.doc.off('afterAllTransactions', this.afterAllTransactions)\n  }\n}\n\n/**\n * @private\n * @param {Y.XmlElement | Y.XmlHook} el\n * @param {PModel.Schema} schema\n * @param {ProsemirrorMapping} mapping\n * @param {Y.Snapshot} [snapshot]\n * @param {Y.Snapshot} [prevSnapshot]\n * @param {function('removed' | 'added', Y.ID):any} [computeYChange]\n * @return {PModel.Node | null}\n */\nconst createNodeIfNotExists = (\n  el,\n  schema,\n  mapping,\n  snapshot,\n  prevSnapshot,\n  computeYChange\n) => {\n  const node = /** @type {PModel.Node} */ (mapping.get(el))\n  if (node === undefined) {\n    if (el instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement) {\n      return createNodeFromYElement(\n        el,\n        schema,\n        mapping,\n        snapshot,\n        prevSnapshot,\n        computeYChange\n      )\n    } else {\n      throw lib0_error__WEBPACK_IMPORTED_MODULE_11__.methodUnimplemented() // we are currently not handling hooks\n    }\n  }\n  return node\n}\n\n/**\n * @private\n * @param {Y.XmlElement} el\n * @param {any} schema\n * @param {ProsemirrorMapping} mapping\n * @param {Y.Snapshot} [snapshot]\n * @param {Y.Snapshot} [prevSnapshot]\n * @param {function('removed' | 'added', Y.ID):any} [computeYChange]\n * @return {PModel.Node | null} Returns node if node could be created. Otherwise it deletes the yjs type and returns null\n */\nconst createNodeFromYElement = (\n  el,\n  schema,\n  mapping,\n  snapshot,\n  prevSnapshot,\n  computeYChange\n) => {\n  const children = []\n  const createChildren = (type) => {\n    if (type.constructor === yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement) {\n      const n = createNodeIfNotExists(\n        type,\n        schema,\n        mapping,\n        snapshot,\n        prevSnapshot,\n        computeYChange\n      )\n      if (n !== null) {\n        children.push(n)\n      }\n    } else {\n      // If the next ytext exists and was created by us, move the content to the current ytext.\n      // This is a fix for #160 -- duplication of characters when two Y.Text exist next to each\n      // other.\n      const nextytext = type._item.right?.content.type\n      if (nextytext instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.Text && !nextytext._item.deleted && nextytext._item.id.client === nextytext.doc.clientID) {\n        type.applyDelta([\n          { retain: type.length },\n          ...nextytext.toDelta()\n        ])\n        nextytext.doc.transact(tr => {\n          nextytext._item.delete(tr)\n        })\n      }\n      // now create the prosemirror text nodes\n      const ns = createTextNodesFromYText(\n        type,\n        schema,\n        mapping,\n        snapshot,\n        prevSnapshot,\n        computeYChange\n      )\n      if (ns !== null) {\n        ns.forEach((textchild) => {\n          if (textchild !== null) {\n            children.push(textchild)\n          }\n        })\n      }\n    }\n  }\n  if (snapshot === undefined || prevSnapshot === undefined) {\n    el.toArray().forEach(createChildren)\n  } else {\n    yjs__WEBPACK_IMPORTED_MODULE_0__.typeListToArraySnapshot(el, new yjs__WEBPACK_IMPORTED_MODULE_0__.Snapshot(prevSnapshot.ds, snapshot.sv))\n      .forEach(createChildren)\n  }\n  try {\n    const attrs = el.getAttributes(snapshot)\n    if (snapshot !== undefined) {\n      if (!isVisible(/** @type {Y.Item} */ (el._item), snapshot)) {\n        attrs.ychange = computeYChange\n          ? computeYChange('removed', /** @type {Y.Item} */ (el._item).id)\n          : { type: 'removed' }\n      } else if (!isVisible(/** @type {Y.Item} */ (el._item), prevSnapshot)) {\n        attrs.ychange = computeYChange\n          ? computeYChange('added', /** @type {Y.Item} */ (el._item).id)\n          : { type: 'added' }\n      }\n    }\n    const node = schema.node(el.nodeName, attrs, children)\n    mapping.set(el, node)\n    return node\n  } catch (e) {\n    // an error occured while creating the node. This is probably a result of a concurrent action.\n    /** @type {Y.Doc} */ (el.doc).transact((transaction) => {\n      /** @type {Y.Item} */ (el._item).delete(transaction)\n    }, _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey)\n    mapping.delete(el)\n    return null\n  }\n}\n\n/**\n * @private\n * @param {Y.XmlText} text\n * @param {any} schema\n * @param {ProsemirrorMapping} _mapping\n * @param {Y.Snapshot} [snapshot]\n * @param {Y.Snapshot} [prevSnapshot]\n * @param {function('removed' | 'added', Y.ID):any} [computeYChange]\n * @return {Array<PModel.Node>|null}\n */\nconst createTextNodesFromYText = (\n  text,\n  schema,\n  _mapping,\n  snapshot,\n  prevSnapshot,\n  computeYChange\n) => {\n  const nodes = []\n  const deltas = text.toDelta(snapshot, prevSnapshot, computeYChange)\n  try {\n    for (let i = 0; i < deltas.length; i++) {\n      const delta = deltas[i]\n      const marks = []\n      for (const markName in delta.attributes) {\n        marks.push(schema.mark(markName, delta.attributes[markName]))\n      }\n      nodes.push(schema.text(delta.insert, marks))\n    }\n  } catch (e) {\n    // an error occured while creating the node. This is probably a result of a concurrent action.\n    /** @type {Y.Doc} */ (text.doc).transact((transaction) => {\n      /** @type {Y.Item} */ (text._item).delete(transaction)\n    }, _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey)\n    return null\n  }\n  // @ts-ignore\n  return nodes\n}\n\n/**\n * @private\n * @param {Array<any>} nodes prosemirror node\n * @param {ProsemirrorMapping} mapping\n * @return {Y.XmlText}\n */\nconst createTypeFromTextNodes = (nodes, mapping) => {\n  const type = new yjs__WEBPACK_IMPORTED_MODULE_0__.XmlText()\n  const delta = nodes.map((node) => ({\n    // @ts-ignore\n    insert: node.text,\n    attributes: marksToAttributes(node.marks)\n  }))\n  type.applyDelta(delta)\n  mapping.set(type, nodes)\n  return type\n}\n\n/**\n * @private\n * @param {any} node prosemirror node\n * @param {ProsemirrorMapping} mapping\n * @return {Y.XmlElement}\n */\nconst createTypeFromElementNode = (node, mapping) => {\n  const type = new yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement(node.type.name)\n  for (const key in node.attrs) {\n    const val = node.attrs[key]\n    if (val !== null && key !== 'ychange') {\n      type.setAttribute(key, val)\n    }\n  }\n  type.insert(\n    0,\n    normalizePNodeContent(node).map((n) =>\n      createTypeFromTextOrElementNode(n, mapping)\n    )\n  )\n  mapping.set(type, node)\n  return type\n}\n\n/**\n * @private\n * @param {PModel.Node|Array<PModel.Node>} node prosemirror text node\n * @param {ProsemirrorMapping} mapping\n * @return {Y.XmlElement|Y.XmlText}\n */\nconst createTypeFromTextOrElementNode = (node, mapping) =>\n  node instanceof Array\n    ? createTypeFromTextNodes(node, mapping)\n    : createTypeFromElementNode(node, mapping)\n\nconst isObject = (val) => typeof val === 'object' && val !== null\n\nconst equalAttrs = (pattrs, yattrs) => {\n  const keys = Object.keys(pattrs).filter((key) => pattrs[key] !== null)\n  let eq =\n    keys.length ===\n      Object.keys(yattrs).filter((key) => yattrs[key] !== null).length\n  for (let i = 0; i < keys.length && eq; i++) {\n    const key = keys[i]\n    const l = pattrs[key]\n    const r = yattrs[key]\n    eq = key === 'ychange' || l === r ||\n      (isObject(l) && isObject(r) && equalAttrs(l, r))\n  }\n  return eq\n}\n\n/**\n * @typedef {Array<Array<PModel.Node>|PModel.Node>} NormalizedPNodeContent\n */\n\n/**\n * @param {any} pnode\n * @return {NormalizedPNodeContent}\n */\nconst normalizePNodeContent = (pnode) => {\n  const c = pnode.content.content\n  const res = []\n  for (let i = 0; i < c.length; i++) {\n    const n = c[i]\n    if (n.isText) {\n      const textNodes = []\n      for (let tnode = c[i]; i < c.length && tnode.isText; tnode = c[++i]) {\n        textNodes.push(tnode)\n      }\n      i--\n      res.push(textNodes)\n    } else {\n      res.push(n)\n    }\n  }\n  return res\n}\n\n/**\n * @param {Y.XmlText} ytext\n * @param {Array<any>} ptexts\n */\nconst equalYTextPText = (ytext, ptexts) => {\n  const delta = ytext.toDelta()\n  return delta.length === ptexts.length &&\n    delta.every((d, i) =>\n      d.insert === /** @type {any} */ (ptexts[i]).text &&\n      lib0_object__WEBPACK_IMPORTED_MODULE_12__.keys(d.attributes || {}).length === ptexts[i].marks.length &&\n      ptexts[i].marks.every((mark) =>\n        equalAttrs(d.attributes[mark.type.name] || {}, mark.attrs)\n      )\n    )\n}\n\n/**\n * @param {Y.XmlElement|Y.XmlText|Y.XmlHook} ytype\n * @param {any|Array<any>} pnode\n */\nconst equalYTypePNode = (ytype, pnode) => {\n  if (\n    ytype instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement && !(pnode instanceof Array) &&\n    matchNodeName(ytype, pnode)\n  ) {\n    const normalizedContent = normalizePNodeContent(pnode)\n    return ytype._length === normalizedContent.length &&\n      equalAttrs(ytype.getAttributes(), pnode.attrs) &&\n      ytype.toArray().every((ychild, i) =>\n        equalYTypePNode(ychild, normalizedContent[i])\n      )\n  }\n  return ytype instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlText && pnode instanceof Array &&\n    equalYTextPText(ytype, pnode)\n}\n\n/**\n * @param {PModel.Node | Array<PModel.Node> | undefined} mapped\n * @param {PModel.Node | Array<PModel.Node>} pcontent\n */\nconst mappedIdentity = (mapped, pcontent) =>\n  mapped === pcontent ||\n  (mapped instanceof Array && pcontent instanceof Array &&\n    mapped.length === pcontent.length && mapped.every((a, i) =>\n    pcontent[i] === a\n  ))\n\n/**\n * @param {Y.XmlElement} ytype\n * @param {PModel.Node} pnode\n * @param {ProsemirrorMapping} mapping\n * @return {{ foundMappedChild: boolean, equalityFactor: number }}\n */\nconst computeChildEqualityFactor = (ytype, pnode, mapping) => {\n  const yChildren = ytype.toArray()\n  const pChildren = normalizePNodeContent(pnode)\n  const pChildCnt = pChildren.length\n  const yChildCnt = yChildren.length\n  const minCnt = lib0_math__WEBPACK_IMPORTED_MODULE_13__.min(yChildCnt, pChildCnt)\n  let left = 0\n  let right = 0\n  let foundMappedChild = false\n  for (; left < minCnt; left++) {\n    const leftY = yChildren[left]\n    const leftP = pChildren[left]\n    if (mappedIdentity(mapping.get(leftY), leftP)) {\n      foundMappedChild = true // definite (good) match!\n    } else if (!equalYTypePNode(leftY, leftP)) {\n      break\n    }\n  }\n  for (; left + right < minCnt; right++) {\n    const rightY = yChildren[yChildCnt - right - 1]\n    const rightP = pChildren[pChildCnt - right - 1]\n    if (mappedIdentity(mapping.get(rightY), rightP)) {\n      foundMappedChild = true\n    } else if (!equalYTypePNode(rightY, rightP)) {\n      break\n    }\n  }\n  return {\n    equalityFactor: left + right,\n    foundMappedChild\n  }\n}\n\nconst ytextTrans = (ytext) => {\n  let str = ''\n  /**\n   * @type {Y.Item|null}\n   */\n  let n = ytext._start\n  const nAttrs = {}\n  while (n !== null) {\n    if (!n.deleted) {\n      if (n.countable && n.content instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.ContentString) {\n        str += n.content.str\n      } else if (n.content instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.ContentFormat) {\n        nAttrs[n.content.key] = null\n      }\n    }\n    n = n.right\n  }\n  return {\n    str,\n    nAttrs\n  }\n}\n\n/**\n * @todo test this more\n *\n * @param {Y.Text} ytext\n * @param {Array<any>} ptexts\n * @param {ProsemirrorMapping} mapping\n */\nconst updateYText = (ytext, ptexts, mapping) => {\n  mapping.set(ytext, ptexts)\n  const { nAttrs, str } = ytextTrans(ytext)\n  const content = ptexts.map((p) => ({\n    insert: /** @type {any} */ (p).text,\n    attributes: Object.assign({}, nAttrs, marksToAttributes(p.marks))\n  }))\n  const { insert, remove, index } = (0,lib0_diff__WEBPACK_IMPORTED_MODULE_14__.simpleDiff)(\n    str,\n    content.map((c) => c.insert).join('')\n  )\n  ytext.delete(index, remove)\n  ytext.insert(index, insert)\n  ytext.applyDelta(\n    content.map((c) => ({ retain: c.insert.length, attributes: c.attributes }))\n  )\n}\n\nconst marksToAttributes = (marks) => {\n  const pattrs = {}\n  marks.forEach((mark) => {\n    if (mark.type.name !== 'ychange') {\n      pattrs[mark.type.name] = mark.attrs\n    }\n  })\n  return pattrs\n}\n\n/**\n * Update a yDom node by syncing the current content of the prosemirror node.\n *\n * This is a y-prosemirror internal feature that you can use at your own risk.\n *\n * @private\n * @unstable\n *\n * @param {{transact: Function}} y\n * @param {Y.XmlFragment} yDomFragment\n * @param {any} pNode\n * @param {ProsemirrorMapping} mapping\n */\nconst updateYFragment = (y, yDomFragment, pNode, mapping) => {\n  if (\n    yDomFragment instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement &&\n    yDomFragment.nodeName !== pNode.type.name\n  ) {\n    throw new Error('node name mismatch!')\n  }\n  mapping.set(yDomFragment, pNode)\n  // update attributes\n  if (yDomFragment instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement) {\n    const yDomAttrs = yDomFragment.getAttributes()\n    const pAttrs = pNode.attrs\n    for (const key in pAttrs) {\n      if (pAttrs[key] !== null) {\n        if (yDomAttrs[key] !== pAttrs[key] && key !== 'ychange') {\n          yDomFragment.setAttribute(key, pAttrs[key])\n        }\n      } else {\n        yDomFragment.removeAttribute(key)\n      }\n    }\n    // remove all keys that are no longer in pAttrs\n    for (const key in yDomAttrs) {\n      if (pAttrs[key] === undefined) {\n        yDomFragment.removeAttribute(key)\n      }\n    }\n  }\n  // update children\n  const pChildren = normalizePNodeContent(pNode)\n  const pChildCnt = pChildren.length\n  const yChildren = yDomFragment.toArray()\n  const yChildCnt = yChildren.length\n  const minCnt = lib0_math__WEBPACK_IMPORTED_MODULE_13__.min(pChildCnt, yChildCnt)\n  let left = 0\n  let right = 0\n  // find number of matching elements from left\n  for (; left < minCnt; left++) {\n    const leftY = yChildren[left]\n    const leftP = pChildren[left]\n    if (!mappedIdentity(mapping.get(leftY), leftP)) {\n      if (equalYTypePNode(leftY, leftP)) {\n        // update mapping\n        mapping.set(leftY, leftP)\n      } else {\n        break\n      }\n    }\n  }\n  // find number of matching elements from right\n  for (; right + left + 1 < minCnt; right++) {\n    const rightY = yChildren[yChildCnt - right - 1]\n    const rightP = pChildren[pChildCnt - right - 1]\n    if (!mappedIdentity(mapping.get(rightY), rightP)) {\n      if (equalYTypePNode(rightY, rightP)) {\n        // update mapping\n        mapping.set(rightY, rightP)\n      } else {\n        break\n      }\n    }\n  }\n  y.transact(() => {\n    // try to compare and update\n    while (yChildCnt - left - right > 0 && pChildCnt - left - right > 0) {\n      const leftY = yChildren[left]\n      const leftP = pChildren[left]\n      const rightY = yChildren[yChildCnt - right - 1]\n      const rightP = pChildren[pChildCnt - right - 1]\n      if (leftY instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlText && leftP instanceof Array) {\n        if (!equalYTextPText(leftY, leftP)) {\n          updateYText(leftY, leftP, mapping)\n        }\n        left += 1\n      } else {\n        let updateLeft = leftY instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement &&\n          matchNodeName(leftY, leftP)\n        let updateRight = rightY instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement &&\n          matchNodeName(rightY, rightP)\n        if (updateLeft && updateRight) {\n          // decide which which element to update\n          const equalityLeft = computeChildEqualityFactor(\n            /** @type {Y.XmlElement} */ (leftY),\n            /** @type {PModel.Node} */ (leftP),\n            mapping\n          )\n          const equalityRight = computeChildEqualityFactor(\n            /** @type {Y.XmlElement} */ (rightY),\n            /** @type {PModel.Node} */ (rightP),\n            mapping\n          )\n          if (\n            equalityLeft.foundMappedChild && !equalityRight.foundMappedChild\n          ) {\n            updateRight = false\n          } else if (\n            !equalityLeft.foundMappedChild && equalityRight.foundMappedChild\n          ) {\n            updateLeft = false\n          } else if (\n            equalityLeft.equalityFactor < equalityRight.equalityFactor\n          ) {\n            updateLeft = false\n          } else {\n            updateRight = false\n          }\n        }\n        if (updateLeft) {\n          updateYFragment(\n            y,\n            /** @type {Y.XmlFragment} */ (leftY),\n            /** @type {PModel.Node} */ (leftP),\n            mapping\n          )\n          left += 1\n        } else if (updateRight) {\n          updateYFragment(\n            y,\n            /** @type {Y.XmlFragment} */ (rightY),\n            /** @type {PModel.Node} */ (rightP),\n            mapping\n          )\n          right += 1\n        } else {\n          mapping.delete(yDomFragment.get(left))\n          yDomFragment.delete(left, 1)\n          yDomFragment.insert(left, [\n            createTypeFromTextOrElementNode(leftP, mapping)\n          ])\n          left += 1\n        }\n      }\n    }\n    const yDelLen = yChildCnt - left - right\n    if (\n      yChildCnt === 1 && pChildCnt === 0 && yChildren[0] instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlText\n    ) {\n      mapping.delete(yChildren[0])\n      // Edge case handling https://github.com/yjs/y-prosemirror/issues/108\n      // Only delete the content of the Y.Text to retain remote changes on the same Y.Text object\n      yChildren[0].delete(0, yChildren[0].length)\n    } else if (yDelLen > 0) {\n      yDomFragment.slice(left, left + yDelLen).forEach(type => mapping.delete(type))\n      yDomFragment.delete(left, yDelLen)\n    }\n    if (left + right < pChildCnt) {\n      const ins = []\n      for (let i = left; i < pChildCnt - right; i++) {\n        ins.push(createTypeFromTextOrElementNode(pChildren[i], mapping))\n      }\n      yDomFragment.insert(left, ins)\n    }\n  }, _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey)\n}\n\n/**\n * @function\n * @param {Y.XmlElement} yElement\n * @param {any} pNode Prosemirror Node\n */\nconst matchNodeName = (yElement, pNode) =>\n  !(pNode instanceof Array) && yElement.nodeName === pNode.type.name\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveS1wcm9zZW1pcnJvci9zcmMvcGx1Z2lucy9zeW5jLXBsdWdpbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7O0FBRXdDO0FBQ0c7QUFDZSxDQUFDO0FBQzFCO0FBQ0k7QUFDTjtBQUNPO0FBQ0g7QUFDdUI7QUFDbEM7QUFJTjtBQUNtQjtBQUNVO0FBQ2hCO0FBQ1k7O0FBRTNDO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsWUFBWTtBQUN2QjtBQUNPO0FBQ1A7QUFDQTtBQUNBLHFEQUFxRCxRQUFRO0FBQzdEO0FBQ0EsT0FBTywwQ0FBVzs7QUFFbEI7QUFDQTtBQUNBLGFBQWEsNERBQTREO0FBQ3pFOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxpQkFBaUI7QUFDL0IsY0FBYyxzQkFBc0I7QUFDcEMsY0FBYywwQkFBMEI7QUFDeEMsY0FBYyxvQkFBb0I7QUFDbEMsY0FBYyxVQUFVO0FBQ3hCOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EseUJBQXlCLHFDQUFxQzs7QUFFOUQ7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQyxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNENBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDhDQUFZO0FBQ3ZDO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxXQUFXO0FBQ3RCLFlBQVksS0FBSztBQUNqQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsRUFBRSxJQUFJO0FBQ047QUFDQTtBQUNBLHFCQUFxQixxREFBTTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix3Q0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiwwQ0FBMEMsMkNBQVk7QUFDdEQ7QUFDQSw0Q0FBNEMsMkNBQVk7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsY0FBYztBQUNyQyx1QkFBdUIsYUFBYTtBQUNwQztBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsY0FBYztBQUNyQyx1QkFBdUIsYUFBYTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZUFBZTtBQUN0Qyx1QkFBdUIsYUFBYTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLHVCQUF1QixlQUFlO0FBQ3RDLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLHdDQUFTO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEVBQUUsb0RBQWM7QUFDbkI7O0FBRUE7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLEtBQUs7QUFDaEI7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vMjhfbm90aW9uLWNsb25lLy4vbm9kZV9tb2R1bGVzL3ktcHJvc2VtaXJyb3Ivc3JjL3BsdWdpbnMvc3luYy1wbHVnaW4uanM/Y2JiNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgYmluZGluZ3MvcHJvc2VtaXJyb3JcbiAqL1xuXG5pbXBvcnQgeyBjcmVhdGVNdXRleCB9IGZyb20gJ2xpYjAvbXV0ZXgnXG5pbXBvcnQgKiBhcyBQTW9kZWwgZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnXG5pbXBvcnQgeyBQbHVnaW4sIFRleHRTZWxlY3Rpb24gfSBmcm9tIFwicHJvc2VtaXJyb3Itc3RhdGVcIjsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuaW1wb3J0ICogYXMgbWF0aCBmcm9tICdsaWIwL21hdGgnXG5pbXBvcnQgKiBhcyBvYmplY3QgZnJvbSAnbGliMC9vYmplY3QnXG5pbXBvcnQgKiBhcyBzZXQgZnJvbSAnbGliMC9zZXQnXG5pbXBvcnQgeyBzaW1wbGVEaWZmIH0gZnJvbSAnbGliMC9kaWZmJ1xuaW1wb3J0ICogYXMgZXJyb3IgZnJvbSAnbGliMC9lcnJvcidcbmltcG9ydCB7IHlTeW5jUGx1Z2luS2V5LCB5VW5kb1BsdWdpbktleSB9IGZyb20gJy4va2V5cy5qcydcbmltcG9ydCAqIGFzIFkgZnJvbSAneWpzJ1xuaW1wb3J0IHtcbiAgYWJzb2x1dGVQb3NpdGlvblRvUmVsYXRpdmVQb3NpdGlvbixcbiAgcmVsYXRpdmVQb3NpdGlvblRvQWJzb2x1dGVQb3NpdGlvblxufSBmcm9tICcuLi9saWIuanMnXG5pbXBvcnQgKiBhcyByYW5kb20gZnJvbSAnbGliMC9yYW5kb20nXG5pbXBvcnQgKiBhcyBlbnZpcm9ubWVudCBmcm9tICdsaWIwL2Vudmlyb25tZW50J1xuaW1wb3J0ICogYXMgZG9tIGZyb20gJ2xpYjAvZG9tJ1xuaW1wb3J0ICogYXMgZXZlbnRsb29wIGZyb20gJ2xpYjAvZXZlbnRsb29wJ1xuXG4vKipcbiAqIEBwYXJhbSB7WS5JdGVtfSBpdGVtXG4gKiBAcGFyYW0ge1kuU25hcHNob3R9IFtzbmFwc2hvdF1cbiAqL1xuZXhwb3J0IGNvbnN0IGlzVmlzaWJsZSA9IChpdGVtLCBzbmFwc2hvdCkgPT5cbiAgc25hcHNob3QgPT09IHVuZGVmaW5lZFxuICAgID8gIWl0ZW0uZGVsZXRlZFxuICAgIDogKHNuYXBzaG90LnN2LmhhcyhpdGVtLmlkLmNsaWVudCkgJiYgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAoc25hcHNob3Quc3YuZ2V0KGl0ZW0uaWQuY2xpZW50KSkgPiBpdGVtLmlkLmNsb2NrICYmXG4gICAgICAhWS5pc0RlbGV0ZWQoc25hcHNob3QuZHMsIGl0ZW0uaWQpKVxuXG4vKipcbiAqIEVpdGhlciBhIG5vZGUgaWYgdHlwZSBpcyBZWG1sRWxlbWVudCBvciBhbiBBcnJheSBvZiB0ZXh0IG5vZGVzIGlmIFlYbWxUZXh0XG4gKiBAdHlwZWRlZiB7TWFwPFkuQWJzdHJhY3RUeXBlPGFueT4sIFBNb2RlbC5Ob2RlIHwgQXJyYXk8UE1vZGVsLk5vZGU+Pn0gUHJvc2VtaXJyb3JNYXBwaW5nXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDb2xvckRlZlxuICogQHByb3BlcnR5IHtzdHJpbmd9IENvbG9yRGVmLmxpZ2h0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gQ29sb3JEZWYuZGFya1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gWVN5bmNPcHRzXG4gKiBAcHJvcGVydHkge0FycmF5PENvbG9yRGVmPn0gW1lTeW5jT3B0cy5jb2xvcnNdXG4gKiBAcHJvcGVydHkge01hcDxzdHJpbmcsQ29sb3JEZWY+fSBbWVN5bmNPcHRzLmNvbG9yTWFwcGluZ11cbiAqIEBwcm9wZXJ0eSB7WS5QZXJtYW5lbnRVc2VyRGF0YXxudWxsfSBbWVN5bmNPcHRzLnBlcm1hbmVudFVzZXJEYXRhXVxuICogQHByb3BlcnR5IHtQcm9zZW1pcnJvck1hcHBpbmd9IFtZU3luY09wdHMubWFwcGluZ11cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtZU3luY09wdHMub25GaXJzdFJlbmRlcl0gRmlyZWQgd2hlbiB0aGUgY29udGVudCBmcm9tIFlqcyBpcyBpbml0aWFsbHkgcmVuZGVyZWQgdG8gUHJvc2VNaXJyb3JcbiAqL1xuXG4vKipcbiAqIEB0eXBlIHtBcnJheTxDb2xvckRlZj59XG4gKi9cbmNvbnN0IGRlZmF1bHRDb2xvcnMgPSBbeyBsaWdodDogJyNlY2Q0NDQzMycsIGRhcms6ICcjZWNkNDQ0JyB9XVxuXG4vKipcbiAqIEBwYXJhbSB7TWFwPHN0cmluZyxDb2xvckRlZj59IGNvbG9yTWFwcGluZ1xuICogQHBhcmFtIHtBcnJheTxDb2xvckRlZj59IGNvbG9yc1xuICogQHBhcmFtIHtzdHJpbmd9IHVzZXJcbiAqIEByZXR1cm4ge0NvbG9yRGVmfVxuICovXG5jb25zdCBnZXRVc2VyQ29sb3IgPSAoY29sb3JNYXBwaW5nLCBjb2xvcnMsIHVzZXIpID0+IHtcbiAgLy8gQHRvZG8gZG8gbm90IGhpdCB0aGUgc2FtZSBjb2xvciB0d2ljZSBpZiBwb3NzaWJsZVxuICBpZiAoIWNvbG9yTWFwcGluZy5oYXModXNlcikpIHtcbiAgICBpZiAoY29sb3JNYXBwaW5nLnNpemUgPCBjb2xvcnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCB1c2VkQ29sb3JzID0gc2V0LmNyZWF0ZSgpXG4gICAgICBjb2xvck1hcHBpbmcuZm9yRWFjaCgoY29sb3IpID0+IHVzZWRDb2xvcnMuYWRkKGNvbG9yKSlcbiAgICAgIGNvbG9ycyA9IGNvbG9ycy5maWx0ZXIoKGNvbG9yKSA9PiAhdXNlZENvbG9ycy5oYXMoY29sb3IpKVxuICAgIH1cbiAgICBjb2xvck1hcHBpbmcuc2V0KHVzZXIsIHJhbmRvbS5vbmVPZihjb2xvcnMpKVxuICB9XG4gIHJldHVybiAvKiogQHR5cGUge0NvbG9yRGVmfSAqLyAoY29sb3JNYXBwaW5nLmdldCh1c2VyKSlcbn1cblxuLyoqXG4gKiBUaGlzIHBsdWdpbiBsaXN0ZW5zIHRvIGNoYW5nZXMgaW4gcHJvc2VtaXJyb3IgdmlldyBhbmQga2VlcHMgeVhtbFN0YXRlIGFuZCB2aWV3IGluIHN5bmMuXG4gKlxuICogVGhpcyBwbHVnaW4gYWxzbyBrZWVwcyByZWZlcmVuY2VzIHRvIHRoZSB0eXBlIGFuZCB0aGUgc2hhcmVkIGRvY3VtZW50IHNvIG90aGVyIHBsdWdpbnMgY2FuIGFjY2VzcyBpdC5cbiAqIEBwYXJhbSB7WS5YbWxGcmFnbWVudH0geVhtbEZyYWdtZW50XG4gKiBAcGFyYW0ge1lTeW5jT3B0c30gb3B0c1xuICogQHJldHVybiB7YW55fSBSZXR1cm5zIGEgcHJvc2VtaXJyb3IgcGx1Z2luIHRoYXQgYmluZHMgdG8gdGhpcyB0eXBlXG4gKi9cbmV4cG9ydCBjb25zdCB5U3luY1BsdWdpbiA9ICh5WG1sRnJhZ21lbnQsIHtcbiAgY29sb3JzID0gZGVmYXVsdENvbG9ycyxcbiAgY29sb3JNYXBwaW5nID0gbmV3IE1hcCgpLFxuICBwZXJtYW5lbnRVc2VyRGF0YSA9IG51bGwsXG4gIG9uRmlyc3RSZW5kZXIgPSAoKSA9PiB7fSxcbiAgbWFwcGluZ1xufSA9IHt9KSA9PiB7XG4gIGxldCBpbml0aWFsQ29udGVudENoYW5nZWQgPSBmYWxzZVxuICBjb25zdCBiaW5kaW5nID0gbmV3IFByb3NlbWlycm9yQmluZGluZyh5WG1sRnJhZ21lbnQsIG1hcHBpbmcpXG4gIGNvbnN0IHBsdWdpbiA9IG5ldyBQbHVnaW4oe1xuICAgIHByb3BzOiB7XG4gICAgICBlZGl0YWJsZTogKHN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IHN5bmNTdGF0ZSA9IHlTeW5jUGx1Z2luS2V5LmdldFN0YXRlKHN0YXRlKVxuICAgICAgICByZXR1cm4gc3luY1N0YXRlLnNuYXBzaG90ID09IG51bGwgJiYgc3luY1N0YXRlLnByZXZTbmFwc2hvdCA9PSBudWxsXG4gICAgICB9XG4gICAgfSxcbiAgICBrZXk6IHlTeW5jUGx1Z2luS2V5LFxuICAgIHN0YXRlOiB7XG4gICAgICAvKipcbiAgICAgICAqIEByZXR1cm5zIHthbnl9XG4gICAgICAgKi9cbiAgICAgIGluaXQ6IChfaW5pdGFyZ3MsIF9zdGF0ZSkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IHlYbWxGcmFnbWVudCxcbiAgICAgICAgICBkb2M6IHlYbWxGcmFnbWVudC5kb2MsXG4gICAgICAgICAgYmluZGluZyxcbiAgICAgICAgICBzbmFwc2hvdDogbnVsbCxcbiAgICAgICAgICBwcmV2U25hcHNob3Q6IG51bGwsXG4gICAgICAgICAgaXNDaGFuZ2VPcmlnaW46IGZhbHNlLFxuICAgICAgICAgIGlzVW5kb1JlZG9PcGVyYXRpb246IGZhbHNlLFxuICAgICAgICAgIGFkZFRvSGlzdG9yeTogdHJ1ZSxcbiAgICAgICAgICBjb2xvcnMsXG4gICAgICAgICAgY29sb3JNYXBwaW5nLFxuICAgICAgICAgIHBlcm1hbmVudFVzZXJEYXRhXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhcHBseTogKHRyLCBwbHVnaW5TdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCBjaGFuZ2UgPSB0ci5nZXRNZXRhKHlTeW5jUGx1Z2luS2V5KVxuICAgICAgICBpZiAoY2hhbmdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwbHVnaW5TdGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIHBsdWdpblN0YXRlKVxuICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGNoYW5nZSkge1xuICAgICAgICAgICAgcGx1Z2luU3RhdGVba2V5XSA9IGNoYW5nZVtrZXldXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBsdWdpblN0YXRlLmFkZFRvSGlzdG9yeSA9IHRyLmdldE1ldGEoJ2FkZFRvSGlzdG9yeScpICE9PSBmYWxzZVxuICAgICAgICAvLyBhbHdheXMgc2V0IGlzQ2hhbmdlT3JpZ2luLiBJZiB1bmRlZmluZWQsIHRoaXMgaXMgbm90IGNoYW5nZSBvcmlnaW4uXG4gICAgICAgIHBsdWdpblN0YXRlLmlzQ2hhbmdlT3JpZ2luID0gY2hhbmdlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAhIWNoYW5nZS5pc0NoYW5nZU9yaWdpblxuICAgICAgICBwbHVnaW5TdGF0ZS5pc1VuZG9SZWRvT3BlcmF0aW9uID0gY2hhbmdlICE9PSB1bmRlZmluZWQgJiYgISFjaGFuZ2UuaXNDaGFuZ2VPcmlnaW4gJiYgISFjaGFuZ2UuaXNVbmRvUmVkb09wZXJhdGlvblxuICAgICAgICBpZiAoYmluZGluZy5wcm9zZW1pcnJvclZpZXcgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBjaGFuZ2UgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKGNoYW5nZS5zbmFwc2hvdCAhPSBudWxsIHx8IGNoYW5nZS5wcmV2U25hcHNob3QgIT0gbnVsbClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIHNuYXBzaG90IGNoYW5nZWQsIHJlcmVuZGVyIG5leHRcbiAgICAgICAgICAgIGV2ZW50bG9vcC50aW1lb3V0KDAsICgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGJpbmRpbmcucHJvc2VtaXJyb3JWaWV3ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY2hhbmdlLnJlc3RvcmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGJpbmRpbmcuX3JlbmRlclNuYXBzaG90KFxuICAgICAgICAgICAgICAgICAgY2hhbmdlLnNuYXBzaG90LFxuICAgICAgICAgICAgICAgICAgY2hhbmdlLnByZXZTbmFwc2hvdCxcbiAgICAgICAgICAgICAgICAgIHBsdWdpblN0YXRlXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJpbmRpbmcuX3JlbmRlclNuYXBzaG90KFxuICAgICAgICAgICAgICAgICAgY2hhbmdlLnNuYXBzaG90LFxuICAgICAgICAgICAgICAgICAgY2hhbmdlLnNuYXBzaG90LFxuICAgICAgICAgICAgICAgICAgcGx1Z2luU3RhdGVcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgLy8gcmVzZXQgdG8gY3VycmVudCBwcm9zZW1pcnJvciBzdGF0ZVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBwbHVnaW5TdGF0ZS5yZXN0b3JlXG4gICAgICAgICAgICAgICAgZGVsZXRlIHBsdWdpblN0YXRlLnNuYXBzaG90XG4gICAgICAgICAgICAgICAgZGVsZXRlIHBsdWdpblN0YXRlLnByZXZTbmFwc2hvdFxuICAgICAgICAgICAgICAgIGJpbmRpbmcubXV4KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGJpbmRpbmcuX3Byb3NlbWlycm9yQ2hhbmdlZChcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZy5wcm9zZW1pcnJvclZpZXcuc3RhdGUuZG9jXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBsdWdpblN0YXRlXG4gICAgICB9XG4gICAgfSxcbiAgICB2aWV3OiAodmlldykgPT4ge1xuICAgICAgYmluZGluZy5pbml0Vmlldyh2aWV3KVxuICAgICAgaWYgKG1hcHBpbmcgPT0gbnVsbCkge1xuICAgICAgICAvLyBmb3JjZSByZXJlbmRlciB0byB1cGRhdGUgdGhlIGJpbmRpbmdzIG1hcHBpbmdcbiAgICAgICAgYmluZGluZy5fZm9yY2VSZXJlbmRlcigpXG4gICAgICB9XG4gICAgICBvbkZpcnN0UmVuZGVyKClcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVwZGF0ZTogKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHBsdWdpblN0YXRlID0gcGx1Z2luLmdldFN0YXRlKHZpZXcuc3RhdGUpXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgcGx1Z2luU3RhdGUuc25hcHNob3QgPT0gbnVsbCAmJiBwbHVnaW5TdGF0ZS5wcmV2U25hcHNob3QgPT0gbnVsbFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAvLyBJZiB0aGUgY29udGVudCBkb2Vzbid0IGNoYW5nZSBpbml0aWFsbHksIHdlIGRvbid0IHJlbmRlciBhbnl0aGluZyB0byBZanNcbiAgICAgICAgICAgICAgLy8gSWYgdGhlIGNvbnRlbnQgd2FzIGNsZWFyZWQgYnkgYSB1c2VyIGFjdGlvbiwgd2Ugd2FudCB0byBjYXRjaCB0aGUgY2hhbmdlIGFuZFxuICAgICAgICAgICAgICAvLyByZXByZXNlbnQgaXQgaW4gWWpzXG4gICAgICAgICAgICAgIGluaXRpYWxDb250ZW50Q2hhbmdlZCB8fFxuICAgICAgICAgICAgICB2aWV3LnN0YXRlLmRvYy5jb250ZW50LmZpbmREaWZmU3RhcnQoXG4gICAgICAgICAgICAgICAgdmlldy5zdGF0ZS5kb2MudHlwZS5jcmVhdGVBbmRGaWxsKCkuY29udGVudFxuICAgICAgICAgICAgICApICE9PSBudWxsXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaW5pdGlhbENvbnRlbnRDaGFuZ2VkID0gdHJ1ZVxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgcGx1Z2luU3RhdGUuYWRkVG9IaXN0b3J5ID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgICFwbHVnaW5TdGF0ZS5pc0NoYW5nZU9yaWdpblxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB5VW5kb1BsdWdpblN0YXRlID0geVVuZG9QbHVnaW5LZXkuZ2V0U3RhdGUodmlldy5zdGF0ZSlcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7WS5VbmRvTWFuYWdlcn1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjb25zdCB1bSA9IHlVbmRvUGx1Z2luU3RhdGUgJiYgeVVuZG9QbHVnaW5TdGF0ZS51bmRvTWFuYWdlclxuICAgICAgICAgICAgICAgIGlmICh1bSkge1xuICAgICAgICAgICAgICAgICAgdW0uc3RvcENhcHR1cmluZygpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJpbmRpbmcubXV4KCgpID0+IHtcbiAgICAgICAgICAgICAgICAvKiogQHR5cGUge1kuRG9jfSAqLyAocGx1Z2luU3RhdGUuZG9jKS50cmFuc2FjdCgodHIpID0+IHtcbiAgICAgICAgICAgICAgICAgIHRyLm1ldGEuc2V0KCdhZGRUb0hpc3RvcnknLCBwbHVnaW5TdGF0ZS5hZGRUb0hpc3RvcnkpXG4gICAgICAgICAgICAgICAgICBiaW5kaW5nLl9wcm9zZW1pcnJvckNoYW5nZWQodmlldy5zdGF0ZS5kb2MpXG4gICAgICAgICAgICAgICAgfSwgeVN5bmNQbHVnaW5LZXkpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkZXN0cm95OiAoKSA9PiB7XG4gICAgICAgICAgYmluZGluZy5kZXN0cm95KClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIHBsdWdpblxufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSB0clxuICogQHBhcmFtIHthbnl9IHJlbFNlbFxuICogQHBhcmFtIHtQcm9zZW1pcnJvckJpbmRpbmd9IGJpbmRpbmdcbiAqL1xuY29uc3QgcmVzdG9yZVJlbGF0aXZlU2VsZWN0aW9uID0gKHRyLCByZWxTZWwsIGJpbmRpbmcpID0+IHtcbiAgaWYgKHJlbFNlbCAhPT0gbnVsbCAmJiByZWxTZWwuYW5jaG9yICE9PSBudWxsICYmIHJlbFNlbC5oZWFkICE9PSBudWxsKSB7XG4gICAgY29uc3QgYW5jaG9yID0gcmVsYXRpdmVQb3NpdGlvblRvQWJzb2x1dGVQb3NpdGlvbihcbiAgICAgIGJpbmRpbmcuZG9jLFxuICAgICAgYmluZGluZy50eXBlLFxuICAgICAgcmVsU2VsLmFuY2hvcixcbiAgICAgIGJpbmRpbmcubWFwcGluZ1xuICAgIClcbiAgICBjb25zdCBoZWFkID0gcmVsYXRpdmVQb3NpdGlvblRvQWJzb2x1dGVQb3NpdGlvbihcbiAgICAgIGJpbmRpbmcuZG9jLFxuICAgICAgYmluZGluZy50eXBlLFxuICAgICAgcmVsU2VsLmhlYWQsXG4gICAgICBiaW5kaW5nLm1hcHBpbmdcbiAgICApXG4gICAgaWYgKGFuY2hvciAhPT0gbnVsbCAmJiBoZWFkICE9PSBudWxsKSB7XG4gICAgICB0ciA9IHRyLnNldFNlbGVjdGlvbihUZXh0U2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsIGFuY2hvciwgaGVhZCkpXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBnZXRSZWxhdGl2ZVNlbGVjdGlvbiA9IChwbWJpbmRpbmcsIHN0YXRlKSA9PiAoe1xuICBhbmNob3I6IGFic29sdXRlUG9zaXRpb25Ub1JlbGF0aXZlUG9zaXRpb24oXG4gICAgc3RhdGUuc2VsZWN0aW9uLmFuY2hvcixcbiAgICBwbWJpbmRpbmcudHlwZSxcbiAgICBwbWJpbmRpbmcubWFwcGluZ1xuICApLFxuICBoZWFkOiBhYnNvbHV0ZVBvc2l0aW9uVG9SZWxhdGl2ZVBvc2l0aW9uKFxuICAgIHN0YXRlLnNlbGVjdGlvbi5oZWFkLFxuICAgIHBtYmluZGluZy50eXBlLFxuICAgIHBtYmluZGluZy5tYXBwaW5nXG4gIClcbn0pXG5cbi8qKlxuICogQmluZGluZyBmb3IgcHJvc2VtaXJyb3IuXG4gKlxuICogQHByb3RlY3RlZFxuICovXG5leHBvcnQgY2xhc3MgUHJvc2VtaXJyb3JCaW5kaW5nIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7WS5YbWxGcmFnbWVudH0geVhtbEZyYWdtZW50IFRoZSBiaW5kIHNvdXJjZVxuICAgKiBAcGFyYW0ge1Byb3NlbWlycm9yTWFwcGluZ30gbWFwcGluZ1xuICAgKi9cbiAgY29uc3RydWN0b3IgKHlYbWxGcmFnbWVudCwgbWFwcGluZyA9IG5ldyBNYXAoKSkge1xuICAgIHRoaXMudHlwZSA9IHlYbWxGcmFnbWVudFxuICAgIC8qKlxuICAgICAqIHRoaXMgd2lsbCBiZSBzZXQgb25jZSB0aGUgdmlldyBpcyBjcmVhdGVkXG4gICAgICogQHR5cGUge2FueX1cbiAgICAgKi9cbiAgICB0aGlzLnByb3NlbWlycm9yVmlldyA9IG51bGxcbiAgICB0aGlzLm11eCA9IGNyZWF0ZU11dGV4KClcbiAgICB0aGlzLm1hcHBpbmcgPSBtYXBwaW5nXG4gICAgdGhpcy5fb2JzZXJ2ZUZ1bmN0aW9uID0gdGhpcy5fdHlwZUNoYW5nZWQuYmluZCh0aGlzKVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtZLkRvY31cbiAgICAgKi9cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5kb2MgPSB5WG1sRnJhZ21lbnQuZG9jXG4gICAgLyoqXG4gICAgICogY3VycmVudCBzZWxlY3Rpb24gYXMgcmVsYXRpdmUgcG9zaXRpb25zIGluIHRoZSBZanMgbW9kZWxcbiAgICAgKi9cbiAgICB0aGlzLmJlZm9yZVRyYW5zYWN0aW9uU2VsZWN0aW9uID0gbnVsbFxuICAgIHRoaXMuYmVmb3JlQWxsVHJhbnNhY3Rpb25zID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuYmVmb3JlVHJhbnNhY3Rpb25TZWxlY3Rpb24gPT09IG51bGwgJiYgdGhpcy5wcm9zZW1pcnJvclZpZXcgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLmJlZm9yZVRyYW5zYWN0aW9uU2VsZWN0aW9uID0gZ2V0UmVsYXRpdmVTZWxlY3Rpb24oXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICB0aGlzLnByb3NlbWlycm9yVmlldy5zdGF0ZVxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYWZ0ZXJBbGxUcmFuc2FjdGlvbnMgPSAoKSA9PiB7XG4gICAgICB0aGlzLmJlZm9yZVRyYW5zYWN0aW9uU2VsZWN0aW9uID0gbnVsbFxuICAgIH1cbiAgICB0aGlzLl9kb21TZWxlY3Rpb25JblZpZXcgPSBudWxsXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgdHJhbnNhY3Rpb24gZm9yIGNoYW5naW5nIHRoZSBwcm9zZW1pcnJvciBzdGF0ZS5cbiAgICpcbiAgICogQHJldHVybnNcbiAgICovXG4gIGdldCBfdHIgKCkge1xuICAgIHJldHVybiB0aGlzLnByb3NlbWlycm9yVmlldy5zdGF0ZS50ci5zZXRNZXRhKCdhZGRUb0hpc3RvcnknLCBmYWxzZSlcbiAgfVxuXG4gIF9pc0xvY2FsQ3Vyc29ySW5WaWV3ICgpIHtcbiAgICBpZiAoIXRoaXMucHJvc2VtaXJyb3JWaWV3Lmhhc0ZvY3VzKCkpIHJldHVybiBmYWxzZVxuICAgIGlmIChlbnZpcm9ubWVudC5pc0Jyb3dzZXIgJiYgdGhpcy5fZG9tU2VsZWN0aW9uSW5WaWV3ID09PSBudWxsKSB7XG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIGRvbVNlbGVjdGlvbkluVmlldyBhbmQgY2xlYXIgYnkgbmV4dCB0aWNrIGFmdGVyIGFsbCBldmVudHMgYXJlIGZpbmlzaGVkXG4gICAgICBldmVudGxvb3AudGltZW91dCgwLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2RvbVNlbGVjdGlvbkluVmlldyA9IG51bGxcbiAgICAgIH0pXG4gICAgICB0aGlzLl9kb21TZWxlY3Rpb25JblZpZXcgPSB0aGlzLl9pc0RvbVNlbGVjdGlvbkluVmlldygpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9kb21TZWxlY3Rpb25JblZpZXdcbiAgfVxuXG4gIF9pc0RvbVNlbGVjdGlvbkluVmlldyAoKSB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gdGhpcy5wcm9zZW1pcnJvclZpZXcuX3Jvb3QuZ2V0U2VsZWN0aW9uKClcblxuICAgIGNvbnN0IHJhbmdlID0gdGhpcy5wcm9zZW1pcnJvclZpZXcuX3Jvb3QuY3JlYXRlUmFuZ2UoKVxuICAgIHJhbmdlLnNldFN0YXJ0KHNlbGVjdGlvbi5hbmNob3JOb2RlLCBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0KVxuICAgIHJhbmdlLnNldEVuZChzZWxlY3Rpb24uZm9jdXNOb2RlLCBzZWxlY3Rpb24uZm9jdXNPZmZzZXQpXG5cbiAgICAvLyBUaGlzIGlzIGEgd29ya2Fyb3VuZCBmb3IgYW4gZWRnZWNhc2Ugd2hlcmUgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IHdpbGxcbiAgICAvLyByZXR1cm4gemVybyB2YWx1ZXMgaWYgdGhlIHNlbGVjdGlvbiBpcyBjb2xsYXBzZWQgYXQgdGhlIHN0YXJ0IG9mIGEgbmV3bGluZVxuICAgIC8vIHNlZSByZWZlcmVuY2UgaGVyZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzU5NzgwOTU0XG4gICAgY29uc3QgcmVjdHMgPSByYW5nZS5nZXRDbGllbnRSZWN0cygpXG4gICAgaWYgKHJlY3RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gcHJvYmFibHkgYnVnZ3kgbmV3bGluZSBiZWhhdmlvciwgZXhwbGljaXRseSBzZWxlY3QgdGhlIG5vZGUgY29udGVudHNcbiAgICAgIGlmIChyYW5nZS5zdGFydENvbnRhaW5lciAmJiByYW5nZS5jb2xsYXBzZWQpIHtcbiAgICAgICAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKHJhbmdlLnN0YXJ0Q29udGFpbmVyKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGJvdW5kaW5nID0gcmFuZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICBjb25zdCBkb2N1bWVudEVsZW1lbnQgPSBkb20uZG9jLmRvY3VtZW50RWxlbWVudFxuXG4gICAgcmV0dXJuIGJvdW5kaW5nLmJvdHRvbSA+PSAwICYmIGJvdW5kaW5nLnJpZ2h0ID49IDAgJiZcbiAgICAgIGJvdW5kaW5nLmxlZnQgPD1cbiAgICAgICAgKHdpbmRvdy5pbm5lcldpZHRoIHx8IGRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCB8fCAwKSAmJlxuICAgICAgYm91bmRpbmcudG9wIDw9ICh3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCB8fCAwKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7WS5TbmFwc2hvdH0gc25hcHNob3RcbiAgICogQHBhcmFtIHtZLlNuYXBzaG90fSBwcmV2U25hcHNob3RcbiAgICovXG4gIHJlbmRlclNuYXBzaG90IChzbmFwc2hvdCwgcHJldlNuYXBzaG90KSB7XG4gICAgaWYgKCFwcmV2U25hcHNob3QpIHtcbiAgICAgIHByZXZTbmFwc2hvdCA9IFkuY3JlYXRlU25hcHNob3QoWS5jcmVhdGVEZWxldGVTZXQoKSwgbmV3IE1hcCgpKVxuICAgIH1cbiAgICB0aGlzLnByb3NlbWlycm9yVmlldy5kaXNwYXRjaChcbiAgICAgIHRoaXMuX3RyLnNldE1ldGEoeVN5bmNQbHVnaW5LZXksIHsgc25hcHNob3QsIHByZXZTbmFwc2hvdCB9KVxuICAgIClcbiAgfVxuXG4gIHVucmVuZGVyU25hcHNob3QgKCkge1xuICAgIHRoaXMubWFwcGluZy5jbGVhcigpXG4gICAgdGhpcy5tdXgoKCkgPT4ge1xuICAgICAgY29uc3QgZnJhZ21lbnRDb250ZW50ID0gdGhpcy50eXBlLnRvQXJyYXkoKS5tYXAoKHQpID0+XG4gICAgICAgIGNyZWF0ZU5vZGVGcm9tWUVsZW1lbnQoXG4gICAgICAgICAgLyoqIEB0eXBlIHtZLlhtbEVsZW1lbnR9ICovICh0KSxcbiAgICAgICAgICB0aGlzLnByb3NlbWlycm9yVmlldy5zdGF0ZS5zY2hlbWEsXG4gICAgICAgICAgdGhpcy5tYXBwaW5nXG4gICAgICAgIClcbiAgICAgICkuZmlsdGVyKChuKSA9PiBuICE9PSBudWxsKVxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgY29uc3QgdHIgPSB0aGlzLl90ci5yZXBsYWNlKFxuICAgICAgICAwLFxuICAgICAgICB0aGlzLnByb3NlbWlycm9yVmlldy5zdGF0ZS5kb2MuY29udGVudC5zaXplLFxuICAgICAgICBuZXcgUE1vZGVsLlNsaWNlKFBNb2RlbC5GcmFnbWVudC5mcm9tKGZyYWdtZW50Q29udGVudCksIDAsIDApXG4gICAgICApXG4gICAgICB0ci5zZXRNZXRhKHlTeW5jUGx1Z2luS2V5LCB7IHNuYXBzaG90OiBudWxsLCBwcmV2U25hcHNob3Q6IG51bGwgfSlcbiAgICAgIHRoaXMucHJvc2VtaXJyb3JWaWV3LmRpc3BhdGNoKHRyKVxuICAgIH0pXG4gIH1cblxuICBfZm9yY2VSZXJlbmRlciAoKSB7XG4gICAgdGhpcy5tYXBwaW5nLmNsZWFyKClcbiAgICB0aGlzLm11eCgoKSA9PiB7XG4gICAgICAvLyBJZiB0aGlzIGlzIGEgZm9yY2VkIHJlcmVuZGVyLCB0aGlzIG1pZ2h0IG5laXRoZXIgaGFwcGVuIGFzIGEgcG0gY2hhbmdlIG5vciB3aXRoaW4gYSBZanNcbiAgICAgIC8vIHRyYW5zYWN0aW9uLiBUaGVuIHRoZSBcImJlZm9yZSBzZWxlY3Rpb25cIiBkb2Vzbid0IGV4aXN0LiBJbiB0aGlzIGNhc2UsIHdlIG5lZWQgdG8gY3JlYXRlIGFcbiAgICAgIC8vIHJlbGF0aXZlIHBvc2l0aW9uIGJlZm9yZSByZXBsYWNpbmcgY29udGVudC4gRml4ZXMgIzEyNlxuICAgICAgY29uc3Qgc2VsID0gdGhpcy5iZWZvcmVUcmFuc2FjdGlvblNlbGVjdGlvbiAhPT0gbnVsbCA/IG51bGwgOiB0aGlzLnByb3NlbWlycm9yVmlldy5zdGF0ZS5zZWxlY3Rpb25cbiAgICAgIGNvbnN0IGZyYWdtZW50Q29udGVudCA9IHRoaXMudHlwZS50b0FycmF5KCkubWFwKCh0KSA9PlxuICAgICAgICBjcmVhdGVOb2RlRnJvbVlFbGVtZW50KFxuICAgICAgICAgIC8qKiBAdHlwZSB7WS5YbWxFbGVtZW50fSAqLyAodCksXG4gICAgICAgICAgdGhpcy5wcm9zZW1pcnJvclZpZXcuc3RhdGUuc2NoZW1hLFxuICAgICAgICAgIHRoaXMubWFwcGluZ1xuICAgICAgICApXG4gICAgICApLmZpbHRlcigobikgPT4gbiAhPT0gbnVsbClcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGNvbnN0IHRyID0gdGhpcy5fdHIucmVwbGFjZShcbiAgICAgICAgMCxcbiAgICAgICAgdGhpcy5wcm9zZW1pcnJvclZpZXcuc3RhdGUuZG9jLmNvbnRlbnQuc2l6ZSxcbiAgICAgICAgbmV3IFBNb2RlbC5TbGljZShQTW9kZWwuRnJhZ21lbnQuZnJvbShmcmFnbWVudENvbnRlbnQpLCAwLCAwKVxuICAgICAgKVxuICAgICAgaWYgKHNlbCkge1xuICAgICAgICB0ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCBzZWwuYW5jaG9yLCBzZWwuaGVhZCkpXG4gICAgICB9XG4gICAgICB0aGlzLnByb3NlbWlycm9yVmlldy5kaXNwYXRjaChcbiAgICAgICAgdHIuc2V0TWV0YSh5U3luY1BsdWdpbktleSwgeyBpc0NoYW5nZU9yaWdpbjogdHJ1ZSwgYmluZGluZzogdGhpcyB9KVxuICAgICAgKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtZLlNuYXBzaG90fFVpbnQ4QXJyYXl9IHNuYXBzaG90XG4gICAqIEBwYXJhbSB7WS5TbmFwc2hvdHxVaW50OEFycmF5fSBwcmV2U25hcHNob3RcbiAgICogQHBhcmFtIHtPYmplY3R9IHBsdWdpblN0YXRlXG4gICAqL1xuICBfcmVuZGVyU25hcHNob3QgKHNuYXBzaG90LCBwcmV2U25hcHNob3QsIHBsdWdpblN0YXRlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGRvY3VtZW50IHRoYXQgY29udGFpbnMgdGhlIGZ1bGwgaGlzdG9yeSBvZiB0aGlzIGRvY3VtZW50LlxuICAgICAqIEB0eXBlIHtZLkRvY31cbiAgICAgKi9cbiAgICBsZXQgaGlzdG9yeURvYyA9IHRoaXMuZG9jXG4gICAgaWYgKCFzbmFwc2hvdCkge1xuICAgICAgc25hcHNob3QgPSBZLnNuYXBzaG90KHRoaXMuZG9jKVxuICAgIH1cbiAgICBpZiAoc25hcHNob3QgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IHByZXZTbmFwc2hvdCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIGlmICghKHNuYXBzaG90IGluc3RhbmNlb2YgVWludDhBcnJheSkgfHwgIShwcmV2U25hcHNob3QgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICAvLyBleHBlY3RlZCBib3RoIHNuYXBzaG90cyB0byBiZSB2MiB1cGRhdGVzXG4gICAgICAgIGVycm9yLnVuZXhwZWN0ZWRDYXNlKClcbiAgICAgIH1cbiAgICAgIGhpc3RvcnlEb2MgPSBuZXcgWS5Eb2MoeyBnYzogZmFsc2UgfSlcbiAgICAgIFkuYXBwbHlVcGRhdGVWMihoaXN0b3J5RG9jLCBwcmV2U25hcHNob3QpXG4gICAgICBwcmV2U25hcHNob3QgPSBZLnNuYXBzaG90KGhpc3RvcnlEb2MpXG4gICAgICBZLmFwcGx5VXBkYXRlVjIoaGlzdG9yeURvYywgc25hcHNob3QpXG4gICAgICBzbmFwc2hvdCA9IFkuc25hcHNob3QoaGlzdG9yeURvYylcbiAgICB9XG4gICAgLy8gY2xlYXIgbWFwcGluZyBiZWNhdXNlIHdlIGFyZSBnb2luZyB0byByZXJlbmRlclxuICAgIHRoaXMubWFwcGluZy5jbGVhcigpXG4gICAgdGhpcy5tdXgoKCkgPT4ge1xuICAgICAgaGlzdG9yeURvYy50cmFuc2FjdCgodHJhbnNhY3Rpb24pID0+IHtcbiAgICAgICAgLy8gYmVmb3JlIHJlbmRlcmluZywgd2UgYXJlIGdvaW5nIHRvIHNhbml0aXplIG9wcyBhbmQgc3BsaXQgZGVsZXRlZCBvcHNcbiAgICAgICAgLy8gaWYgdGhleSB3ZXJlIGRlbGV0ZWQgYnkgc2VwZXJhdGUgdXNlcnMuXG4gICAgICAgIGNvbnN0IHB1ZCA9IHBsdWdpblN0YXRlLnBlcm1hbmVudFVzZXJEYXRhXG4gICAgICAgIGlmIChwdWQpIHtcbiAgICAgICAgICBwdWQuZHNzLmZvckVhY2goKGRzKSA9PiB7XG4gICAgICAgICAgICBZLml0ZXJhdGVEZWxldGVkU3RydWN0cyh0cmFuc2FjdGlvbiwgZHMsIChfaXRlbSkgPT4ge30pXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHsncmVtb3ZlZCd8J2FkZGVkJ30gdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge1kuSUR9IGlkXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBjb21wdXRlWUNoYW5nZSA9ICh0eXBlLCBpZCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHVzZXIgPSB0eXBlID09PSAnYWRkZWQnXG4gICAgICAgICAgICA/IHB1ZC5nZXRVc2VyQnlDbGllbnRJZChpZC5jbGllbnQpXG4gICAgICAgICAgICA6IHB1ZC5nZXRVc2VyQnlEZWxldGVkSWQoaWQpXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVzZXIsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgY29sb3I6IGdldFVzZXJDb2xvcihcbiAgICAgICAgICAgICAgcGx1Z2luU3RhdGUuY29sb3JNYXBwaW5nLFxuICAgICAgICAgICAgICBwbHVnaW5TdGF0ZS5jb2xvcnMsXG4gICAgICAgICAgICAgIHVzZXJcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIGRvY3VtZW50IGZyYWdtZW50IGFuZCByZW5kZXJcbiAgICAgICAgY29uc3QgZnJhZ21lbnRDb250ZW50ID0gWS50eXBlTGlzdFRvQXJyYXlTbmFwc2hvdChcbiAgICAgICAgICB0aGlzLnR5cGUsXG4gICAgICAgICAgbmV3IFkuU25hcHNob3QocHJldlNuYXBzaG90LmRzLCBzbmFwc2hvdC5zdilcbiAgICAgICAgKS5tYXAoKHQpID0+IHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhdC5faXRlbS5kZWxldGVkIHx8IGlzVmlzaWJsZSh0Ll9pdGVtLCBzbmFwc2hvdCkgfHxcbiAgICAgICAgICAgIGlzVmlzaWJsZSh0Ll9pdGVtLCBwcmV2U25hcHNob3QpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTm9kZUZyb21ZRWxlbWVudChcbiAgICAgICAgICAgICAgdCxcbiAgICAgICAgICAgICAgdGhpcy5wcm9zZW1pcnJvclZpZXcuc3RhdGUuc2NoZW1hLFxuICAgICAgICAgICAgICBuZXcgTWFwKCksXG4gICAgICAgICAgICAgIHNuYXBzaG90LFxuICAgICAgICAgICAgICBwcmV2U25hcHNob3QsXG4gICAgICAgICAgICAgIGNvbXB1dGVZQ2hhbmdlXG4gICAgICAgICAgICApXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gcmVuZGVyIGVsZW1lbnRzIHRoYXQgYXJlIG5vdCB2aXNpYmxlIGJ5IGVpdGhlciBzbmFwc2hvdC5cbiAgICAgICAgICAgIC8vIElmIGEgY2xpZW50IGFkZHMgYW5kIGRlbGV0ZXMgY29udGVudCBpbiB0aGUgc2FtZSBzbmFwc2hvdCB0aGUgZWxlbWVudCBpcyBub3QgdmlzaWJsZSBieSBlaXRoZXIgc25hcHNob3QuXG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICAgIH1cbiAgICAgICAgfSkuZmlsdGVyKChuKSA9PiBuICE9PSBudWxsKVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGNvbnN0IHRyID0gdGhpcy5fdHIucmVwbGFjZShcbiAgICAgICAgICAwLFxuICAgICAgICAgIHRoaXMucHJvc2VtaXJyb3JWaWV3LnN0YXRlLmRvYy5jb250ZW50LnNpemUsXG4gICAgICAgICAgbmV3IFBNb2RlbC5TbGljZShQTW9kZWwuRnJhZ21lbnQuZnJvbShmcmFnbWVudENvbnRlbnQpLCAwLCAwKVxuICAgICAgICApXG4gICAgICAgIHRoaXMucHJvc2VtaXJyb3JWaWV3LmRpc3BhdGNoKFxuICAgICAgICAgIHRyLnNldE1ldGEoeVN5bmNQbHVnaW5LZXksIHsgaXNDaGFuZ2VPcmlnaW46IHRydWUgfSlcbiAgICAgICAgKVxuICAgICAgfSwgeVN5bmNQbHVnaW5LZXkpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PFkuWUV2ZW50PGFueT4+fSBldmVudHNcbiAgICogQHBhcmFtIHtZLlRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKi9cbiAgX3R5cGVDaGFuZ2VkIChldmVudHMsIHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKHRoaXMucHJvc2VtaXJyb3JWaWV3ID09IG51bGwpIHJldHVyblxuICAgIGNvbnN0IHN5bmNTdGF0ZSA9IHlTeW5jUGx1Z2luS2V5LmdldFN0YXRlKHRoaXMucHJvc2VtaXJyb3JWaWV3LnN0YXRlKVxuICAgIGlmIChcbiAgICAgIGV2ZW50cy5sZW5ndGggPT09IDAgfHwgc3luY1N0YXRlLnNuYXBzaG90ICE9IG51bGwgfHxcbiAgICAgIHN5bmNTdGF0ZS5wcmV2U25hcHNob3QgIT0gbnVsbFxuICAgICkge1xuICAgICAgLy8gZHJvcCBvdXQgaWYgc25hcHNob3QgaXMgYWN0aXZlXG4gICAgICB0aGlzLnJlbmRlclNuYXBzaG90KHN5bmNTdGF0ZS5zbmFwc2hvdCwgc3luY1N0YXRlLnByZXZTbmFwc2hvdClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0aGlzLm11eCgoKSA9PiB7XG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7YW55fSBfXG4gICAgICAgKiBAcGFyYW0ge1kuQWJzdHJhY3RUeXBlPGFueT59IHR5cGVcbiAgICAgICAqL1xuICAgICAgY29uc3QgZGVsVHlwZSA9IChfLCB0eXBlKSA9PiB0aGlzLm1hcHBpbmcuZGVsZXRlKHR5cGUpXG4gICAgICBZLml0ZXJhdGVEZWxldGVkU3RydWN0cyhcbiAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgIHRyYW5zYWN0aW9uLmRlbGV0ZVNldCxcbiAgICAgICAgKHN0cnVjdCkgPT4ge1xuICAgICAgICAgIGlmIChzdHJ1Y3QuY29uc3RydWN0b3IgPT09IFkuSXRlbSkge1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IC8qKiBAdHlwZSB7WS5Db250ZW50VHlwZX0gKi8gKC8qKiBAdHlwZSB7WS5JdGVtfSAqLyAoc3RydWN0KS5jb250ZW50KS50eXBlXG4gICAgICAgICAgICB0eXBlICYmIHRoaXMubWFwcGluZy5kZWxldGUodHlwZSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIClcbiAgICAgIHRyYW5zYWN0aW9uLmNoYW5nZWQuZm9yRWFjaChkZWxUeXBlKVxuICAgICAgdHJhbnNhY3Rpb24uY2hhbmdlZFBhcmVudFR5cGVzLmZvckVhY2goZGVsVHlwZSlcbiAgICAgIGNvbnN0IGZyYWdtZW50Q29udGVudCA9IHRoaXMudHlwZS50b0FycmF5KCkubWFwKCh0KSA9PlxuICAgICAgICBjcmVhdGVOb2RlSWZOb3RFeGlzdHMoXG4gICAgICAgICAgLyoqIEB0eXBlIHtZLlhtbEVsZW1lbnQgfCBZLlhtbEhvb2t9ICovICh0KSxcbiAgICAgICAgICB0aGlzLnByb3NlbWlycm9yVmlldy5zdGF0ZS5zY2hlbWEsXG4gICAgICAgICAgdGhpcy5tYXBwaW5nXG4gICAgICAgIClcbiAgICAgICkuZmlsdGVyKChuKSA9PiBuICE9PSBudWxsKVxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgbGV0IHRyID0gdGhpcy5fdHIucmVwbGFjZShcbiAgICAgICAgMCxcbiAgICAgICAgdGhpcy5wcm9zZW1pcnJvclZpZXcuc3RhdGUuZG9jLmNvbnRlbnQuc2l6ZSxcbiAgICAgICAgbmV3IFBNb2RlbC5TbGljZShQTW9kZWwuRnJhZ21lbnQuZnJvbShmcmFnbWVudENvbnRlbnQpLCAwLCAwKVxuICAgICAgKVxuICAgICAgcmVzdG9yZVJlbGF0aXZlU2VsZWN0aW9uKHRyLCB0aGlzLmJlZm9yZVRyYW5zYWN0aW9uU2VsZWN0aW9uLCB0aGlzKVxuICAgICAgdHIgPSB0ci5zZXRNZXRhKHlTeW5jUGx1Z2luS2V5LCB7IGlzQ2hhbmdlT3JpZ2luOiB0cnVlLCBpc1VuZG9SZWRvT3BlcmF0aW9uOiB0cmFuc2FjdGlvbi5vcmlnaW4gaW5zdGFuY2VvZiBZLlVuZG9NYW5hZ2VyIH0pXG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuYmVmb3JlVHJhbnNhY3Rpb25TZWxlY3Rpb24gIT09IG51bGwgJiYgdGhpcy5faXNMb2NhbEN1cnNvckluVmlldygpXG4gICAgICApIHtcbiAgICAgICAgdHIuc2Nyb2xsSW50b1ZpZXcoKVxuICAgICAgfVxuICAgICAgdGhpcy5wcm9zZW1pcnJvclZpZXcuZGlzcGF0Y2godHIpXG4gICAgfSlcbiAgfVxuXG4gIF9wcm9zZW1pcnJvckNoYW5nZWQgKGRvYykge1xuICAgIHRoaXMuZG9jLnRyYW5zYWN0KCgpID0+IHtcbiAgICAgIHVwZGF0ZVlGcmFnbWVudCh0aGlzLmRvYywgdGhpcy50eXBlLCBkb2MsIHRoaXMubWFwcGluZylcbiAgICAgIHRoaXMuYmVmb3JlVHJhbnNhY3Rpb25TZWxlY3Rpb24gPSBnZXRSZWxhdGl2ZVNlbGVjdGlvbihcbiAgICAgICAgdGhpcyxcbiAgICAgICAgdGhpcy5wcm9zZW1pcnJvclZpZXcuc3RhdGVcbiAgICAgIClcbiAgICB9LCB5U3luY1BsdWdpbktleSlcbiAgfVxuXG4gIC8qKlxuICAgKiBWaWV3IGlzIHJlYWR5IHRvIGxpc3RlbiB0byBjaGFuZ2VzLiBSZWdpc3RlciBvYnNlcnZlcnMuXG4gICAqIEBwYXJhbSB7YW55fSBwcm9zZW1pcnJvclZpZXdcbiAgICovXG4gIGluaXRWaWV3IChwcm9zZW1pcnJvclZpZXcpIHtcbiAgICBpZiAodGhpcy5wcm9zZW1pcnJvclZpZXcgIT0gbnVsbCkgdGhpcy5kZXN0cm95KClcbiAgICB0aGlzLnByb3NlbWlycm9yVmlldyA9IHByb3NlbWlycm9yVmlld1xuICAgIHRoaXMuZG9jLm9uKCdiZWZvcmVBbGxUcmFuc2FjdGlvbnMnLCB0aGlzLmJlZm9yZUFsbFRyYW5zYWN0aW9ucylcbiAgICB0aGlzLmRvYy5vbignYWZ0ZXJBbGxUcmFuc2FjdGlvbnMnLCB0aGlzLmFmdGVyQWxsVHJhbnNhY3Rpb25zKVxuICAgIHRoaXMudHlwZS5vYnNlcnZlRGVlcCh0aGlzLl9vYnNlcnZlRnVuY3Rpb24pXG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICBpZiAodGhpcy5wcm9zZW1pcnJvclZpZXcgPT0gbnVsbCkgcmV0dXJuXG4gICAgdGhpcy5wcm9zZW1pcnJvclZpZXcgPSBudWxsXG4gICAgdGhpcy50eXBlLnVub2JzZXJ2ZURlZXAodGhpcy5fb2JzZXJ2ZUZ1bmN0aW9uKVxuICAgIHRoaXMuZG9jLm9mZignYmVmb3JlQWxsVHJhbnNhY3Rpb25zJywgdGhpcy5iZWZvcmVBbGxUcmFuc2FjdGlvbnMpXG4gICAgdGhpcy5kb2Mub2ZmKCdhZnRlckFsbFRyYW5zYWN0aW9ucycsIHRoaXMuYWZ0ZXJBbGxUcmFuc2FjdGlvbnMpXG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtZLlhtbEVsZW1lbnQgfCBZLlhtbEhvb2t9IGVsXG4gKiBAcGFyYW0ge1BNb2RlbC5TY2hlbWF9IHNjaGVtYVxuICogQHBhcmFtIHtQcm9zZW1pcnJvck1hcHBpbmd9IG1hcHBpbmdcbiAqIEBwYXJhbSB7WS5TbmFwc2hvdH0gW3NuYXBzaG90XVxuICogQHBhcmFtIHtZLlNuYXBzaG90fSBbcHJldlNuYXBzaG90XVxuICogQHBhcmFtIHtmdW5jdGlvbigncmVtb3ZlZCcgfCAnYWRkZWQnLCBZLklEKTphbnl9IFtjb21wdXRlWUNoYW5nZV1cbiAqIEByZXR1cm4ge1BNb2RlbC5Ob2RlIHwgbnVsbH1cbiAqL1xuY29uc3QgY3JlYXRlTm9kZUlmTm90RXhpc3RzID0gKFxuICBlbCxcbiAgc2NoZW1hLFxuICBtYXBwaW5nLFxuICBzbmFwc2hvdCxcbiAgcHJldlNuYXBzaG90LFxuICBjb21wdXRlWUNoYW5nZVxuKSA9PiB7XG4gIGNvbnN0IG5vZGUgPSAvKiogQHR5cGUge1BNb2RlbC5Ob2RlfSAqLyAobWFwcGluZy5nZXQoZWwpKVxuICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGVsIGluc3RhbmNlb2YgWS5YbWxFbGVtZW50KSB7XG4gICAgICByZXR1cm4gY3JlYXRlTm9kZUZyb21ZRWxlbWVudChcbiAgICAgICAgZWwsXG4gICAgICAgIHNjaGVtYSxcbiAgICAgICAgbWFwcGluZyxcbiAgICAgICAgc25hcHNob3QsXG4gICAgICAgIHByZXZTbmFwc2hvdCxcbiAgICAgICAgY29tcHV0ZVlDaGFuZ2VcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyb3IubWV0aG9kVW5pbXBsZW1lbnRlZCgpIC8vIHdlIGFyZSBjdXJyZW50bHkgbm90IGhhbmRsaW5nIGhvb2tzXG4gICAgfVxuICB9XG4gIHJldHVybiBub2RlXG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7WS5YbWxFbGVtZW50fSBlbFxuICogQHBhcmFtIHthbnl9IHNjaGVtYVxuICogQHBhcmFtIHtQcm9zZW1pcnJvck1hcHBpbmd9IG1hcHBpbmdcbiAqIEBwYXJhbSB7WS5TbmFwc2hvdH0gW3NuYXBzaG90XVxuICogQHBhcmFtIHtZLlNuYXBzaG90fSBbcHJldlNuYXBzaG90XVxuICogQHBhcmFtIHtmdW5jdGlvbigncmVtb3ZlZCcgfCAnYWRkZWQnLCBZLklEKTphbnl9IFtjb21wdXRlWUNoYW5nZV1cbiAqIEByZXR1cm4ge1BNb2RlbC5Ob2RlIHwgbnVsbH0gUmV0dXJucyBub2RlIGlmIG5vZGUgY291bGQgYmUgY3JlYXRlZC4gT3RoZXJ3aXNlIGl0IGRlbGV0ZXMgdGhlIHlqcyB0eXBlIGFuZCByZXR1cm5zIG51bGxcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZU5vZGVGcm9tWUVsZW1lbnQgPSAoXG4gIGVsLFxuICBzY2hlbWEsXG4gIG1hcHBpbmcsXG4gIHNuYXBzaG90LFxuICBwcmV2U25hcHNob3QsXG4gIGNvbXB1dGVZQ2hhbmdlXG4pID0+IHtcbiAgY29uc3QgY2hpbGRyZW4gPSBbXVxuICBjb25zdCBjcmVhdGVDaGlsZHJlbiA9ICh0eXBlKSA9PiB7XG4gICAgaWYgKHR5cGUuY29uc3RydWN0b3IgPT09IFkuWG1sRWxlbWVudCkge1xuICAgICAgY29uc3QgbiA9IGNyZWF0ZU5vZGVJZk5vdEV4aXN0cyhcbiAgICAgICAgdHlwZSxcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICBtYXBwaW5nLFxuICAgICAgICBzbmFwc2hvdCxcbiAgICAgICAgcHJldlNuYXBzaG90LFxuICAgICAgICBjb21wdXRlWUNoYW5nZVxuICAgICAgKVxuICAgICAgaWYgKG4gIT09IG51bGwpIHtcbiAgICAgICAgY2hpbGRyZW4ucHVzaChuKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGUgbmV4dCB5dGV4dCBleGlzdHMgYW5kIHdhcyBjcmVhdGVkIGJ5IHVzLCBtb3ZlIHRoZSBjb250ZW50IHRvIHRoZSBjdXJyZW50IHl0ZXh0LlxuICAgICAgLy8gVGhpcyBpcyBhIGZpeCBmb3IgIzE2MCAtLSBkdXBsaWNhdGlvbiBvZiBjaGFyYWN0ZXJzIHdoZW4gdHdvIFkuVGV4dCBleGlzdCBuZXh0IHRvIGVhY2hcbiAgICAgIC8vIG90aGVyLlxuICAgICAgY29uc3QgbmV4dHl0ZXh0ID0gdHlwZS5faXRlbS5yaWdodD8uY29udGVudC50eXBlXG4gICAgICBpZiAobmV4dHl0ZXh0IGluc3RhbmNlb2YgWS5UZXh0ICYmICFuZXh0eXRleHQuX2l0ZW0uZGVsZXRlZCAmJiBuZXh0eXRleHQuX2l0ZW0uaWQuY2xpZW50ID09PSBuZXh0eXRleHQuZG9jLmNsaWVudElEKSB7XG4gICAgICAgIHR5cGUuYXBwbHlEZWx0YShbXG4gICAgICAgICAgeyByZXRhaW46IHR5cGUubGVuZ3RoIH0sXG4gICAgICAgICAgLi4ubmV4dHl0ZXh0LnRvRGVsdGEoKVxuICAgICAgICBdKVxuICAgICAgICBuZXh0eXRleHQuZG9jLnRyYW5zYWN0KHRyID0+IHtcbiAgICAgICAgICBuZXh0eXRleHQuX2l0ZW0uZGVsZXRlKHRyKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgLy8gbm93IGNyZWF0ZSB0aGUgcHJvc2VtaXJyb3IgdGV4dCBub2Rlc1xuICAgICAgY29uc3QgbnMgPSBjcmVhdGVUZXh0Tm9kZXNGcm9tWVRleHQoXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHNjaGVtYSxcbiAgICAgICAgbWFwcGluZyxcbiAgICAgICAgc25hcHNob3QsXG4gICAgICAgIHByZXZTbmFwc2hvdCxcbiAgICAgICAgY29tcHV0ZVlDaGFuZ2VcbiAgICAgIClcbiAgICAgIGlmIChucyAhPT0gbnVsbCkge1xuICAgICAgICBucy5mb3JFYWNoKCh0ZXh0Y2hpbGQpID0+IHtcbiAgICAgICAgICBpZiAodGV4dGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHRleHRjaGlsZClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChzbmFwc2hvdCA9PT0gdW5kZWZpbmVkIHx8IHByZXZTbmFwc2hvdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZWwudG9BcnJheSgpLmZvckVhY2goY3JlYXRlQ2hpbGRyZW4pXG4gIH0gZWxzZSB7XG4gICAgWS50eXBlTGlzdFRvQXJyYXlTbmFwc2hvdChlbCwgbmV3IFkuU25hcHNob3QocHJldlNuYXBzaG90LmRzLCBzbmFwc2hvdC5zdikpXG4gICAgICAuZm9yRWFjaChjcmVhdGVDaGlsZHJlbilcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IGF0dHJzID0gZWwuZ2V0QXR0cmlidXRlcyhzbmFwc2hvdClcbiAgICBpZiAoc25hcHNob3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCFpc1Zpc2libGUoLyoqIEB0eXBlIHtZLkl0ZW19ICovIChlbC5faXRlbSksIHNuYXBzaG90KSkge1xuICAgICAgICBhdHRycy55Y2hhbmdlID0gY29tcHV0ZVlDaGFuZ2VcbiAgICAgICAgICA/IGNvbXB1dGVZQ2hhbmdlKCdyZW1vdmVkJywgLyoqIEB0eXBlIHtZLkl0ZW19ICovIChlbC5faXRlbSkuaWQpXG4gICAgICAgICAgOiB7IHR5cGU6ICdyZW1vdmVkJyB9XG4gICAgICB9IGVsc2UgaWYgKCFpc1Zpc2libGUoLyoqIEB0eXBlIHtZLkl0ZW19ICovIChlbC5faXRlbSksIHByZXZTbmFwc2hvdCkpIHtcbiAgICAgICAgYXR0cnMueWNoYW5nZSA9IGNvbXB1dGVZQ2hhbmdlXG4gICAgICAgICAgPyBjb21wdXRlWUNoYW5nZSgnYWRkZWQnLCAvKiogQHR5cGUge1kuSXRlbX0gKi8gKGVsLl9pdGVtKS5pZClcbiAgICAgICAgICA6IHsgdHlwZTogJ2FkZGVkJyB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSBzY2hlbWEubm9kZShlbC5ub2RlTmFtZSwgYXR0cnMsIGNoaWxkcmVuKVxuICAgIG1hcHBpbmcuc2V0KGVsLCBub2RlKVxuICAgIHJldHVybiBub2RlXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBhbiBlcnJvciBvY2N1cmVkIHdoaWxlIGNyZWF0aW5nIHRoZSBub2RlLiBUaGlzIGlzIHByb2JhYmx5IGEgcmVzdWx0IG9mIGEgY29uY3VycmVudCBhY3Rpb24uXG4gICAgLyoqIEB0eXBlIHtZLkRvY30gKi8gKGVsLmRvYykudHJhbnNhY3QoKHRyYW5zYWN0aW9uKSA9PiB7XG4gICAgICAvKiogQHR5cGUge1kuSXRlbX0gKi8gKGVsLl9pdGVtKS5kZWxldGUodHJhbnNhY3Rpb24pXG4gICAgfSwgeVN5bmNQbHVnaW5LZXkpXG4gICAgbWFwcGluZy5kZWxldGUoZWwpXG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1kuWG1sVGV4dH0gdGV4dFxuICogQHBhcmFtIHthbnl9IHNjaGVtYVxuICogQHBhcmFtIHtQcm9zZW1pcnJvck1hcHBpbmd9IF9tYXBwaW5nXG4gKiBAcGFyYW0ge1kuU25hcHNob3R9IFtzbmFwc2hvdF1cbiAqIEBwYXJhbSB7WS5TbmFwc2hvdH0gW3ByZXZTbmFwc2hvdF1cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oJ3JlbW92ZWQnIHwgJ2FkZGVkJywgWS5JRCk6YW55fSBbY29tcHV0ZVlDaGFuZ2VdXG4gKiBAcmV0dXJuIHtBcnJheTxQTW9kZWwuTm9kZT58bnVsbH1cbiAqL1xuY29uc3QgY3JlYXRlVGV4dE5vZGVzRnJvbVlUZXh0ID0gKFxuICB0ZXh0LFxuICBzY2hlbWEsXG4gIF9tYXBwaW5nLFxuICBzbmFwc2hvdCxcbiAgcHJldlNuYXBzaG90LFxuICBjb21wdXRlWUNoYW5nZVxuKSA9PiB7XG4gIGNvbnN0IG5vZGVzID0gW11cbiAgY29uc3QgZGVsdGFzID0gdGV4dC50b0RlbHRhKHNuYXBzaG90LCBwcmV2U25hcHNob3QsIGNvbXB1dGVZQ2hhbmdlKVxuICB0cnkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVsdGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBkZWx0YSA9IGRlbHRhc1tpXVxuICAgICAgY29uc3QgbWFya3MgPSBbXVxuICAgICAgZm9yIChjb25zdCBtYXJrTmFtZSBpbiBkZWx0YS5hdHRyaWJ1dGVzKSB7XG4gICAgICAgIG1hcmtzLnB1c2goc2NoZW1hLm1hcmsobWFya05hbWUsIGRlbHRhLmF0dHJpYnV0ZXNbbWFya05hbWVdKSlcbiAgICAgIH1cbiAgICAgIG5vZGVzLnB1c2goc2NoZW1hLnRleHQoZGVsdGEuaW5zZXJ0LCBtYXJrcykpXG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gYW4gZXJyb3Igb2NjdXJlZCB3aGlsZSBjcmVhdGluZyB0aGUgbm9kZS4gVGhpcyBpcyBwcm9iYWJseSBhIHJlc3VsdCBvZiBhIGNvbmN1cnJlbnQgYWN0aW9uLlxuICAgIC8qKiBAdHlwZSB7WS5Eb2N9ICovICh0ZXh0LmRvYykudHJhbnNhY3QoKHRyYW5zYWN0aW9uKSA9PiB7XG4gICAgICAvKiogQHR5cGUge1kuSXRlbX0gKi8gKHRleHQuX2l0ZW0pLmRlbGV0ZSh0cmFuc2FjdGlvbilcbiAgICB9LCB5U3luY1BsdWdpbktleSlcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIC8vIEB0cy1pZ25vcmVcbiAgcmV0dXJuIG5vZGVzXG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gbm9kZXMgcHJvc2VtaXJyb3Igbm9kZVxuICogQHBhcmFtIHtQcm9zZW1pcnJvck1hcHBpbmd9IG1hcHBpbmdcbiAqIEByZXR1cm4ge1kuWG1sVGV4dH1cbiAqL1xuY29uc3QgY3JlYXRlVHlwZUZyb21UZXh0Tm9kZXMgPSAobm9kZXMsIG1hcHBpbmcpID0+IHtcbiAgY29uc3QgdHlwZSA9IG5ldyBZLlhtbFRleHQoKVxuICBjb25zdCBkZWx0YSA9IG5vZGVzLm1hcCgobm9kZSkgPT4gKHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaW5zZXJ0OiBub2RlLnRleHQsXG4gICAgYXR0cmlidXRlczogbWFya3NUb0F0dHJpYnV0ZXMobm9kZS5tYXJrcylcbiAgfSkpXG4gIHR5cGUuYXBwbHlEZWx0YShkZWx0YSlcbiAgbWFwcGluZy5zZXQodHlwZSwgbm9kZXMpXG4gIHJldHVybiB0eXBlXG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7YW55fSBub2RlIHByb3NlbWlycm9yIG5vZGVcbiAqIEBwYXJhbSB7UHJvc2VtaXJyb3JNYXBwaW5nfSBtYXBwaW5nXG4gKiBAcmV0dXJuIHtZLlhtbEVsZW1lbnR9XG4gKi9cbmNvbnN0IGNyZWF0ZVR5cGVGcm9tRWxlbWVudE5vZGUgPSAobm9kZSwgbWFwcGluZykgPT4ge1xuICBjb25zdCB0eXBlID0gbmV3IFkuWG1sRWxlbWVudChub2RlLnR5cGUubmFtZSlcbiAgZm9yIChjb25zdCBrZXkgaW4gbm9kZS5hdHRycykge1xuICAgIGNvbnN0IHZhbCA9IG5vZGUuYXR0cnNba2V5XVxuICAgIGlmICh2YWwgIT09IG51bGwgJiYga2V5ICE9PSAneWNoYW5nZScpIHtcbiAgICAgIHR5cGUuc2V0QXR0cmlidXRlKGtleSwgdmFsKVxuICAgIH1cbiAgfVxuICB0eXBlLmluc2VydChcbiAgICAwLFxuICAgIG5vcm1hbGl6ZVBOb2RlQ29udGVudChub2RlKS5tYXAoKG4pID0+XG4gICAgICBjcmVhdGVUeXBlRnJvbVRleHRPckVsZW1lbnROb2RlKG4sIG1hcHBpbmcpXG4gICAgKVxuICApXG4gIG1hcHBpbmcuc2V0KHR5cGUsIG5vZGUpXG4gIHJldHVybiB0eXBlXG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UE1vZGVsLk5vZGV8QXJyYXk8UE1vZGVsLk5vZGU+fSBub2RlIHByb3NlbWlycm9yIHRleHQgbm9kZVxuICogQHBhcmFtIHtQcm9zZW1pcnJvck1hcHBpbmd9IG1hcHBpbmdcbiAqIEByZXR1cm4ge1kuWG1sRWxlbWVudHxZLlhtbFRleHR9XG4gKi9cbmNvbnN0IGNyZWF0ZVR5cGVGcm9tVGV4dE9yRWxlbWVudE5vZGUgPSAobm9kZSwgbWFwcGluZykgPT5cbiAgbm9kZSBpbnN0YW5jZW9mIEFycmF5XG4gICAgPyBjcmVhdGVUeXBlRnJvbVRleHROb2Rlcyhub2RlLCBtYXBwaW5nKVxuICAgIDogY3JlYXRlVHlwZUZyb21FbGVtZW50Tm9kZShub2RlLCBtYXBwaW5nKVxuXG5jb25zdCBpc09iamVjdCA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbFxuXG5jb25zdCBlcXVhbEF0dHJzID0gKHBhdHRycywgeWF0dHJzKSA9PiB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwYXR0cnMpLmZpbHRlcigoa2V5KSA9PiBwYXR0cnNba2V5XSAhPT0gbnVsbClcbiAgbGV0IGVxID1cbiAgICBrZXlzLmxlbmd0aCA9PT1cbiAgICAgIE9iamVjdC5rZXlzKHlhdHRycykuZmlsdGVyKChrZXkpID0+IHlhdHRyc1trZXldICE9PSBudWxsKS5sZW5ndGhcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aCAmJiBlcTsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0ga2V5c1tpXVxuICAgIGNvbnN0IGwgPSBwYXR0cnNba2V5XVxuICAgIGNvbnN0IHIgPSB5YXR0cnNba2V5XVxuICAgIGVxID0ga2V5ID09PSAneWNoYW5nZScgfHwgbCA9PT0gciB8fFxuICAgICAgKGlzT2JqZWN0KGwpICYmIGlzT2JqZWN0KHIpICYmIGVxdWFsQXR0cnMobCwgcikpXG4gIH1cbiAgcmV0dXJuIGVxXG59XG5cbi8qKlxuICogQHR5cGVkZWYge0FycmF5PEFycmF5PFBNb2RlbC5Ob2RlPnxQTW9kZWwuTm9kZT59IE5vcm1hbGl6ZWRQTm9kZUNvbnRlbnRcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBwbm9kZVxuICogQHJldHVybiB7Tm9ybWFsaXplZFBOb2RlQ29udGVudH1cbiAqL1xuY29uc3Qgbm9ybWFsaXplUE5vZGVDb250ZW50ID0gKHBub2RlKSA9PiB7XG4gIGNvbnN0IGMgPSBwbm9kZS5jb250ZW50LmNvbnRlbnRcbiAgY29uc3QgcmVzID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbiA9IGNbaV1cbiAgICBpZiAobi5pc1RleHQpIHtcbiAgICAgIGNvbnN0IHRleHROb2RlcyA9IFtdXG4gICAgICBmb3IgKGxldCB0bm9kZSA9IGNbaV07IGkgPCBjLmxlbmd0aCAmJiB0bm9kZS5pc1RleHQ7IHRub2RlID0gY1srK2ldKSB7XG4gICAgICAgIHRleHROb2Rlcy5wdXNoKHRub2RlKVxuICAgICAgfVxuICAgICAgaS0tXG4gICAgICByZXMucHVzaCh0ZXh0Tm9kZXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcy5wdXNoKG4pXG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1kuWG1sVGV4dH0geXRleHRcbiAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gcHRleHRzXG4gKi9cbmNvbnN0IGVxdWFsWVRleHRQVGV4dCA9ICh5dGV4dCwgcHRleHRzKSA9PiB7XG4gIGNvbnN0IGRlbHRhID0geXRleHQudG9EZWx0YSgpXG4gIHJldHVybiBkZWx0YS5sZW5ndGggPT09IHB0ZXh0cy5sZW5ndGggJiZcbiAgICBkZWx0YS5ldmVyeSgoZCwgaSkgPT5cbiAgICAgIGQuaW5zZXJ0ID09PSAvKiogQHR5cGUge2FueX0gKi8gKHB0ZXh0c1tpXSkudGV4dCAmJlxuICAgICAgb2JqZWN0LmtleXMoZC5hdHRyaWJ1dGVzIHx8IHt9KS5sZW5ndGggPT09IHB0ZXh0c1tpXS5tYXJrcy5sZW5ndGggJiZcbiAgICAgIHB0ZXh0c1tpXS5tYXJrcy5ldmVyeSgobWFyaykgPT5cbiAgICAgICAgZXF1YWxBdHRycyhkLmF0dHJpYnV0ZXNbbWFyay50eXBlLm5hbWVdIHx8IHt9LCBtYXJrLmF0dHJzKVxuICAgICAgKVxuICAgIClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1kuWG1sRWxlbWVudHxZLlhtbFRleHR8WS5YbWxIb29rfSB5dHlwZVxuICogQHBhcmFtIHthbnl8QXJyYXk8YW55Pn0gcG5vZGVcbiAqL1xuY29uc3QgZXF1YWxZVHlwZVBOb2RlID0gKHl0eXBlLCBwbm9kZSkgPT4ge1xuICBpZiAoXG4gICAgeXR5cGUgaW5zdGFuY2VvZiBZLlhtbEVsZW1lbnQgJiYgIShwbm9kZSBpbnN0YW5jZW9mIEFycmF5KSAmJlxuICAgIG1hdGNoTm9kZU5hbWUoeXR5cGUsIHBub2RlKVxuICApIHtcbiAgICBjb25zdCBub3JtYWxpemVkQ29udGVudCA9IG5vcm1hbGl6ZVBOb2RlQ29udGVudChwbm9kZSlcbiAgICByZXR1cm4geXR5cGUuX2xlbmd0aCA9PT0gbm9ybWFsaXplZENvbnRlbnQubGVuZ3RoICYmXG4gICAgICBlcXVhbEF0dHJzKHl0eXBlLmdldEF0dHJpYnV0ZXMoKSwgcG5vZGUuYXR0cnMpICYmXG4gICAgICB5dHlwZS50b0FycmF5KCkuZXZlcnkoKHljaGlsZCwgaSkgPT5cbiAgICAgICAgZXF1YWxZVHlwZVBOb2RlKHljaGlsZCwgbm9ybWFsaXplZENvbnRlbnRbaV0pXG4gICAgICApXG4gIH1cbiAgcmV0dXJuIHl0eXBlIGluc3RhbmNlb2YgWS5YbWxUZXh0ICYmIHBub2RlIGluc3RhbmNlb2YgQXJyYXkgJiZcbiAgICBlcXVhbFlUZXh0UFRleHQoeXR5cGUsIHBub2RlKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UE1vZGVsLk5vZGUgfCBBcnJheTxQTW9kZWwuTm9kZT4gfCB1bmRlZmluZWR9IG1hcHBlZFxuICogQHBhcmFtIHtQTW9kZWwuTm9kZSB8IEFycmF5PFBNb2RlbC5Ob2RlPn0gcGNvbnRlbnRcbiAqL1xuY29uc3QgbWFwcGVkSWRlbnRpdHkgPSAobWFwcGVkLCBwY29udGVudCkgPT5cbiAgbWFwcGVkID09PSBwY29udGVudCB8fFxuICAobWFwcGVkIGluc3RhbmNlb2YgQXJyYXkgJiYgcGNvbnRlbnQgaW5zdGFuY2VvZiBBcnJheSAmJlxuICAgIG1hcHBlZC5sZW5ndGggPT09IHBjb250ZW50Lmxlbmd0aCAmJiBtYXBwZWQuZXZlcnkoKGEsIGkpID0+XG4gICAgcGNvbnRlbnRbaV0gPT09IGFcbiAgKSlcblxuLyoqXG4gKiBAcGFyYW0ge1kuWG1sRWxlbWVudH0geXR5cGVcbiAqIEBwYXJhbSB7UE1vZGVsLk5vZGV9IHBub2RlXG4gKiBAcGFyYW0ge1Byb3NlbWlycm9yTWFwcGluZ30gbWFwcGluZ1xuICogQHJldHVybiB7eyBmb3VuZE1hcHBlZENoaWxkOiBib29sZWFuLCBlcXVhbGl0eUZhY3RvcjogbnVtYmVyIH19XG4gKi9cbmNvbnN0IGNvbXB1dGVDaGlsZEVxdWFsaXR5RmFjdG9yID0gKHl0eXBlLCBwbm9kZSwgbWFwcGluZykgPT4ge1xuICBjb25zdCB5Q2hpbGRyZW4gPSB5dHlwZS50b0FycmF5KClcbiAgY29uc3QgcENoaWxkcmVuID0gbm9ybWFsaXplUE5vZGVDb250ZW50KHBub2RlKVxuICBjb25zdCBwQ2hpbGRDbnQgPSBwQ2hpbGRyZW4ubGVuZ3RoXG4gIGNvbnN0IHlDaGlsZENudCA9IHlDaGlsZHJlbi5sZW5ndGhcbiAgY29uc3QgbWluQ250ID0gbWF0aC5taW4oeUNoaWxkQ250LCBwQ2hpbGRDbnQpXG4gIGxldCBsZWZ0ID0gMFxuICBsZXQgcmlnaHQgPSAwXG4gIGxldCBmb3VuZE1hcHBlZENoaWxkID0gZmFsc2VcbiAgZm9yICg7IGxlZnQgPCBtaW5DbnQ7IGxlZnQrKykge1xuICAgIGNvbnN0IGxlZnRZID0geUNoaWxkcmVuW2xlZnRdXG4gICAgY29uc3QgbGVmdFAgPSBwQ2hpbGRyZW5bbGVmdF1cbiAgICBpZiAobWFwcGVkSWRlbnRpdHkobWFwcGluZy5nZXQobGVmdFkpLCBsZWZ0UCkpIHtcbiAgICAgIGZvdW5kTWFwcGVkQ2hpbGQgPSB0cnVlIC8vIGRlZmluaXRlIChnb29kKSBtYXRjaCFcbiAgICB9IGVsc2UgaWYgKCFlcXVhbFlUeXBlUE5vZGUobGVmdFksIGxlZnRQKSkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgZm9yICg7IGxlZnQgKyByaWdodCA8IG1pbkNudDsgcmlnaHQrKykge1xuICAgIGNvbnN0IHJpZ2h0WSA9IHlDaGlsZHJlblt5Q2hpbGRDbnQgLSByaWdodCAtIDFdXG4gICAgY29uc3QgcmlnaHRQID0gcENoaWxkcmVuW3BDaGlsZENudCAtIHJpZ2h0IC0gMV1cbiAgICBpZiAobWFwcGVkSWRlbnRpdHkobWFwcGluZy5nZXQocmlnaHRZKSwgcmlnaHRQKSkge1xuICAgICAgZm91bmRNYXBwZWRDaGlsZCA9IHRydWVcbiAgICB9IGVsc2UgaWYgKCFlcXVhbFlUeXBlUE5vZGUocmlnaHRZLCByaWdodFApKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGVxdWFsaXR5RmFjdG9yOiBsZWZ0ICsgcmlnaHQsXG4gICAgZm91bmRNYXBwZWRDaGlsZFxuICB9XG59XG5cbmNvbnN0IHl0ZXh0VHJhbnMgPSAoeXRleHQpID0+IHtcbiAgbGV0IHN0ciA9ICcnXG4gIC8qKlxuICAgKiBAdHlwZSB7WS5JdGVtfG51bGx9XG4gICAqL1xuICBsZXQgbiA9IHl0ZXh0Ll9zdGFydFxuICBjb25zdCBuQXR0cnMgPSB7fVxuICB3aGlsZSAobiAhPT0gbnVsbCkge1xuICAgIGlmICghbi5kZWxldGVkKSB7XG4gICAgICBpZiAobi5jb3VudGFibGUgJiYgbi5jb250ZW50IGluc3RhbmNlb2YgWS5Db250ZW50U3RyaW5nKSB7XG4gICAgICAgIHN0ciArPSBuLmNvbnRlbnQuc3RyXG4gICAgICB9IGVsc2UgaWYgKG4uY29udGVudCBpbnN0YW5jZW9mIFkuQ29udGVudEZvcm1hdCkge1xuICAgICAgICBuQXR0cnNbbi5jb250ZW50LmtleV0gPSBudWxsXG4gICAgICB9XG4gICAgfVxuICAgIG4gPSBuLnJpZ2h0XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzdHIsXG4gICAgbkF0dHJzXG4gIH1cbn1cblxuLyoqXG4gKiBAdG9kbyB0ZXN0IHRoaXMgbW9yZVxuICpcbiAqIEBwYXJhbSB7WS5UZXh0fSB5dGV4dFxuICogQHBhcmFtIHtBcnJheTxhbnk+fSBwdGV4dHNcbiAqIEBwYXJhbSB7UHJvc2VtaXJyb3JNYXBwaW5nfSBtYXBwaW5nXG4gKi9cbmNvbnN0IHVwZGF0ZVlUZXh0ID0gKHl0ZXh0LCBwdGV4dHMsIG1hcHBpbmcpID0+IHtcbiAgbWFwcGluZy5zZXQoeXRleHQsIHB0ZXh0cylcbiAgY29uc3QgeyBuQXR0cnMsIHN0ciB9ID0geXRleHRUcmFucyh5dGV4dClcbiAgY29uc3QgY29udGVudCA9IHB0ZXh0cy5tYXAoKHApID0+ICh7XG4gICAgaW5zZXJ0OiAvKiogQHR5cGUge2FueX0gKi8gKHApLnRleHQsXG4gICAgYXR0cmlidXRlczogT2JqZWN0LmFzc2lnbih7fSwgbkF0dHJzLCBtYXJrc1RvQXR0cmlidXRlcyhwLm1hcmtzKSlcbiAgfSkpXG4gIGNvbnN0IHsgaW5zZXJ0LCByZW1vdmUsIGluZGV4IH0gPSBzaW1wbGVEaWZmKFxuICAgIHN0cixcbiAgICBjb250ZW50Lm1hcCgoYykgPT4gYy5pbnNlcnQpLmpvaW4oJycpXG4gIClcbiAgeXRleHQuZGVsZXRlKGluZGV4LCByZW1vdmUpXG4gIHl0ZXh0Lmluc2VydChpbmRleCwgaW5zZXJ0KVxuICB5dGV4dC5hcHBseURlbHRhKFxuICAgIGNvbnRlbnQubWFwKChjKSA9PiAoeyByZXRhaW46IGMuaW5zZXJ0Lmxlbmd0aCwgYXR0cmlidXRlczogYy5hdHRyaWJ1dGVzIH0pKVxuICApXG59XG5cbmNvbnN0IG1hcmtzVG9BdHRyaWJ1dGVzID0gKG1hcmtzKSA9PiB7XG4gIGNvbnN0IHBhdHRycyA9IHt9XG4gIG1hcmtzLmZvckVhY2goKG1hcmspID0+IHtcbiAgICBpZiAobWFyay50eXBlLm5hbWUgIT09ICd5Y2hhbmdlJykge1xuICAgICAgcGF0dHJzW21hcmsudHlwZS5uYW1lXSA9IG1hcmsuYXR0cnNcbiAgICB9XG4gIH0pXG4gIHJldHVybiBwYXR0cnNcbn1cblxuLyoqXG4gKiBVcGRhdGUgYSB5RG9tIG5vZGUgYnkgc3luY2luZyB0aGUgY3VycmVudCBjb250ZW50IG9mIHRoZSBwcm9zZW1pcnJvciBub2RlLlxuICpcbiAqIFRoaXMgaXMgYSB5LXByb3NlbWlycm9yIGludGVybmFsIGZlYXR1cmUgdGhhdCB5b3UgY2FuIHVzZSBhdCB5b3VyIG93biByaXNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAdW5zdGFibGVcbiAqXG4gKiBAcGFyYW0ge3t0cmFuc2FjdDogRnVuY3Rpb259fSB5XG4gKiBAcGFyYW0ge1kuWG1sRnJhZ21lbnR9IHlEb21GcmFnbWVudFxuICogQHBhcmFtIHthbnl9IHBOb2RlXG4gKiBAcGFyYW0ge1Byb3NlbWlycm9yTWFwcGluZ30gbWFwcGluZ1xuICovXG5leHBvcnQgY29uc3QgdXBkYXRlWUZyYWdtZW50ID0gKHksIHlEb21GcmFnbWVudCwgcE5vZGUsIG1hcHBpbmcpID0+IHtcbiAgaWYgKFxuICAgIHlEb21GcmFnbWVudCBpbnN0YW5jZW9mIFkuWG1sRWxlbWVudCAmJlxuICAgIHlEb21GcmFnbWVudC5ub2RlTmFtZSAhPT0gcE5vZGUudHlwZS5uYW1lXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcignbm9kZSBuYW1lIG1pc21hdGNoIScpXG4gIH1cbiAgbWFwcGluZy5zZXQoeURvbUZyYWdtZW50LCBwTm9kZSlcbiAgLy8gdXBkYXRlIGF0dHJpYnV0ZXNcbiAgaWYgKHlEb21GcmFnbWVudCBpbnN0YW5jZW9mIFkuWG1sRWxlbWVudCkge1xuICAgIGNvbnN0IHlEb21BdHRycyA9IHlEb21GcmFnbWVudC5nZXRBdHRyaWJ1dGVzKClcbiAgICBjb25zdCBwQXR0cnMgPSBwTm9kZS5hdHRyc1xuICAgIGZvciAoY29uc3Qga2V5IGluIHBBdHRycykge1xuICAgICAgaWYgKHBBdHRyc1trZXldICE9PSBudWxsKSB7XG4gICAgICAgIGlmICh5RG9tQXR0cnNba2V5XSAhPT0gcEF0dHJzW2tleV0gJiYga2V5ICE9PSAneWNoYW5nZScpIHtcbiAgICAgICAgICB5RG9tRnJhZ21lbnQuc2V0QXR0cmlidXRlKGtleSwgcEF0dHJzW2tleV0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlEb21GcmFnbWVudC5yZW1vdmVBdHRyaWJ1dGUoa2V5KVxuICAgICAgfVxuICAgIH1cbiAgICAvLyByZW1vdmUgYWxsIGtleXMgdGhhdCBhcmUgbm8gbG9uZ2VyIGluIHBBdHRyc1xuICAgIGZvciAoY29uc3Qga2V5IGluIHlEb21BdHRycykge1xuICAgICAgaWYgKHBBdHRyc1trZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgeURvbUZyYWdtZW50LnJlbW92ZUF0dHJpYnV0ZShrZXkpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIHVwZGF0ZSBjaGlsZHJlblxuICBjb25zdCBwQ2hpbGRyZW4gPSBub3JtYWxpemVQTm9kZUNvbnRlbnQocE5vZGUpXG4gIGNvbnN0IHBDaGlsZENudCA9IHBDaGlsZHJlbi5sZW5ndGhcbiAgY29uc3QgeUNoaWxkcmVuID0geURvbUZyYWdtZW50LnRvQXJyYXkoKVxuICBjb25zdCB5Q2hpbGRDbnQgPSB5Q2hpbGRyZW4ubGVuZ3RoXG4gIGNvbnN0IG1pbkNudCA9IG1hdGgubWluKHBDaGlsZENudCwgeUNoaWxkQ250KVxuICBsZXQgbGVmdCA9IDBcbiAgbGV0IHJpZ2h0ID0gMFxuICAvLyBmaW5kIG51bWJlciBvZiBtYXRjaGluZyBlbGVtZW50cyBmcm9tIGxlZnRcbiAgZm9yICg7IGxlZnQgPCBtaW5DbnQ7IGxlZnQrKykge1xuICAgIGNvbnN0IGxlZnRZID0geUNoaWxkcmVuW2xlZnRdXG4gICAgY29uc3QgbGVmdFAgPSBwQ2hpbGRyZW5bbGVmdF1cbiAgICBpZiAoIW1hcHBlZElkZW50aXR5KG1hcHBpbmcuZ2V0KGxlZnRZKSwgbGVmdFApKSB7XG4gICAgICBpZiAoZXF1YWxZVHlwZVBOb2RlKGxlZnRZLCBsZWZ0UCkpIHtcbiAgICAgICAgLy8gdXBkYXRlIG1hcHBpbmdcbiAgICAgICAgbWFwcGluZy5zZXQobGVmdFksIGxlZnRQKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gZmluZCBudW1iZXIgb2YgbWF0Y2hpbmcgZWxlbWVudHMgZnJvbSByaWdodFxuICBmb3IgKDsgcmlnaHQgKyBsZWZ0ICsgMSA8IG1pbkNudDsgcmlnaHQrKykge1xuICAgIGNvbnN0IHJpZ2h0WSA9IHlDaGlsZHJlblt5Q2hpbGRDbnQgLSByaWdodCAtIDFdXG4gICAgY29uc3QgcmlnaHRQID0gcENoaWxkcmVuW3BDaGlsZENudCAtIHJpZ2h0IC0gMV1cbiAgICBpZiAoIW1hcHBlZElkZW50aXR5KG1hcHBpbmcuZ2V0KHJpZ2h0WSksIHJpZ2h0UCkpIHtcbiAgICAgIGlmIChlcXVhbFlUeXBlUE5vZGUocmlnaHRZLCByaWdodFApKSB7XG4gICAgICAgIC8vIHVwZGF0ZSBtYXBwaW5nXG4gICAgICAgIG1hcHBpbmcuc2V0KHJpZ2h0WSwgcmlnaHRQKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgeS50cmFuc2FjdCgoKSA9PiB7XG4gICAgLy8gdHJ5IHRvIGNvbXBhcmUgYW5kIHVwZGF0ZVxuICAgIHdoaWxlICh5Q2hpbGRDbnQgLSBsZWZ0IC0gcmlnaHQgPiAwICYmIHBDaGlsZENudCAtIGxlZnQgLSByaWdodCA+IDApIHtcbiAgICAgIGNvbnN0IGxlZnRZID0geUNoaWxkcmVuW2xlZnRdXG4gICAgICBjb25zdCBsZWZ0UCA9IHBDaGlsZHJlbltsZWZ0XVxuICAgICAgY29uc3QgcmlnaHRZID0geUNoaWxkcmVuW3lDaGlsZENudCAtIHJpZ2h0IC0gMV1cbiAgICAgIGNvbnN0IHJpZ2h0UCA9IHBDaGlsZHJlbltwQ2hpbGRDbnQgLSByaWdodCAtIDFdXG4gICAgICBpZiAobGVmdFkgaW5zdGFuY2VvZiBZLlhtbFRleHQgJiYgbGVmdFAgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBpZiAoIWVxdWFsWVRleHRQVGV4dChsZWZ0WSwgbGVmdFApKSB7XG4gICAgICAgICAgdXBkYXRlWVRleHQobGVmdFksIGxlZnRQLCBtYXBwaW5nKVxuICAgICAgICB9XG4gICAgICAgIGxlZnQgKz0gMVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHVwZGF0ZUxlZnQgPSBsZWZ0WSBpbnN0YW5jZW9mIFkuWG1sRWxlbWVudCAmJlxuICAgICAgICAgIG1hdGNoTm9kZU5hbWUobGVmdFksIGxlZnRQKVxuICAgICAgICBsZXQgdXBkYXRlUmlnaHQgPSByaWdodFkgaW5zdGFuY2VvZiBZLlhtbEVsZW1lbnQgJiZcbiAgICAgICAgICBtYXRjaE5vZGVOYW1lKHJpZ2h0WSwgcmlnaHRQKVxuICAgICAgICBpZiAodXBkYXRlTGVmdCAmJiB1cGRhdGVSaWdodCkge1xuICAgICAgICAgIC8vIGRlY2lkZSB3aGljaCB3aGljaCBlbGVtZW50IHRvIHVwZGF0ZVxuICAgICAgICAgIGNvbnN0IGVxdWFsaXR5TGVmdCA9IGNvbXB1dGVDaGlsZEVxdWFsaXR5RmFjdG9yKFxuICAgICAgICAgICAgLyoqIEB0eXBlIHtZLlhtbEVsZW1lbnR9ICovIChsZWZ0WSksXG4gICAgICAgICAgICAvKiogQHR5cGUge1BNb2RlbC5Ob2RlfSAqLyAobGVmdFApLFxuICAgICAgICAgICAgbWFwcGluZ1xuICAgICAgICAgIClcbiAgICAgICAgICBjb25zdCBlcXVhbGl0eVJpZ2h0ID0gY29tcHV0ZUNoaWxkRXF1YWxpdHlGYWN0b3IoXG4gICAgICAgICAgICAvKiogQHR5cGUge1kuWG1sRWxlbWVudH0gKi8gKHJpZ2h0WSksXG4gICAgICAgICAgICAvKiogQHR5cGUge1BNb2RlbC5Ob2RlfSAqLyAocmlnaHRQKSxcbiAgICAgICAgICAgIG1hcHBpbmdcbiAgICAgICAgICApXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgZXF1YWxpdHlMZWZ0LmZvdW5kTWFwcGVkQ2hpbGQgJiYgIWVxdWFsaXR5UmlnaHQuZm91bmRNYXBwZWRDaGlsZFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdXBkYXRlUmlnaHQgPSBmYWxzZVxuICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAhZXF1YWxpdHlMZWZ0LmZvdW5kTWFwcGVkQ2hpbGQgJiYgZXF1YWxpdHlSaWdodC5mb3VuZE1hcHBlZENoaWxkXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB1cGRhdGVMZWZ0ID0gZmFsc2VcbiAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgZXF1YWxpdHlMZWZ0LmVxdWFsaXR5RmFjdG9yIDwgZXF1YWxpdHlSaWdodC5lcXVhbGl0eUZhY3RvclxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdXBkYXRlTGVmdCA9IGZhbHNlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVwZGF0ZVJpZ2h0ID0gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZUxlZnQpIHtcbiAgICAgICAgICB1cGRhdGVZRnJhZ21lbnQoXG4gICAgICAgICAgICB5LFxuICAgICAgICAgICAgLyoqIEB0eXBlIHtZLlhtbEZyYWdtZW50fSAqLyAobGVmdFkpLFxuICAgICAgICAgICAgLyoqIEB0eXBlIHtQTW9kZWwuTm9kZX0gKi8gKGxlZnRQKSxcbiAgICAgICAgICAgIG1hcHBpbmdcbiAgICAgICAgICApXG4gICAgICAgICAgbGVmdCArPSAxXG4gICAgICAgIH0gZWxzZSBpZiAodXBkYXRlUmlnaHQpIHtcbiAgICAgICAgICB1cGRhdGVZRnJhZ21lbnQoXG4gICAgICAgICAgICB5LFxuICAgICAgICAgICAgLyoqIEB0eXBlIHtZLlhtbEZyYWdtZW50fSAqLyAocmlnaHRZKSxcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7UE1vZGVsLk5vZGV9ICovIChyaWdodFApLFxuICAgICAgICAgICAgbWFwcGluZ1xuICAgICAgICAgIClcbiAgICAgICAgICByaWdodCArPSAxXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWFwcGluZy5kZWxldGUoeURvbUZyYWdtZW50LmdldChsZWZ0KSlcbiAgICAgICAgICB5RG9tRnJhZ21lbnQuZGVsZXRlKGxlZnQsIDEpXG4gICAgICAgICAgeURvbUZyYWdtZW50Lmluc2VydChsZWZ0LCBbXG4gICAgICAgICAgICBjcmVhdGVUeXBlRnJvbVRleHRPckVsZW1lbnROb2RlKGxlZnRQLCBtYXBwaW5nKVxuICAgICAgICAgIF0pXG4gICAgICAgICAgbGVmdCArPSAxXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgeURlbExlbiA9IHlDaGlsZENudCAtIGxlZnQgLSByaWdodFxuICAgIGlmIChcbiAgICAgIHlDaGlsZENudCA9PT0gMSAmJiBwQ2hpbGRDbnQgPT09IDAgJiYgeUNoaWxkcmVuWzBdIGluc3RhbmNlb2YgWS5YbWxUZXh0XG4gICAgKSB7XG4gICAgICBtYXBwaW5nLmRlbGV0ZSh5Q2hpbGRyZW5bMF0pXG4gICAgICAvLyBFZGdlIGNhc2UgaGFuZGxpbmcgaHR0cHM6Ly9naXRodWIuY29tL3lqcy95LXByb3NlbWlycm9yL2lzc3Vlcy8xMDhcbiAgICAgIC8vIE9ubHkgZGVsZXRlIHRoZSBjb250ZW50IG9mIHRoZSBZLlRleHQgdG8gcmV0YWluIHJlbW90ZSBjaGFuZ2VzIG9uIHRoZSBzYW1lIFkuVGV4dCBvYmplY3RcbiAgICAgIHlDaGlsZHJlblswXS5kZWxldGUoMCwgeUNoaWxkcmVuWzBdLmxlbmd0aClcbiAgICB9IGVsc2UgaWYgKHlEZWxMZW4gPiAwKSB7XG4gICAgICB5RG9tRnJhZ21lbnQuc2xpY2UobGVmdCwgbGVmdCArIHlEZWxMZW4pLmZvckVhY2godHlwZSA9PiBtYXBwaW5nLmRlbGV0ZSh0eXBlKSlcbiAgICAgIHlEb21GcmFnbWVudC5kZWxldGUobGVmdCwgeURlbExlbilcbiAgICB9XG4gICAgaWYgKGxlZnQgKyByaWdodCA8IHBDaGlsZENudCkge1xuICAgICAgY29uc3QgaW5zID0gW11cbiAgICAgIGZvciAobGV0IGkgPSBsZWZ0OyBpIDwgcENoaWxkQ250IC0gcmlnaHQ7IGkrKykge1xuICAgICAgICBpbnMucHVzaChjcmVhdGVUeXBlRnJvbVRleHRPckVsZW1lbnROb2RlKHBDaGlsZHJlbltpXSwgbWFwcGluZykpXG4gICAgICB9XG4gICAgICB5RG9tRnJhZ21lbnQuaW5zZXJ0KGxlZnQsIGlucylcbiAgICB9XG4gIH0sIHlTeW5jUGx1Z2luS2V5KVxufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtZLlhtbEVsZW1lbnR9IHlFbGVtZW50XG4gKiBAcGFyYW0ge2FueX0gcE5vZGUgUHJvc2VtaXJyb3IgTm9kZVxuICovXG5jb25zdCBtYXRjaE5vZGVOYW1lID0gKHlFbGVtZW50LCBwTm9kZSkgPT5cbiAgIShwTm9kZSBpbnN0YW5jZW9mIEFycmF5KSAmJiB5RWxlbWVudC5ub2RlTmFtZSA9PT0gcE5vZGUudHlwZS5uYW1lXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/y-prosemirror/src/plugins/sync-plugin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/y-prosemirror/src/plugins/undo-plugin.js":
/*!***************************************************************!*\
  !*** ./node_modules/y-prosemirror/src/plugins/undo-plugin.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultDeleteFilter: () => (/* binding */ defaultDeleteFilter),\n/* harmony export */   defaultProtectedNodes: () => (/* binding */ defaultProtectedNodes),\n/* harmony export */   redo: () => (/* binding */ redo),\n/* harmony export */   undo: () => (/* binding */ undo),\n/* harmony export */   yUndoPlugin: () => (/* binding */ yUndoPlugin)\n/* harmony export */ });\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var _sync_plugin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./sync-plugin.js */ \"(ssr)/./node_modules/y-prosemirror/src/plugins/sync-plugin.js\");\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! yjs */ \"(ssr)/./node_modules/yjs/dist/yjs.mjs\");\n/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./keys.js */ \"(ssr)/./node_modules/y-prosemirror/src/plugins/keys.js\");\n // eslint-disable-line\n\n\n\n\n\nconst undo = state => {\n  const undoManager = _keys_js__WEBPACK_IMPORTED_MODULE_0__.yUndoPluginKey.getState(state).undoManager\n  if (undoManager != null) {\n    undoManager.undo()\n    return true\n  }\n}\n\nconst redo = state => {\n  const undoManager = _keys_js__WEBPACK_IMPORTED_MODULE_0__.yUndoPluginKey.getState(state).undoManager\n  if (undoManager != null) {\n    undoManager.redo()\n    return true\n  }\n}\n\nconst defaultProtectedNodes = new Set(['paragraph'])\n\nconst defaultDeleteFilter = (item, protectedNodes) => !(item instanceof yjs__WEBPACK_IMPORTED_MODULE_1__.Item) ||\n!(item.content instanceof yjs__WEBPACK_IMPORTED_MODULE_1__.ContentType) ||\n!(item.content.type instanceof yjs__WEBPACK_IMPORTED_MODULE_1__.Text ||\n  (item.content.type instanceof yjs__WEBPACK_IMPORTED_MODULE_1__.XmlElement && protectedNodes.has(item.content.type.nodeName))) ||\nitem.content.type._length === 0\n\nconst yUndoPlugin = ({ protectedNodes = defaultProtectedNodes, trackedOrigins = [], undoManager = null } = {}) => new prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.Plugin({\n  key: _keys_js__WEBPACK_IMPORTED_MODULE_0__.yUndoPluginKey,\n  state: {\n    init: (initargs, state) => {\n      // TODO: check if plugin order matches and fix\n      const ystate = _keys_js__WEBPACK_IMPORTED_MODULE_0__.ySyncPluginKey.getState(state)\n      const _undoManager = undoManager || new yjs__WEBPACK_IMPORTED_MODULE_1__.UndoManager(ystate.type, {\n        trackedOrigins: new Set([_keys_js__WEBPACK_IMPORTED_MODULE_0__.ySyncPluginKey].concat(trackedOrigins)),\n        deleteFilter: (item) => defaultDeleteFilter(item, protectedNodes),\n        captureTransaction: tr => tr.meta.get('addToHistory') !== false\n      })\n      return {\n        undoManager: _undoManager,\n        prevSel: null,\n        hasUndoOps: _undoManager.undoStack.length > 0,\n        hasRedoOps: _undoManager.redoStack.length > 0\n      }\n    },\n    /**\n     * @returns {any}\n     */\n    apply: (tr, val, oldState, state) => {\n      const binding = _keys_js__WEBPACK_IMPORTED_MODULE_0__.ySyncPluginKey.getState(state).binding\n      const undoManager = val.undoManager\n      const hasUndoOps = undoManager.undoStack.length > 0\n      const hasRedoOps = undoManager.redoStack.length > 0\n      if (binding) {\n        return {\n          undoManager,\n          prevSel: (0,_sync_plugin_js__WEBPACK_IMPORTED_MODULE_3__.getRelativeSelection)(binding, oldState),\n          hasUndoOps,\n          hasRedoOps\n        }\n      } else {\n        if (hasUndoOps !== val.hasUndoOps || hasRedoOps !== val.hasRedoOps) {\n          return Object.assign({}, val, {\n            hasUndoOps: undoManager.undoStack.length > 0,\n            hasRedoOps: undoManager.redoStack.length > 0\n          })\n        } else { // nothing changed\n          return val\n        }\n      }\n    }\n  },\n  view: view => {\n    const ystate = _keys_js__WEBPACK_IMPORTED_MODULE_0__.ySyncPluginKey.getState(view.state)\n    const undoManager = _keys_js__WEBPACK_IMPORTED_MODULE_0__.yUndoPluginKey.getState(view.state).undoManager\n    undoManager.on('stack-item-added', ({ stackItem }) => {\n      const binding = ystate.binding\n      if (binding) {\n        stackItem.meta.set(binding, _keys_js__WEBPACK_IMPORTED_MODULE_0__.yUndoPluginKey.getState(view.state).prevSel)\n      }\n    })\n    undoManager.on('stack-item-popped', ({ stackItem }) => {\n      const binding = ystate.binding\n      if (binding) {\n        binding.beforeTransactionSelection = stackItem.meta.get(binding) || binding.beforeTransactionSelection\n      }\n    })\n    return {\n      destroy: () => {\n        undoManager.destroy()\n      }\n    }\n  }\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveS1wcm9zZW1pcnJvci9zcmMvcGx1Z2lucy91bmRvLXBsdWdpbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBMEM7O0FBRWE7QUFDZTtBQUNaOztBQUVuRDtBQUNQLHNCQUFzQixvREFBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1Asc0JBQXNCLG9EQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87O0FBRUEsd0VBQXdFLHFDQUFJO0FBQ25GLDBCQUEwQiw0Q0FBVztBQUNyQywrQkFBK0IscUNBQUk7QUFDbkMsZ0NBQWdDLDJDQUFVO0FBQzFDOztBQUVPLHVCQUF1QixrRkFBa0YsSUFBSSxTQUFTLHFEQUFNO0FBQ25JLE9BQU8sb0RBQWM7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9EQUFjO0FBQ25DLDhDQUE4Qyw0Q0FBVztBQUN6RCxpQ0FBaUMsb0RBQWM7QUFDL0M7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHNCQUFzQixvREFBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUVBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLG1CQUFtQixvREFBYztBQUNqQyx3QkFBd0Isb0RBQWM7QUFDdEMsMENBQTBDLFdBQVc7QUFDckQ7QUFDQTtBQUNBLG9DQUFvQyxvREFBYztBQUNsRDtBQUNBLEtBQUs7QUFDTCwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vMjhfbm90aW9uLWNsb25lLy4vbm9kZV9tb2R1bGVzL3ktcHJvc2VtaXJyb3Ivc3JjL3BsdWdpbnMvdW5kby1wbHVnaW4uanM/NWM3YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQbHVnaW4gfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZScgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG5pbXBvcnQgeyBnZXRSZWxhdGl2ZVNlbGVjdGlvbiB9IGZyb20gJy4vc3luYy1wbHVnaW4uanMnXG5pbXBvcnQgeyBVbmRvTWFuYWdlciwgSXRlbSwgQ29udGVudFR5cGUsIFhtbEVsZW1lbnQsIFRleHQgfSBmcm9tICd5anMnXG5pbXBvcnQgeyB5VW5kb1BsdWdpbktleSwgeVN5bmNQbHVnaW5LZXkgfSBmcm9tICcuL2tleXMuanMnXG5cbmV4cG9ydCBjb25zdCB1bmRvID0gc3RhdGUgPT4ge1xuICBjb25zdCB1bmRvTWFuYWdlciA9IHlVbmRvUGx1Z2luS2V5LmdldFN0YXRlKHN0YXRlKS51bmRvTWFuYWdlclxuICBpZiAodW5kb01hbmFnZXIgIT0gbnVsbCkge1xuICAgIHVuZG9NYW5hZ2VyLnVuZG8oKVxuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHJlZG8gPSBzdGF0ZSA9PiB7XG4gIGNvbnN0IHVuZG9NYW5hZ2VyID0geVVuZG9QbHVnaW5LZXkuZ2V0U3RhdGUoc3RhdGUpLnVuZG9NYW5hZ2VyXG4gIGlmICh1bmRvTWFuYWdlciAhPSBudWxsKSB7XG4gICAgdW5kb01hbmFnZXIucmVkbygpXG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZGVmYXVsdFByb3RlY3RlZE5vZGVzID0gbmV3IFNldChbJ3BhcmFncmFwaCddKVxuXG5leHBvcnQgY29uc3QgZGVmYXVsdERlbGV0ZUZpbHRlciA9IChpdGVtLCBwcm90ZWN0ZWROb2RlcykgPT4gIShpdGVtIGluc3RhbmNlb2YgSXRlbSkgfHxcbiEoaXRlbS5jb250ZW50IGluc3RhbmNlb2YgQ29udGVudFR5cGUpIHx8XG4hKGl0ZW0uY29udGVudC50eXBlIGluc3RhbmNlb2YgVGV4dCB8fFxuICAoaXRlbS5jb250ZW50LnR5cGUgaW5zdGFuY2VvZiBYbWxFbGVtZW50ICYmIHByb3RlY3RlZE5vZGVzLmhhcyhpdGVtLmNvbnRlbnQudHlwZS5ub2RlTmFtZSkpKSB8fFxuaXRlbS5jb250ZW50LnR5cGUuX2xlbmd0aCA9PT0gMFxuXG5leHBvcnQgY29uc3QgeVVuZG9QbHVnaW4gPSAoeyBwcm90ZWN0ZWROb2RlcyA9IGRlZmF1bHRQcm90ZWN0ZWROb2RlcywgdHJhY2tlZE9yaWdpbnMgPSBbXSwgdW5kb01hbmFnZXIgPSBudWxsIH0gPSB7fSkgPT4gbmV3IFBsdWdpbih7XG4gIGtleTogeVVuZG9QbHVnaW5LZXksXG4gIHN0YXRlOiB7XG4gICAgaW5pdDogKGluaXRhcmdzLCBzdGF0ZSkgPT4ge1xuICAgICAgLy8gVE9ETzogY2hlY2sgaWYgcGx1Z2luIG9yZGVyIG1hdGNoZXMgYW5kIGZpeFxuICAgICAgY29uc3QgeXN0YXRlID0geVN5bmNQbHVnaW5LZXkuZ2V0U3RhdGUoc3RhdGUpXG4gICAgICBjb25zdCBfdW5kb01hbmFnZXIgPSB1bmRvTWFuYWdlciB8fCBuZXcgVW5kb01hbmFnZXIoeXN0YXRlLnR5cGUsIHtcbiAgICAgICAgdHJhY2tlZE9yaWdpbnM6IG5ldyBTZXQoW3lTeW5jUGx1Z2luS2V5XS5jb25jYXQodHJhY2tlZE9yaWdpbnMpKSxcbiAgICAgICAgZGVsZXRlRmlsdGVyOiAoaXRlbSkgPT4gZGVmYXVsdERlbGV0ZUZpbHRlcihpdGVtLCBwcm90ZWN0ZWROb2RlcyksXG4gICAgICAgIGNhcHR1cmVUcmFuc2FjdGlvbjogdHIgPT4gdHIubWV0YS5nZXQoJ2FkZFRvSGlzdG9yeScpICE9PSBmYWxzZVxuICAgICAgfSlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVuZG9NYW5hZ2VyOiBfdW5kb01hbmFnZXIsXG4gICAgICAgIHByZXZTZWw6IG51bGwsXG4gICAgICAgIGhhc1VuZG9PcHM6IF91bmRvTWFuYWdlci51bmRvU3RhY2subGVuZ3RoID4gMCxcbiAgICAgICAgaGFzUmVkb09wczogX3VuZG9NYW5hZ2VyLnJlZG9TdGFjay5sZW5ndGggPiAwXG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7YW55fVxuICAgICAqL1xuICAgIGFwcGx5OiAodHIsIHZhbCwgb2xkU3RhdGUsIHN0YXRlKSA9PiB7XG4gICAgICBjb25zdCBiaW5kaW5nID0geVN5bmNQbHVnaW5LZXkuZ2V0U3RhdGUoc3RhdGUpLmJpbmRpbmdcbiAgICAgIGNvbnN0IHVuZG9NYW5hZ2VyID0gdmFsLnVuZG9NYW5hZ2VyXG4gICAgICBjb25zdCBoYXNVbmRvT3BzID0gdW5kb01hbmFnZXIudW5kb1N0YWNrLmxlbmd0aCA+IDBcbiAgICAgIGNvbnN0IGhhc1JlZG9PcHMgPSB1bmRvTWFuYWdlci5yZWRvU3RhY2subGVuZ3RoID4gMFxuICAgICAgaWYgKGJpbmRpbmcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB1bmRvTWFuYWdlcixcbiAgICAgICAgICBwcmV2U2VsOiBnZXRSZWxhdGl2ZVNlbGVjdGlvbihiaW5kaW5nLCBvbGRTdGF0ZSksXG4gICAgICAgICAgaGFzVW5kb09wcyxcbiAgICAgICAgICBoYXNSZWRvT3BzXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChoYXNVbmRvT3BzICE9PSB2YWwuaGFzVW5kb09wcyB8fCBoYXNSZWRvT3BzICE9PSB2YWwuaGFzUmVkb09wcykge1xuICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB2YWwsIHtcbiAgICAgICAgICAgIGhhc1VuZG9PcHM6IHVuZG9NYW5hZ2VyLnVuZG9TdGFjay5sZW5ndGggPiAwLFxuICAgICAgICAgICAgaGFzUmVkb09wczogdW5kb01hbmFnZXIucmVkb1N0YWNrLmxlbmd0aCA+IDBcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2UgeyAvLyBub3RoaW5nIGNoYW5nZWRcbiAgICAgICAgICByZXR1cm4gdmFsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHZpZXc6IHZpZXcgPT4ge1xuICAgIGNvbnN0IHlzdGF0ZSA9IHlTeW5jUGx1Z2luS2V5LmdldFN0YXRlKHZpZXcuc3RhdGUpXG4gICAgY29uc3QgdW5kb01hbmFnZXIgPSB5VW5kb1BsdWdpbktleS5nZXRTdGF0ZSh2aWV3LnN0YXRlKS51bmRvTWFuYWdlclxuICAgIHVuZG9NYW5hZ2VyLm9uKCdzdGFjay1pdGVtLWFkZGVkJywgKHsgc3RhY2tJdGVtIH0pID0+IHtcbiAgICAgIGNvbnN0IGJpbmRpbmcgPSB5c3RhdGUuYmluZGluZ1xuICAgICAgaWYgKGJpbmRpbmcpIHtcbiAgICAgICAgc3RhY2tJdGVtLm1ldGEuc2V0KGJpbmRpbmcsIHlVbmRvUGx1Z2luS2V5LmdldFN0YXRlKHZpZXcuc3RhdGUpLnByZXZTZWwpXG4gICAgICB9XG4gICAgfSlcbiAgICB1bmRvTWFuYWdlci5vbignc3RhY2staXRlbS1wb3BwZWQnLCAoeyBzdGFja0l0ZW0gfSkgPT4ge1xuICAgICAgY29uc3QgYmluZGluZyA9IHlzdGF0ZS5iaW5kaW5nXG4gICAgICBpZiAoYmluZGluZykge1xuICAgICAgICBiaW5kaW5nLmJlZm9yZVRyYW5zYWN0aW9uU2VsZWN0aW9uID0gc3RhY2tJdGVtLm1ldGEuZ2V0KGJpbmRpbmcpIHx8IGJpbmRpbmcuYmVmb3JlVHJhbnNhY3Rpb25TZWxlY3Rpb25cbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiB7XG4gICAgICBkZXN0cm95OiAoKSA9PiB7XG4gICAgICAgIHVuZG9NYW5hZ2VyLmRlc3Ryb3koKVxuICAgICAgfVxuICAgIH1cbiAgfVxufSlcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/y-prosemirror/src/plugins/undo-plugin.js\n");

/***/ })

};
;