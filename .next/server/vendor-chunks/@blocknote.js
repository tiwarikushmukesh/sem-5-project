"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@blocknote";
exports.ids = ["vendor-chunks/@blocknote"];
exports.modules = {

/***/ "(ssr)/./node_modules/@blocknote/core/dist/style.css":
/*!*****************************************************!*\
  !*** ./node_modules/@blocknote/core/dist/style.css ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"2370f620b6c5\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJsb2Nrbm90ZS9jb3JlL2Rpc3Qvc3R5bGUuY3NzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxjQUFjO0FBQzdCLElBQUksS0FBVSxFQUFFLEVBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vMjhfbm90aW9uLWNsb25lLy4vbm9kZV9tb2R1bGVzL0BibG9ja25vdGUvY29yZS9kaXN0L3N0eWxlLmNzcz9lZDY0Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiMjM3MGY2MjBiNmM1XCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@blocknote/core/dist/style.css\n");

/***/ }),

/***/ "(ssr)/./node_modules/@blocknote/core/dist/blocknote.js":
/*!********************************************************!*\
  !*** ./node_modules/@blocknote/core/dist/blocknote.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BlockNoteEditor: () => (/* binding */ _n),\n/* harmony export */   CustomBlockSerializerExtension: () => (/* binding */ Xe),\n/* harmony export */   FormattingToolbarProsemirrorPlugin: () => (/* binding */ zo),\n/* harmony export */   FormattingToolbarView: () => (/* binding */ Oo),\n/* harmony export */   HyperlinkToolbarProsemirrorPlugin: () => (/* binding */ Fo),\n/* harmony export */   ImageToolbarProsemirrorPlugin: () => (/* binding */ Lo),\n/* harmony export */   ImageToolbarView: () => (/* binding */ Ho),\n/* harmony export */   SideMenuProsemirrorPlugin: () => (/* binding */ Ko),\n/* harmony export */   SideMenuView: () => (/* binding */ qo),\n/* harmony export */   SlashMenuProsemirrorPlugin: () => (/* binding */ Ze),\n/* harmony export */   UnreachableCaseError: () => (/* binding */ De),\n/* harmony export */   blockStyles: () => (/* binding */ In),\n/* harmony export */   camelToDataKebab: () => (/* binding */ ct),\n/* harmony export */   createBlockSpec: () => (/* binding */ ko),\n/* harmony export */   createTipTapBlock: () => (/* binding */ W),\n/* harmony export */   defaultBlockSchema: () => (/* binding */ qt),\n/* harmony export */   defaultProps: () => (/* binding */ T),\n/* harmony export */   formatKeyboardShortcut: () => (/* binding */ xn),\n/* harmony export */   formattingToolbarPluginKey: () => (/* binding */ Ro),\n/* harmony export */   getBlockNoteExtensions: () => (/* binding */ io),\n/* harmony export */   getDefaultSlashMenuItems: () => (/* binding */ Yo),\n/* harmony export */   hyperlinkToolbarPluginKey: () => (/* binding */ Uo),\n/* harmony export */   imageToolbarPluginKey: () => (/* binding */ U),\n/* harmony export */   isAppleOS: () => (/* binding */ Pe),\n/* harmony export */   mergeCSSClasses: () => (/* binding */ B),\n/* harmony export */   parse: () => (/* binding */ fo),\n/* harmony export */   propsToAttributes: () => (/* binding */ mo),\n/* harmony export */   render: () => (/* binding */ go),\n/* harmony export */   setupSuggestionsMenu: () => (/* binding */ Je),\n/* harmony export */   sideMenuPluginKey: () => (/* binding */ Xo),\n/* harmony export */   slashMenuPluginKey: () => (/* binding */ et),\n/* harmony export */   uploadToTmpFilesDotOrg_DEV_ONLY: () => (/* binding */ An)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_extension_bold__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/extension-bold */ \"(ssr)/./node_modules/@tiptap/extension-bold/dist/index.js\");\n/* harmony import */ var _tiptap_extension_code__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/extension-code */ \"(ssr)/./node_modules/@tiptap/extension-code/dist/index.js\");\n/* harmony import */ var _tiptap_extension_collaboration__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/extension-collaboration */ \"(ssr)/./node_modules/@tiptap/extension-collaboration/dist/index.js\");\n/* harmony import */ var _tiptap_extension_collaboration_cursor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tiptap/extension-collaboration-cursor */ \"(ssr)/./node_modules/@tiptap/extension-collaboration-cursor/dist/index.js\");\n/* harmony import */ var _tiptap_extension_dropcursor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tiptap/extension-dropcursor */ \"(ssr)/./node_modules/@tiptap/extension-dropcursor/dist/index.js\");\n/* harmony import */ var _tiptap_extension_gapcursor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tiptap/extension-gapcursor */ \"(ssr)/./node_modules/@tiptap/extension-gapcursor/dist/index.js\");\n/* harmony import */ var _tiptap_extension_hard_break__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tiptap/extension-hard-break */ \"(ssr)/./node_modules/@tiptap/extension-hard-break/dist/index.js\");\n/* harmony import */ var _tiptap_extension_history__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @tiptap/extension-history */ \"(ssr)/./node_modules/@tiptap/extension-history/dist/index.js\");\n/* harmony import */ var _tiptap_extension_italic__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tiptap/extension-italic */ \"(ssr)/./node_modules/@tiptap/extension-italic/dist/index.js\");\n/* harmony import */ var _tiptap_extension_link__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @tiptap/extension-link */ \"(ssr)/./node_modules/@tiptap/extension-link/dist/index.js\");\n/* harmony import */ var _tiptap_extension_strike__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @tiptap/extension-strike */ \"(ssr)/./node_modules/@tiptap/extension-strike/dist/index.js\");\n/* harmony import */ var _tiptap_extension_text__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @tiptap/extension-text */ \"(ssr)/./node_modules/@tiptap/extension-text/dist/index.js\");\n/* harmony import */ var _tiptap_extension_underline__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @tiptap/extension-underline */ \"(ssr)/./node_modules/@tiptap/extension-underline/dist/index.js\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! uuid */ \"(ssr)/./node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var prosemirror_view__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! prosemirror-view */ \"(ssr)/./node_modules/prosemirror-view/dist/index.js\");\n/* harmony import */ var rehype_parse__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! rehype-parse */ \"(ssr)/./node_modules/rehype-parse/lib/index.js\");\n/* harmony import */ var rehype_remark__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! rehype-remark */ \"(ssr)/./node_modules/rehype-remark/lib/index.js\");\n/* harmony import */ var rehype_stringify__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! rehype-stringify */ \"(ssr)/./node_modules/rehype-stringify/lib/index.js\");\n/* harmony import */ var remark_gfm__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! remark-gfm */ \"(ssr)/./node_modules/remark-gfm/index.js\");\n/* harmony import */ var remark_parse__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! remark-parse */ \"(ssr)/./node_modules/remark-parse/lib/index.js\");\n/* harmony import */ var remark_rehype__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! remark-rehype */ \"(ssr)/./node_modules/remark-rehype/lib/index.js\");\n/* harmony import */ var remark_rehype__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! remark-rehype */ \"(ssr)/./node_modules/mdast-util-to-hast/lib/handlers/index.js\");\n/* harmony import */ var remark_stringify__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! remark-stringify */ \"(ssr)/./node_modules/remark-stringify/lib/index.js\");\n/* harmony import */ var unified__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! unified */ \"(ssr)/./node_modules/unified/lib/index.js\");\n/* harmony import */ var hast_util_from_dom__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! hast-util-from-dom */ \"(ssr)/./node_modules/hast-util-from-dom/lib/index.js\");\nvar Jt = Object.defineProperty;\nvar Zt = (n, t, e) => t in n ? Jt(n, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : n[t] = e;\nvar u = (n, t, e) => (Zt(n, typeof t != \"symbol\" ? t + \"\" : t, e), e);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst Be = \"_bnEditor_12je0_3\", xe = \"_bnRoot_12je0_19\", Ie = \"_defaultStyles_12je0_34\", _e = \"_dragPreview_12je0_57\", R = {\n  bnEditor: Be,\n  bnRoot: xe,\n  defaultStyles: Ie,\n  dragPreview: _e,\n  \"collaboration-cursor__caret\": \"_collaboration-cursor__caret_12je0_63\",\n  \"collaboration-cursor__label\": \"_collaboration-cursor__label_12je0_74\"\n};\nfunction yt(n) {\n  const t = n.attrs.id, e = n.firstChild, o = e.type, r = n.childCount === 2 ? n.lastChild.childCount : 0;\n  return {\n    id: t,\n    node: n,\n    contentNode: e,\n    contentType: o,\n    numChildBlocks: r\n  };\n}\nfunction v(n, t) {\n  const o = n.nodeSize - 2;\n  if (t <= 1)\n    for (t = 1 + 1; n.resolve(t).parent.type.name !== \"blockContainer\" && t < o; )\n      t++;\n  else if (t >= o)\n    for (t = o - 1; n.resolve(t).parent.type.name !== \"blockContainer\" && t > 1; )\n      t--;\n  n.resolve(t).parent.type.name === \"blockGroup\" && t++;\n  const r = n.resolve(t), i = r.depth;\n  let s = r.node(i), l = i;\n  for (; ; ) {\n    if (l < 0)\n      throw new Error(\n        \"Could not find blockContainer node. This can only happen if the underlying BlockNote schema has been edited.\"\n      );\n    if (s.type.name === \"blockContainer\")\n      break;\n    l -= 1, s = r.node(l);\n  }\n  const { id: a, contentNode: d, contentType: c, numChildBlocks: h } = yt(s), m = r.start(l), p = r.end(l);\n  return {\n    id: a,\n    node: s,\n    contentNode: d,\n    contentType: c,\n    numChildBlocks: h,\n    startPos: m,\n    endPos: p,\n    depth: l\n  };\n}\nconst T = {\n  backgroundColor: {\n    default: \"default\"\n  },\n  textColor: {\n    default: \"default\"\n  },\n  textAlignment: {\n    default: \"left\",\n    values: [\"left\", \"center\", \"right\", \"justify\"]\n  }\n}, Ae = _tiptap_core__WEBPACK_IMPORTED_MODULE_13__.Extension.create({\n  name: \"blockBackgroundColor\",\n  addGlobalAttributes() {\n    return [\n      {\n        types: [\"blockContainer\"],\n        attributes: {\n          backgroundColor: {\n            default: T.backgroundColor.default,\n            parseHTML: (n) => n.hasAttribute(\"data-background-color\") ? n.getAttribute(\"data-background-color\") : T.backgroundColor.default,\n            renderHTML: (n) => n.backgroundColor !== T.backgroundColor.default && {\n              \"data-background-color\": n.backgroundColor\n            }\n          }\n        }\n      }\n    ];\n  },\n  addCommands() {\n    return {\n      setBlockBackgroundColor: (n, t) => ({ state: e, view: o }) => {\n        const r = v(e.doc, n);\n        return r === void 0 ? !1 : (e.tr.setNodeAttribute(\n          r.startPos - 1,\n          \"backgroundColor\",\n          t\n        ), o.focus(), !0);\n      }\n    };\n  }\n}), He = _tiptap_core__WEBPACK_IMPORTED_MODULE_13__.Mark.create({\n  name: \"backgroundColor\",\n  addAttributes() {\n    return {\n      color: {\n        default: void 0,\n        parseHTML: (n) => n.getAttribute(\"data-background-color\"),\n        renderHTML: (n) => ({\n          \"data-background-color\": n.color\n        })\n      }\n    };\n  },\n  parseHTML() {\n    return [\n      {\n        tag: \"span\",\n        getAttrs: (n) => typeof n == \"string\" ? !1 : n.hasAttribute(\"data-background-color\") ? { color: n.getAttribute(\"data-background-color\") } : !1\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes: n }) {\n    return [\"span\", n, 0];\n  },\n  addCommands() {\n    return {\n      setBackgroundColor: (n) => ({ commands: t }) => n !== T.backgroundColor.default ? t.setMark(this.name, { color: n }) : t.unsetMark(this.name)\n    };\n  }\n});\nfunction Le(n, t = JSON.stringify) {\n  const e = {};\n  return n.filter((o) => {\n    const r = t(o);\n    return Object.prototype.hasOwnProperty.call(e, r) ? !1 : e[r] = !0;\n  });\n}\nfunction Ne(n) {\n  const t = n.filter(\n    (o, r) => n.indexOf(o) !== r\n  );\n  return Le(t);\n}\nconst X = _tiptap_core__WEBPACK_IMPORTED_MODULE_13__.Extension.create({\n  name: \"uniqueID\",\n  // we’ll set a very high priority to make sure this runs first\n  // and is compatible with `appendTransaction` hooks of other extensions\n  priority: 1e4,\n  addOptions() {\n    return {\n      attributeName: \"id\",\n      types: [],\n      generateID: () => {\n        if (typeof window < \"u\" && window.__TEST_OPTIONS) {\n          const n = window.__TEST_OPTIONS;\n          return n.mockID === void 0 ? n.mockID = 0 : n.mockID++, n.mockID.toString();\n        }\n        return (0,uuid__WEBPACK_IMPORTED_MODULE_14__[\"default\"])();\n      },\n      filterTransaction: null\n    };\n  },\n  addGlobalAttributes() {\n    return [\n      {\n        types: this.options.types,\n        attributes: {\n          [this.options.attributeName]: {\n            default: null,\n            parseHTML: (n) => n.getAttribute(`data-${this.options.attributeName}`),\n            renderHTML: (n) => ({\n              [`data-${this.options.attributeName}`]: n[this.options.attributeName]\n            })\n          }\n        }\n      }\n    ];\n  },\n  // check initial content for missing ids\n  // onCreate() {\n  //   // Don’t do this when the collaboration extension is active\n  //   // because this may update the content, so Y.js tries to merge these changes.\n  //   // This leads to empty block nodes.\n  //   // See: https://github.com/ueberdosis/tiptap/issues/2400\n  //   if (\n  //     this.editor.extensionManager.extensions.find(\n  //       (extension) => extension.name === \"collaboration\"\n  //     )\n  //   ) {\n  //     return;\n  //   }\n  //   const { view, state } = this.editor;\n  //   const { tr, doc } = state;\n  //   const { types, attributeName, generateID } = this.options;\n  //   const nodesWithoutId = findChildren(doc, (node) => {\n  //     return (\n  //       types.includes(node.type.name) && node.attrs[attributeName] === null\n  //     );\n  //   });\n  //   nodesWithoutId.forEach(({ node, pos }) => {\n  //     tr.setNodeMarkup(pos, undefined, {\n  //       ...node.attrs,\n  //       [attributeName]: generateID(),\n  //     });\n  //   });\n  //   tr.setMeta(\"addToHistory\", false);\n  //   view.dispatch(tr);\n  // },\n  addProseMirrorPlugins() {\n    let n = null, t = !1;\n    return [\n      new prosemirror_state__WEBPACK_IMPORTED_MODULE_15__.Plugin({\n        key: new prosemirror_state__WEBPACK_IMPORTED_MODULE_15__.PluginKey(\"uniqueID\"),\n        appendTransaction: (e, o, r) => {\n          const i = e.some((f) => f.docChanged) && !o.doc.eq(r.doc), s = this.options.filterTransaction && e.some((f) => {\n            let b, w;\n            return !(!((w = (b = this.options).filterTransaction) === null || w === void 0) && w.call(b, f));\n          });\n          if (!i || s)\n            return;\n          const { tr: l } = r, { types: a, attributeName: d, generateID: c } = this.options, h = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_13__.combineTransactionSteps)(\n            o.doc,\n            e\n          ), { mapping: m } = h;\n          if ((0,_tiptap_core__WEBPACK_IMPORTED_MODULE_13__.getChangedRanges)(h).forEach(({ newRange: f }) => {\n            const b = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_13__.findChildrenInRange)(\n              r.doc,\n              f,\n              (M) => a.includes(M.type.name)\n            ), w = b.map(({ node: M }) => M.attrs[d]).filter((M) => M !== null), C = Ne(w);\n            b.forEach(({ node: M, pos: E }) => {\n              let y;\n              const S = (y = l.doc.nodeAt(E)) === null || y === void 0 ? void 0 : y.attrs[d];\n              if (S === null) {\n                l.setNodeMarkup(E, void 0, {\n                  ...M.attrs,\n                  [d]: c()\n                });\n                return;\n              }\n              const { deleted: g } = m.invert().mapResult(E);\n              g && C.includes(S) && l.setNodeMarkup(E, void 0, {\n                ...M.attrs,\n                [d]: c()\n              });\n            });\n          }), !!l.steps.length)\n            return l;\n        },\n        // we register a global drag handler to track the current drag source element\n        view(e) {\n          const o = (r) => {\n            let i;\n            n = !((i = e.dom.parentElement) === null || i === void 0) && i.contains(r.target) ? e.dom.parentElement : null;\n          };\n          return window.addEventListener(\"dragstart\", o), {\n            destroy() {\n              window.removeEventListener(\"dragstart\", o);\n            }\n          };\n        },\n        props: {\n          // `handleDOMEvents` is called before `transformPasted`\n          // so we can do some checks before\n          handleDOMEvents: {\n            // only create new ids for dropped content while holding `alt`\n            // or content is dragged from another editor\n            drop: (e, o) => {\n              let r;\n              return (n !== e.dom.parentElement || ((r = o.dataTransfer) === null || r === void 0 ? void 0 : r.effectAllowed) === \"copy\") && (n = null, t = !0), !1;\n            },\n            // always create new ids on pasted content\n            paste: () => (t = !0, !1)\n          },\n          // we’ll remove ids for every pasted node\n          // so we can create a new one within `appendTransaction`\n          transformPasted: (e) => {\n            if (!t)\n              return e;\n            const { types: o, attributeName: r } = this.options, i = (s) => {\n              const l = [];\n              return s.forEach((a) => {\n                if (a.isText) {\n                  l.push(a);\n                  return;\n                }\n                if (!o.includes(a.type.name)) {\n                  l.push(a.copy(i(a.content)));\n                  return;\n                }\n                const d = a.type.create(\n                  {\n                    ...a.attrs,\n                    [r]: null\n                  },\n                  i(a.content),\n                  a.marks\n                );\n                l.push(d);\n              }), prosemirror_model__WEBPACK_IMPORTED_MODULE_16__.Fragment.from(l);\n            };\n            return t = !1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_16__.Slice(\n              i(e.content),\n              e.openStart,\n              e.openEnd\n            );\n          }\n        }\n      })\n    ];\n  }\n}), Pe = () => /Mac/.test(navigator.platform) || /AppleWebKit/.test(navigator.userAgent) && /Mobile\\/\\w+/.test(navigator.userAgent);\nfunction xn(n) {\n  return Pe() ? n.replace(\"Mod\", \"⌘\") : n.replace(\"Mod\", \"Ctrl\");\n}\nfunction B(...n) {\n  return n.filter((t) => t).join(\" \");\n}\nclass De extends Error {\n  constructor(t) {\n    super(`Unreachable case: ${t}`);\n  }\n}\nconst vt = /* @__PURE__ */ new Set([\n  \"bold\",\n  \"italic\",\n  \"underline\",\n  \"strike\",\n  \"code\"\n]), wt = /* @__PURE__ */ new Set([\"textColor\", \"backgroundColor\"]);\nfunction lt(n, t) {\n  const e = [];\n  for (const [o, r] of Object.entries(n.styles))\n    vt.has(o) ? e.push(t.mark(o)) : wt.has(o) && e.push(t.mark(o, { color: r }));\n  return n.text.split(/(\\n)/g).filter((o) => o.length > 0).map((o) => o === `\n` ? t.nodes.hardBreak.create() : t.text(o, e));\n}\nfunction Oe(n, t) {\n  const e = t.marks.link.create({\n    href: n.href\n  });\n  return Ct(n.content, t).map((o) => {\n    if (o.type.name === \"text\")\n      return o.mark([...o.marks, e]);\n    if (o.type.name === \"hardBreak\")\n      return o;\n    throw new Error(\"unexpected node type\");\n  });\n}\nfunction Ct(n, t) {\n  const e = [];\n  if (typeof n == \"string\")\n    return e.push(\n      ...lt({ type: \"text\", text: n, styles: {} }, t)\n    ), e;\n  for (const o of n)\n    e.push(...lt(o, t));\n  return e;\n}\nfunction Et(n, t) {\n  const e = [];\n  for (const o of n)\n    if (o.type === \"link\")\n      e.push(...Oe(o, t));\n    else if (o.type === \"text\")\n      e.push(...Ct([o], t));\n    else\n      throw new De(o);\n  return e;\n}\nfunction F(n, t) {\n  let e = n.id;\n  e === void 0 && (e = X.options.generateID());\n  let o = n.type;\n  o === void 0 && (o = \"paragraph\");\n  let r;\n  if (!n.content)\n    r = t.nodes[o].create(n.props);\n  else if (typeof n.content == \"string\")\n    r = t.nodes[o].create(\n      n.props,\n      t.text(n.content)\n    );\n  else {\n    const l = Et(n.content, t);\n    r = t.nodes[o].create(n.props, l);\n  }\n  const i = [];\n  if (n.children)\n    for (const l of n.children)\n      i.push(F(l, t));\n  const s = t.nodes.blockGroup.create({}, i);\n  return t.nodes.blockContainer.create(\n    {\n      id: e,\n      ...n.props\n    },\n    i.length > 0 ? [r, s] : r\n  );\n}\nfunction Re(n) {\n  const t = [];\n  let e;\n  return n.content.forEach((o) => {\n    if (o.type.name === \"hardBreak\") {\n      e ? e.type === \"text\" ? e.text += `\n` : e.type === \"link\" && (e.content[e.content.length - 1].text += `\n`) : e = {\n        type: \"text\",\n        text: `\n`,\n        styles: {}\n      };\n      return;\n    }\n    const r = {};\n    let i;\n    for (const s of o.marks)\n      if (s.type.name === \"link\")\n        i = s;\n      else if (vt.has(s.type.name))\n        r[s.type.name] = !0;\n      else if (wt.has(s.type.name))\n        r[s.type.name] = s.attrs.color;\n      else\n        throw Error(\"Mark is of an unrecognized type: \" + s.type.name);\n    e ? e.type === \"text\" ? i ? (t.push(e), e = {\n      type: \"link\",\n      href: i.attrs.href,\n      content: [\n        {\n          type: \"text\",\n          text: o.textContent,\n          styles: r\n        }\n      ]\n    }) : JSON.stringify(e.styles) === JSON.stringify(r) ? e.text += o.textContent : (t.push(e), e = {\n      type: \"text\",\n      text: o.textContent,\n      styles: r\n    }) : e.type === \"link\" && (i ? e.href === i.attrs.href ? JSON.stringify(\n      e.content[e.content.length - 1].styles\n    ) === JSON.stringify(r) ? e.content[e.content.length - 1].text += o.textContent : e.content.push({\n      type: \"text\",\n      text: o.textContent,\n      styles: r\n    }) : (t.push(e), e = {\n      type: \"link\",\n      href: i.attrs.href,\n      content: [\n        {\n          type: \"text\",\n          text: o.textContent,\n          styles: r\n        }\n      ]\n    }) : (t.push(e), e = {\n      type: \"text\",\n      text: o.textContent,\n      styles: r\n    })) : i ? e = {\n      type: \"link\",\n      href: i.attrs.href,\n      content: [\n        {\n          type: \"text\",\n          text: o.textContent,\n          styles: r\n        }\n      ]\n    } : e = {\n      type: \"text\",\n      text: o.textContent,\n      styles: r\n    };\n  }), e && t.push(e), t;\n}\nfunction A(n, t, e) {\n  if (n.type.name !== \"blockContainer\")\n    throw Error(\n      \"Node must be of type blockContainer, but is of type\" + n.type.name + \".\"\n    );\n  const o = e == null ? void 0 : e.get(n);\n  if (o)\n    return o;\n  const r = yt(n);\n  let i = r.id;\n  i === null && (i = X.options.generateID());\n  const s = {};\n  for (const [c, h] of Object.entries({\n    ...n.attrs,\n    ...r.contentNode.attrs\n  })) {\n    const m = t[r.contentType.name];\n    if (!m)\n      throw Error(\n        \"Block is of an unrecognized type: \" + r.contentType.name\n      );\n    const p = m.propSchema;\n    c in p && (s[c] = h);\n  }\n  const l = t[r.contentType.name], a = [];\n  for (let c = 0; c < r.numChildBlocks; c++)\n    a.push(\n      A(n.lastChild.child(c), t, e)\n    );\n  const d = {\n    id: i,\n    type: l.node.name,\n    props: s,\n    content: l.node.config.content === \"inline*\" ? Re(r.contentNode) : void 0,\n    children: a\n  };\n  return e == null || e.set(n, d), d;\n}\nconst dt = new prosemirror_state__WEBPACK_IMPORTED_MODULE_15__.PluginKey(\"previous-blocks\"), ze = {\n  // Numbered List Items\n  index: \"index\",\n  // Headings\n  level: \"level\",\n  // All Blocks\n  type: \"type\",\n  depth: \"depth\",\n  \"depth-change\": \"depth-change\"\n}, Ve = () => {\n  let n;\n  return new prosemirror_state__WEBPACK_IMPORTED_MODULE_15__.Plugin({\n    key: dt,\n    view(t) {\n      return {\n        update: async (e, o) => {\n          var r;\n          ((r = this.key) == null ? void 0 : r.getState(e.state).updatedBlocks.size) > 0 && (n = setTimeout(() => {\n            e.dispatch(\n              e.state.tr.setMeta(dt, { clearUpdate: !0 })\n            );\n          }, 0));\n        },\n        destroy: () => {\n          n && clearTimeout(n);\n        }\n      };\n    },\n    state: {\n      init() {\n        return {\n          // Block attributes, by block ID, from just before the previous transaction.\n          prevTransactionOldBlockAttrs: {},\n          // Block attributes, by block ID, from just before the current transaction.\n          currentTransactionOldBlockAttrs: {},\n          // Set of IDs of blocks whose attributes changed from the current transaction.\n          updatedBlocks: /* @__PURE__ */ new Set()\n        };\n      },\n      apply(t, e, o, r) {\n        if (e.currentTransactionOldBlockAttrs = {}, e.updatedBlocks.clear(), !t.docChanged || o.doc.eq(r.doc))\n          return e;\n        const i = {}, s = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_13__.findChildren)(o.doc, (d) => d.attrs.id), l = new Map(\n          s.map((d) => [d.node.attrs.id, d])\n        ), a = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_13__.findChildren)(r.doc, (d) => d.attrs.id);\n        for (const d of a) {\n          const c = l.get(d.node.attrs.id), h = c == null ? void 0 : c.node.firstChild, m = d.node.firstChild;\n          if (c && h && m) {\n            const p = {\n              index: m.attrs.index,\n              level: m.attrs.level,\n              type: m.type.name,\n              depth: r.doc.resolve(d.pos).depth\n            };\n            let f = {\n              index: h.attrs.index,\n              level: h.attrs.level,\n              type: h.type.name,\n              depth: o.doc.resolve(c.pos).depth\n            };\n            i[d.node.attrs.id] = f, t.getMeta(\"numberedListIndexing\") && (d.node.attrs.id in e.prevTransactionOldBlockAttrs && (f = e.prevTransactionOldBlockAttrs[d.node.attrs.id]), p.type === \"numberedListItem\" && (f.index = p.index)), e.currentTransactionOldBlockAttrs[d.node.attrs.id] = f, JSON.stringify(f) !== JSON.stringify(p) && (f[\"depth-change\"] = f.depth - p.depth, e.updatedBlocks.add(d.node.attrs.id));\n          }\n        }\n        return e.prevTransactionOldBlockAttrs = i, e;\n      }\n    },\n    props: {\n      decorations(t) {\n        const e = this.getState(t);\n        if (e.updatedBlocks.size === 0)\n          return;\n        const o = [];\n        return t.doc.descendants((r, i) => {\n          if (!r.attrs.id || !e.updatedBlocks.has(r.attrs.id))\n            return;\n          const s = e.currentTransactionOldBlockAttrs[r.attrs.id], l = {};\n          for (const [d, c] of Object.entries(s))\n            l[\"data-prev-\" + ze[d]] = c || \"none\";\n          const a = prosemirror_view__WEBPACK_IMPORTED_MODULE_17__.Decoration.node(i, i + r.nodeSize, {\n            ...l\n          });\n          o.push(a);\n        }), prosemirror_view__WEBPACK_IMPORTED_MODULE_17__.DecorationSet.create(t.doc, o);\n      }\n    }\n  });\n}, St = \"_blockOuter_nstdf_5\", Mt = \"_block_nstdf_5\", Tt = \"_reactNodeViewRenderer_nstdf_17\", Bt = \"_blockContent_nstdf_22\", xt = \"_blockGroup_nstdf_43\", It = \"_wrapper_nstdf_227\", _t = \"_addImageButton_nstdf_235\", At = \"_addImageButtonIcon_nstdf_251\", Ht = \"_addImageButtonText_nstdf_257\", Lt = \"_imageAndCaptionWrapper_nstdf_261\", Nt = \"_imageWrapper_nstdf_267\", Pt = \"_image_nstdf_261\", Dt = \"_resizeHandle_nstdf_280\", Ot = \"_caption_nstdf_291\", Rt = \"_isEmpty_nstdf_297\", zt = \"_inlineContent_nstdf_297\", Vt = \"_isFilter_nstdf_298\", Ut = \"_hasAnchor_nstdf_310\", k = {\n  blockOuter: St,\n  block: Mt,\n  reactNodeViewRenderer: Tt,\n  blockContent: Bt,\n  blockGroup: xt,\n  wrapper: It,\n  addImageButton: _t,\n  addImageButtonIcon: At,\n  addImageButtonText: Ht,\n  imageAndCaptionWrapper: Lt,\n  imageWrapper: Nt,\n  image: Pt,\n  resizeHandle: Dt,\n  caption: Ot,\n  isEmpty: Rt,\n  inlineContent: zt,\n  isFilter: Vt,\n  hasAnchor: Ut\n}, In = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  addImageButton: _t,\n  addImageButtonIcon: At,\n  addImageButtonText: Ht,\n  block: Mt,\n  blockContent: Bt,\n  blockGroup: xt,\n  blockOuter: St,\n  caption: Ot,\n  default: k,\n  hasAnchor: Ut,\n  image: Pt,\n  imageAndCaptionWrapper: Lt,\n  imageWrapper: Nt,\n  inlineContent: zt,\n  isEmpty: Rt,\n  isFilter: Vt,\n  reactNodeViewRenderer: Tt,\n  resizeHandle: Dt,\n  wrapper: It\n}, Symbol.toStringTag, { value: \"Module\" })), Ue = {\n  blockColor: \"data-block-color\",\n  blockStyle: \"data-block-style\",\n  id: \"data-id\",\n  depth: \"data-depth\",\n  depthChange: \"data-depth-change\"\n}, Fe = new prosemirror_state__WEBPACK_IMPORTED_MODULE_15__.PluginKey(\"non-editable-block\"), $e = () => new prosemirror_state__WEBPACK_IMPORTED_MODULE_15__.Plugin({\n  key: Fe,\n  props: {\n    handleKeyDown: (n, t) => {\n      \"node\" in n.state.selection && t.preventDefault();\n    }\n  }\n}), We = _tiptap_core__WEBPACK_IMPORTED_MODULE_13__.Node.create({\n  name: \"blockContainer\",\n  group: \"blockContainer\",\n  // A block always contains content, and optionally a blockGroup which contains nested blocks\n  content: \"blockContent blockGroup?\",\n  // Ensures content-specific keyboard handlers trigger first.\n  priority: 50,\n  defining: !0,\n  parseHTML() {\n    return [\n      {\n        tag: \"div\",\n        getAttrs: (n) => {\n          if (typeof n == \"string\")\n            return !1;\n          const t = {};\n          for (const [e, o] of Object.entries(Ue))\n            n.getAttribute(o) && (t[e] = n.getAttribute(o));\n          return n.getAttribute(\"data-node-type\") === \"blockContainer\" ? t : !1;\n        }\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes: n }) {\n    var e;\n    const t = ((e = this.options.domAttributes) == null ? void 0 : e.blockContainer) || {};\n    return [\n      \"div\",\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_13__.mergeAttributes)(n, {\n        class: k.blockOuter,\n        \"data-node-type\": \"block-outer\"\n      }),\n      [\n        \"div\",\n        (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_13__.mergeAttributes)(\n          {\n            ...t,\n            class: B(k.block, t.class),\n            \"data-node-type\": this.name\n          },\n          n\n        ),\n        0\n      ]\n    ];\n  },\n  addCommands() {\n    return {\n      // Creates a new text block at a given position.\n      BNCreateBlock: (n) => ({ state: t, dispatch: e }) => {\n        const o = t.schema.nodes.blockContainer.createAndFill();\n        return e && t.tr.insert(n, o), !0;\n      },\n      // Deletes a block at a given position.\n      BNDeleteBlock: (n) => ({ state: t, dispatch: e }) => {\n        const o = v(t.doc, n);\n        if (o === void 0)\n          return !1;\n        const { startPos: r, endPos: i } = o;\n        return e && t.tr.deleteRange(r, i), !0;\n      },\n      // Updates a block at a given position.\n      BNUpdateBlock: (n, t) => ({ state: e, dispatch: o }) => {\n        const r = v(e.doc, n);\n        if (r === void 0)\n          return !1;\n        const { startPos: i, endPos: s, node: l, contentNode: a } = r;\n        if (o) {\n          if (t.children !== void 0) {\n            const p = [];\n            for (const f of t.children)\n              p.push(F(f, e.schema));\n            l.childCount === 2 ? e.tr.replace(\n              i + a.nodeSize + 1,\n              s - 1,\n              new prosemirror_model__WEBPACK_IMPORTED_MODULE_16__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_16__.Fragment.from(p), 0, 0)\n            ) : e.tr.insert(\n              i + a.nodeSize,\n              e.schema.nodes.blockGroup.create({}, p)\n            );\n          }\n          if (t.content !== void 0) {\n            let p = [];\n            typeof t.content == \"string\" ? p.push(e.schema.text(t.content)) : p = Et(t.content, e.schema), e.tr.replace(\n              i + 1,\n              i + a.nodeSize - 1,\n              new prosemirror_model__WEBPACK_IMPORTED_MODULE_16__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_16__.Fragment.from(p), 0, 0)\n            );\n          }\n          const d = a.type.name, c = t.type || d, h = e.schema.nodes[d].spec.content, m = e.schema.nodes[c].spec.content;\n          h === \"inline*\" && m === \"\" ? e.tr.replaceWith(\n            i,\n            s,\n            e.schema.nodes[c].create({\n              ...a.attrs,\n              ...t.props\n            })\n          ).setSelection(\n            new prosemirror_state__WEBPACK_IMPORTED_MODULE_15__.NodeSelection(e.tr.doc.resolve(i))\n          ) : e.tr.setNodeMarkup(\n            i,\n            t.type === void 0 ? void 0 : e.schema.nodes[t.type],\n            {\n              ...a.attrs,\n              ...t.props\n            }\n          ), e.tr.setNodeMarkup(i - 1, void 0, {\n            ...l.attrs,\n            ...t.props\n          });\n        }\n        return !0;\n      },\n      // Appends the text contents of a block to the nearest previous block, given a position between them. Children of\n      // the merged block are moved out of it first, rather than also being merged.\n      //\n      // In the example below, the position passed into the function is between Block1 and Block2.\n      //\n      // Block1\n      //    Block2\n      // Block3\n      //    Block4\n      //        Block5\n      //\n      // Becomes:\n      //\n      // Block1\n      //    Block2Block3\n      // Block4\n      //     Block5\n      BNMergeBlocks: (n) => ({ state: t, dispatch: e }) => {\n        const o = t.doc.resolve(n + 1).node().type.name === \"blockContainer\", r = t.doc.resolve(n - 1).node().type.name === \"blockContainer\";\n        if (!o || !r)\n          return !1;\n        const i = v(\n          t.doc,\n          n + 1\n        ), { node: s, contentNode: l, startPos: a, endPos: d, depth: c } = i;\n        if (s.childCount === 2) {\n          const p = t.doc.resolve(\n            a + l.nodeSize + 1\n          ), f = t.doc.resolve(d - 1), b = p.blockRange(f);\n          e && t.tr.lift(b, c - 1);\n        }\n        let h = n - 1, m = v(t.doc, h);\n        for (; m.numChildBlocks > 0; )\n          if (h--, m = v(t.doc, h), m === void 0)\n            return !1;\n        return e && (e(\n          t.tr.deleteRange(a, a + l.nodeSize).replace(\n            h - 1,\n            a,\n            new prosemirror_model__WEBPACK_IMPORTED_MODULE_16__.Slice(l.content, 0, 0)\n          ).scrollIntoView()\n        ), t.tr.setSelection(\n          new prosemirror_state__WEBPACK_IMPORTED_MODULE_15__.TextSelection(t.doc.resolve(h - 1))\n        )), !0;\n      },\n      // Splits a block at a given position. Content after the position is moved to a new block below, at the same\n      // nesting level.\n      BNSplitBlock: (n, t) => ({ state: e, dispatch: o }) => {\n        const r = v(e.doc, n);\n        if (r === void 0)\n          return !1;\n        const { contentNode: i, contentType: s, startPos: l, endPos: a, depth: d } = r, c = e.doc.cut(l + 1, n), h = e.doc.cut(n, a - 1), m = e.schema.nodes.blockContainer.createAndFill(), p = a + 1, f = p + 2;\n        return o && (e.tr.insert(p, m), e.tr.replace(\n          f,\n          f + 1,\n          h.content.size > 0 ? new prosemirror_model__WEBPACK_IMPORTED_MODULE_16__.Slice(\n            prosemirror_model__WEBPACK_IMPORTED_MODULE_16__.Fragment.from(h),\n            d + 2,\n            d + 2\n          ) : void 0\n        ), t && e.tr.setBlockType(\n          f,\n          f,\n          e.schema.node(s).type,\n          i.attrs\n        ), e.tr.setSelection(\n          new prosemirror_state__WEBPACK_IMPORTED_MODULE_15__.TextSelection(e.doc.resolve(f))\n        ), e.tr.replace(\n          l + 1,\n          a - 1,\n          c.content.size > 0 ? new prosemirror_model__WEBPACK_IMPORTED_MODULE_16__.Slice(\n            prosemirror_model__WEBPACK_IMPORTED_MODULE_16__.Fragment.from(c),\n            d + 2,\n            d + 2\n          ) : void 0\n        )), !0;\n      }\n    };\n  },\n  addProseMirrorPlugins() {\n    return [Ve(), $e()];\n  },\n  addKeyboardShortcuts() {\n    return {\n      Backspace: () => this.editor.commands.first(({ commands: o }) => [\n        // Deletes the selection if it's not empty.\n        () => o.deleteSelection(),\n        // Undoes an input rule if one was triggered in the last editor state change.\n        () => o.undoInputRule(),\n        // Reverts block content type to a paragraph if the selection is at the start of the block.\n        () => o.command(({ state: r }) => {\n          const { contentType: i } = v(\n            r.doc,\n            r.selection.from\n          ), s = r.selection.$anchor.parentOffset === 0, l = i.name === \"paragraph\";\n          return s && !l ? o.BNUpdateBlock(r.selection.from, {\n            type: \"paragraph\",\n            props: {}\n          }) : !1;\n        }),\n        // Removes a level of nesting if the block is indented if the selection is at the start of the block.\n        () => o.command(({ state: r }) => r.selection.$anchor.parentOffset === 0 ? o.liftListItem(\"blockContainer\") : !1),\n        // Merges block with the previous one if it isn't indented, isn't the first block in the doc, and the selection\n        // is at the start of the block.\n        () => o.command(({ state: r }) => {\n          const { depth: i, startPos: s } = v(\n            r.doc,\n            r.selection.from\n          ), l = r.selection.$anchor.parentOffset === 0, a = r.selection.anchor === r.selection.head, d = s === 2, c = s - 1;\n          return !d && l && a && i === 2 ? o.BNMergeBlocks(c) : !1;\n        })\n      ]),\n      Delete: () => this.editor.commands.first(({ commands: o }) => [\n        // Deletes the selection if it's not empty.\n        () => o.deleteSelection(),\n        // Merges block with the next one (at the same nesting level or lower),\n        // if one exists, the block has no children, and the selection is at the\n        // end of the block.\n        () => o.command(({ state: r }) => {\n          const { node: i, contentNode: s, depth: l, endPos: a } = v(\n            r.doc,\n            r.selection.from\n          ), d = r.selection.$anchor.parentOffset === s.firstChild.nodeSize, c = r.selection.anchor === r.selection.head, h = i.childCount === 2;\n          if (d && c && !h) {\n            let m = l, p = a + 2, f = r.doc.resolve(p).depth;\n            for (; f < m; )\n              m = f, p += 2, f = r.doc.resolve(p).depth;\n            return o.BNMergeBlocks(p - 1);\n          }\n          return !1;\n        })\n      ]),\n      Enter: () => this.editor.commands.first(({ commands: o }) => [\n        // Removes a level of nesting if the block is empty & indented, while the selection is also empty & at the start\n        // of the block.\n        () => o.command(({ state: r }) => {\n          const { node: i, depth: s } = v(\n            r.doc,\n            r.selection.from\n          ), l = r.selection.$anchor.parentOffset === 0, a = r.selection.anchor === r.selection.head, d = i.textContent.length === 0, c = s > 2;\n          return l && a && d && c ? o.liftListItem(\"blockContainer\") : !1;\n        }),\n        // Creates a new block and moves the selection to it if the current one is empty, while the selection is also\n        // empty & at the start of the block.\n        () => o.command(({ state: r, chain: i }) => {\n          const { node: s, endPos: l } = v(\n            r.doc,\n            r.selection.from\n          ), a = r.selection.$anchor.parentOffset === 0, d = r.selection.anchor === r.selection.head, c = s.textContent.length === 0;\n          if (a && d && c) {\n            const h = l + 1, m = h + 2;\n            return i().BNCreateBlock(h).setTextSelection(m).run(), !0;\n          }\n          return !1;\n        }),\n        // Splits the current block, moving content inside that's after the cursor to a new text block below. Also\n        // deletes the selection beforehand, if it's not empty.\n        () => o.command(({ state: r, chain: i }) => {\n          const { node: s } = v(\n            r.doc,\n            r.selection.from\n          ), l = r.selection.$anchor.parentOffset === 0;\n          return s.textContent.length === 0 ? !1 : (i().deleteSelection().BNSplitBlock(r.selection.from, l).run(), !0);\n        })\n      ]),\n      // Always returning true for tab key presses ensures they're not captured by the browser. Otherwise, they blur the\n      // editor since the browser will try to use tab for keyboard navigation.\n      Tab: () => (this.editor.commands.sinkListItem(\"blockContainer\"), !0),\n      \"Shift-Tab\": () => (this.editor.commands.liftListItem(\"blockContainer\"), !0),\n      \"Mod-Alt-0\": () => this.editor.commands.BNCreateBlock(\n        this.editor.state.selection.anchor + 2\n      )\n    };\n  }\n}), Ge = _tiptap_core__WEBPACK_IMPORTED_MODULE_13__.Node.create({\n  name: \"blockGroup\",\n  group: \"blockGroup\",\n  content: \"blockContainer+\",\n  parseHTML() {\n    return [\n      {\n        tag: \"div\",\n        getAttrs: (n) => typeof n == \"string\" ? !1 : n.getAttribute(\"data-node-type\") === \"blockGroup\" ? null : !1\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes: n }) {\n    var e;\n    const t = ((e = this.options.domAttributes) == null ? void 0 : e.blockGroup) || {};\n    return [\n      \"div\",\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_13__.mergeAttributes)(\n        {\n          ...t,\n          class: B(\n            k.blockGroup,\n            t.class\n          ),\n          \"data-node-type\": \"blockGroup\"\n        },\n        n\n      ),\n      0\n    ];\n  }\n}), je = _tiptap_core__WEBPACK_IMPORTED_MODULE_13__.Node.create({\n  name: \"doc\",\n  topNode: !0,\n  content: \"blockGroup\"\n}), qe = (n) => {\n  const t = prosemirror_model__WEBPACK_IMPORTED_MODULE_16__.DOMSerializer.fromSchema(n);\n  return new prosemirror_model__WEBPACK_IMPORTED_MODULE_16__.DOMSerializer(\n    {\n      ...t.nodes\n      // TODO: If a serializer is defined in the config for a custom block, it\n      //  should be added here. We still need to figure out how the serializer\n      //  should be defined in the custom blocks API though, and implement that,\n      //  before we can do this.\n    },\n    t.marks\n  );\n}, Xe = _tiptap_core__WEBPACK_IMPORTED_MODULE_13__.Extension.create({\n  addProseMirrorPlugins() {\n    return [\n      new prosemirror_state__WEBPACK_IMPORTED_MODULE_15__.Plugin({\n        props: {\n          clipboardSerializer: qe(this.editor.schema)\n        }\n      })\n    ];\n  }\n});\nclass $ {\n  constructor() {\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    u(this, \"callbacks\", {});\n  }\n  on(t, e) {\n    return this.callbacks[t] || (this.callbacks[t] = []), this.callbacks[t].push(e), () => this.off(t, e);\n  }\n  emit(t, ...e) {\n    const o = this.callbacks[t];\n    o && o.forEach((r) => r.apply(this, e));\n  }\n  off(t, e) {\n    const o = this.callbacks[t];\n    o && (e ? this.callbacks[t] = o.filter((r) => r !== e) : delete this.callbacks[t]);\n  }\n  removeAllListeners() {\n    this.callbacks = {};\n  }\n}\nconst Ke = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_13__.findParentNode)(\n  (n) => n.type.name === \"blockContainer\"\n);\nclass Ye {\n  constructor(t, e, o = () => {\n  }) {\n    u(this, \"suggestionsMenuState\");\n    u(this, \"updateSuggestionsMenu\");\n    u(this, \"pluginState\");\n    u(this, \"handleScroll\", () => {\n      var t;\n      if ((t = this.suggestionsMenuState) != null && t.show) {\n        const e = document.querySelector(\n          `[data-decoration-id=\"${this.pluginState.decorationId}\"]`\n        );\n        this.suggestionsMenuState.referencePos = e.getBoundingClientRect(), this.updateSuggestionsMenu();\n      }\n    });\n    this.editor = t, this.pluginKey = e, this.pluginState = Z(), this.updateSuggestionsMenu = () => {\n      if (!this.suggestionsMenuState)\n        throw new Error(\"Attempting to update uninitialized suggestions menu\");\n      o(this.suggestionsMenuState);\n    }, document.addEventListener(\"scroll\", this.handleScroll);\n  }\n  update(t, e) {\n    const o = this.pluginKey.getState(e), r = this.pluginKey.getState(t.state), i = !o.active && r.active, s = o.active && !r.active, l = o.active && r.active;\n    if (!i && !l && !s)\n      return;\n    if (this.pluginState = s ? o : r, s || !this.editor.isEditable) {\n      this.suggestionsMenuState.show = !1, this.updateSuggestionsMenu();\n      return;\n    }\n    const a = document.querySelector(\n      `[data-decoration-id=\"${this.pluginState.decorationId}\"]`\n    );\n    this.editor.isEditable && (this.suggestionsMenuState = {\n      show: !0,\n      referencePos: a.getBoundingClientRect(),\n      filteredItems: this.pluginState.items,\n      keyboardHoveredItemIndex: this.pluginState.keyboardHoveredItemIndex\n    }, this.updateSuggestionsMenu());\n  }\n  destroy() {\n    document.removeEventListener(\"scroll\", this.handleScroll);\n  }\n}\nfunction Z() {\n  return {\n    active: !1,\n    triggerCharacter: void 0,\n    queryStartPos: void 0,\n    items: [],\n    keyboardHoveredItemIndex: void 0,\n    notFoundCount: 0,\n    decorationId: void 0\n  };\n}\nconst Je = (n, t, e, o, r = () => [], i = () => {\n}) => {\n  if (o.length !== 1)\n    throw new Error(\"'char' should be a single character\");\n  let s;\n  const l = (a) => {\n    a.dispatch(a.state.tr.setMeta(e, { deactivate: !0 }));\n  };\n  return {\n    plugin: new prosemirror_state__WEBPACK_IMPORTED_MODULE_15__.Plugin({\n      key: e,\n      view: () => (s = new Ye(\n        n,\n        e,\n        t\n      ), s),\n      state: {\n        // Initialize the plugin's internal state.\n        init() {\n          return Z();\n        },\n        // Apply changes to the plugin state from an editor transaction.\n        apply(a, d, c, h) {\n          var p, f, b, w;\n          if (a.getMeta(\"orderedListIndexing\") !== void 0)\n            return d;\n          if ((p = a.getMeta(e)) != null && p.activate)\n            return {\n              active: !0,\n              triggerCharacter: ((f = a.getMeta(e)) == null ? void 0 : f.triggerCharacter) || \"\",\n              queryStartPos: h.selection.from,\n              items: r(\"\"),\n              keyboardHoveredItemIndex: 0,\n              // TODO: Maybe should be 1 if the menu has no possible items? Probably redundant since a menu with no items\n              //  is useless in practice.\n              notFoundCount: 0,\n              decorationId: `id_${Math.floor(Math.random() * 4294967295)}`\n            };\n          if (!d.active)\n            return d;\n          const m = { ...d };\n          if (m.items = r(\n            h.doc.textBetween(\n              d.queryStartPos,\n              h.selection.from\n            )\n          ), m.notFoundCount = 0, m.items.length === 0 && (m.notFoundCount = Math.max(\n            0,\n            d.notFoundCount + (h.selection.from - c.selection.from)\n          )), // Highlighting text should hide the menu.\n          h.selection.from !== h.selection.to || // Transactions with plugin metadata {deactivate: true} should hide the menu.\n          (b = a.getMeta(e)) != null && b.deactivate || // Certain mouse events should hide the menu.\n          // TODO: Change to global mousedown listener.\n          a.getMeta(\"focus\") || a.getMeta(\"blur\") || a.getMeta(\"pointer\") || // Moving the caret before the character which triggered the menu should hide it.\n          d.active && h.selection.from < d.queryStartPos || // Entering more than 3 characters, after the last query that matched with at least 1 menu item, should hide\n          // the menu.\n          m.notFoundCount > 3)\n            return Z();\n          if (((w = a.getMeta(e)) == null ? void 0 : w.selectedItemIndexChanged) !== void 0) {\n            let C = a.getMeta(e).selectedItemIndexChanged;\n            C < 0 ? C = d.items.length - 1 : C >= d.items.length && (C = 0), m.keyboardHoveredItemIndex = C;\n          } else\n            c.selection.from !== h.selection.from && (m.keyboardHoveredItemIndex = 0);\n          return m;\n        }\n      },\n      props: {\n        handleKeyDown(a, d) {\n          const c = this.getState(a.state).active;\n          if (d.key === o && !c)\n            return a.dispatch(\n              a.state.tr.insertText(o).scrollIntoView().setMeta(e, {\n                activate: !0,\n                triggerCharacter: o\n              })\n            ), !0;\n          if (!c)\n            return !1;\n          const {\n            triggerCharacter: h,\n            queryStartPos: m,\n            items: p,\n            keyboardHoveredItemIndex: f\n          } = e.getState(a.state);\n          return d.key === \"ArrowUp\" ? (a.dispatch(\n            a.state.tr.setMeta(e, {\n              selectedItemIndexChanged: f - 1\n            })\n          ), !0) : d.key === \"ArrowDown\" ? (a.dispatch(\n            a.state.tr.setMeta(e, {\n              selectedItemIndexChanged: f + 1\n            })\n          ), !0) : d.key === \"Enter\" ? (p.length === 0 || (l(a), n._tiptapEditor.chain().focus().deleteRange({\n            from: m - h.length,\n            to: n._tiptapEditor.state.selection.from\n          }).run(), i({\n            item: p[f],\n            editor: n\n          })), !0) : d.key === \"Escape\" ? (l(a), !0) : !1;\n        },\n        // Setup decorator on the currently active suggestion.\n        decorations(a) {\n          const { active: d, decorationId: c, queryStartPos: h, triggerCharacter: m } = this.getState(a);\n          if (!d)\n            return null;\n          if (m === \"\") {\n            const p = Ke(a.selection);\n            if (p)\n              return prosemirror_view__WEBPACK_IMPORTED_MODULE_17__.DecorationSet.create(a.doc, [\n                prosemirror_view__WEBPACK_IMPORTED_MODULE_17__.Decoration.node(\n                  p.pos,\n                  p.pos + p.node.nodeSize,\n                  {\n                    nodeName: \"span\",\n                    class: \"suggestion-decorator\",\n                    \"data-decoration-id\": c\n                  }\n                )\n              ]);\n          }\n          return prosemirror_view__WEBPACK_IMPORTED_MODULE_17__.DecorationSet.create(a.doc, [\n            prosemirror_view__WEBPACK_IMPORTED_MODULE_17__.Decoration.inline(\n              h - m.length,\n              h,\n              {\n                nodeName: \"span\",\n                class: \"suggestion-decorator\",\n                \"data-decoration-id\": c\n              }\n            )\n          ]);\n        }\n      }\n    }),\n    itemCallback: (a) => {\n      l(n._tiptapEditor.view), n._tiptapEditor.chain().focus().deleteRange({\n        from: s.pluginState.queryStartPos - s.pluginState.triggerCharacter.length,\n        to: n._tiptapEditor.state.selection.from\n      }).run(), i({\n        item: a,\n        editor: n\n      });\n    }\n  };\n}, et = new prosemirror_state__WEBPACK_IMPORTED_MODULE_15__.PluginKey(\"SlashMenuPlugin\");\nclass Ze extends $ {\n  constructor(e, o) {\n    super();\n    u(this, \"plugin\");\n    u(this, \"itemCallback\");\n    const r = Je(\n      e,\n      (i) => {\n        this.emit(\"update\", i);\n      },\n      et,\n      \"/\",\n      (i) => o.filter(\n        ({ name: s, aliases: l }) => s.toLowerCase().startsWith(i.toLowerCase()) || l && l.filter(\n          (a) => a.toLowerCase().startsWith(i.toLowerCase())\n        ).length !== 0\n      ),\n      ({ item: i, editor: s }) => i.execute(s)\n    );\n    this.plugin = r.plugin, this.itemCallback = r.itemCallback;\n  }\n  onUpdate(e) {\n    return this.on(\"update\", e);\n  }\n}\nconst Qe = new prosemirror_state__WEBPACK_IMPORTED_MODULE_15__.PluginKey(\"blocknote-placeholder\"), to = _tiptap_core__WEBPACK_IMPORTED_MODULE_13__.Extension.create({\n  name: \"placeholder\",\n  addOptions() {\n    return {\n      emptyEditorClass: \"is-editor-empty\",\n      emptyNodeClass: \"is-empty\",\n      isFilterClass: \"is-filter\",\n      hasAnchorClass: \"has-anchor\",\n      placeholder: \"Write something …\",\n      showOnlyWhenEditable: !0,\n      showOnlyCurrent: !0,\n      includeChildren: !1\n    };\n  },\n  addProseMirrorPlugins() {\n    return [\n      new prosemirror_state__WEBPACK_IMPORTED_MODULE_15__.Plugin({\n        key: Qe,\n        props: {\n          decorations: (n) => {\n            const { doc: t, selection: e } = n, o = et.getState(n), r = this.editor.isEditable || !this.options.showOnlyWhenEditable, { anchor: i } = e, s = [];\n            if (r)\n              return t.descendants((l, a) => {\n                const d = i >= a && i <= a + l.nodeSize, c = !l.isLeaf && !l.childCount;\n                if ((d || !this.options.showOnlyCurrent) && c) {\n                  const h = [this.options.emptyNodeClass];\n                  this.editor.isEmpty && h.push(this.options.emptyEditorClass), d && h.push(this.options.hasAnchorClass), (o == null ? void 0 : o.triggerCharacter) === \"\" && (o != null && o.active) && h.push(this.options.isFilterClass);\n                  const m = prosemirror_view__WEBPACK_IMPORTED_MODULE_17__.Decoration.node(a, a + l.nodeSize, {\n                    class: h.join(\" \")\n                  });\n                  s.push(m);\n                }\n                return this.options.includeChildren;\n              }), prosemirror_view__WEBPACK_IMPORTED_MODULE_17__.DecorationSet.create(t, s);\n          }\n        }\n      })\n    ];\n  }\n}), eo = _tiptap_core__WEBPACK_IMPORTED_MODULE_13__.Extension.create({\n  name: \"textAlignment\",\n  addGlobalAttributes() {\n    return [\n      {\n        // Attribute is applied to block content instead of container so that child blocks don't inherit the text\n        // alignment styling.\n        types: [\"paragraph\", \"heading\", \"bulletListItem\", \"numberedListItem\"],\n        attributes: {\n          textAlignment: {\n            default: \"left\",\n            parseHTML: (n) => n.getAttribute(\"data-text-alignment\"),\n            renderHTML: (n) => n.textAlignment !== \"left\" && {\n              \"data-text-alignment\": n.textAlignment\n            }\n          }\n        }\n      }\n    ];\n  },\n  addCommands() {\n    return {\n      setTextAlignment: (n) => ({ state: t }) => {\n        const e = [], o = v(\n          t.doc,\n          t.selection.from\n        );\n        if (o === void 0)\n          return !1;\n        let r = o.startPos;\n        for (; r < t.selection.to; )\n          t.doc.resolve(r).node().type.spec.group === \"blockContent\" ? (e.push(r - 1), r += t.doc.resolve(r).node().nodeSize - 1) : r += 1;\n        for (const i of e)\n          t.tr.setNodeAttribute(i, \"textAlignment\", n);\n        return !0;\n      }\n    };\n  }\n}), oo = _tiptap_core__WEBPACK_IMPORTED_MODULE_13__.Extension.create({\n  name: \"blockTextColor\",\n  addGlobalAttributes() {\n    return [\n      {\n        types: [\"blockContainer\"],\n        attributes: {\n          textColor: {\n            default: T.textColor.default,\n            parseHTML: (n) => n.hasAttribute(\"data-text-color\") ? n.getAttribute(\"data-text-color\") : T.textColor.default,\n            renderHTML: (n) => n.textColor !== T.textColor.default && {\n              \"data-text-color\": n.textColor\n            }\n          }\n        }\n      }\n    ];\n  },\n  addCommands() {\n    return {\n      setBlockTextColor: (n, t) => ({ state: e, view: o }) => {\n        const r = v(e.doc, n);\n        return r === void 0 ? !1 : (e.tr.setNodeAttribute(r.startPos - 1, \"textColor\", t), o.focus(), !0);\n      }\n    };\n  }\n}), no = _tiptap_core__WEBPACK_IMPORTED_MODULE_13__.Mark.create({\n  name: \"textColor\",\n  addAttributes() {\n    return {\n      color: {\n        default: void 0,\n        parseHTML: (n) => n.getAttribute(\"data-text-color\"),\n        renderHTML: (n) => ({\n          \"data-text-color\": n.color\n        })\n      }\n    };\n  },\n  parseHTML() {\n    return [\n      {\n        tag: \"span\",\n        getAttrs: (n) => typeof n == \"string\" ? !1 : n.hasAttribute(\"data-text-color\") ? { color: n.getAttribute(\"data-text-color\") } : !1\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes: n }) {\n    return [\"span\", n, 0];\n  },\n  addCommands() {\n    return {\n      setTextColor: (n) => ({ commands: t }) => n !== T.textColor.default ? t.setMark(this.name, { color: n }) : t.unsetMark(this.name)\n    };\n  }\n}), ro = _tiptap_core__WEBPACK_IMPORTED_MODULE_13__.Extension.create({\n  name: \"trailingNode\",\n  addProseMirrorPlugins() {\n    const n = new prosemirror_state__WEBPACK_IMPORTED_MODULE_15__.PluginKey(this.name);\n    return [\n      new prosemirror_state__WEBPACK_IMPORTED_MODULE_15__.Plugin({\n        key: n,\n        appendTransaction: (t, e, o) => {\n          const { doc: r, tr: i, schema: s } = o, l = n.getState(o), a = r.content.size - 2, d = s.nodes.blockContainer, c = s.nodes.paragraph;\n          if (l)\n            return i.insert(\n              a,\n              d.create(void 0, c.create())\n            );\n        },\n        state: {\n          init: (t, e) => {\n          },\n          apply: (t, e) => {\n            if (!t.docChanged)\n              return e;\n            let o = t.doc.lastChild;\n            if (!o || o.type.name !== \"blockGroup\")\n              throw new Error(\"Expected blockGroup\");\n            if (o = o.lastChild, !o || o.type.name !== \"blockContainer\")\n              throw new Error(\"Expected blockContainer\");\n            const r = o.firstChild;\n            if (!r)\n              throw new Error(\"Expected blockContent\");\n            return o.nodeSize > 4 || r.type.spec.content !== \"inline*\";\n          }\n        }\n      })\n    ];\n  }\n}), io = (n) => {\n  var e;\n  const t = [\n    _tiptap_core__WEBPACK_IMPORTED_MODULE_13__.extensions.ClipboardTextSerializer,\n    _tiptap_core__WEBPACK_IMPORTED_MODULE_13__.extensions.Commands,\n    _tiptap_core__WEBPACK_IMPORTED_MODULE_13__.extensions.Editable,\n    _tiptap_core__WEBPACK_IMPORTED_MODULE_13__.extensions.FocusEvents,\n    _tiptap_core__WEBPACK_IMPORTED_MODULE_13__.extensions.Tabindex,\n    // DevTools,\n    _tiptap_extension_gapcursor__WEBPACK_IMPORTED_MODULE_5__.Gapcursor,\n    // DropCursor,\n    to.configure({\n      emptyNodeClass: k.isEmpty,\n      hasAnchorClass: k.hasAnchor,\n      isFilterClass: k.isFilter,\n      includeChildren: !0,\n      showOnlyCurrent: !1\n    }),\n    X.configure({\n      types: [\"blockContainer\"]\n    }),\n    _tiptap_extension_hard_break__WEBPACK_IMPORTED_MODULE_6__.HardBreak,\n    // Comments,\n    // basics:\n    _tiptap_extension_text__WEBPACK_IMPORTED_MODULE_11__.Text,\n    // marks:\n    _tiptap_extension_bold__WEBPACK_IMPORTED_MODULE_0__.Bold,\n    _tiptap_extension_code__WEBPACK_IMPORTED_MODULE_1__.Code,\n    _tiptap_extension_italic__WEBPACK_IMPORTED_MODULE_8__.Italic,\n    _tiptap_extension_strike__WEBPACK_IMPORTED_MODULE_10__.Strike,\n    _tiptap_extension_underline__WEBPACK_IMPORTED_MODULE_12__.Underline,\n    _tiptap_extension_link__WEBPACK_IMPORTED_MODULE_9__.Link,\n    no,\n    oo,\n    He,\n    Ae,\n    eo,\n    // nodes\n    je,\n    We.configure({\n      domAttributes: n.domAttributes\n    }),\n    Ge.configure({\n      domAttributes: n.domAttributes\n    }),\n    ...Object.values(n.blockSchema).map(\n      (o) => o.node.configure({\n        editor: n.editor,\n        domAttributes: n.domAttributes\n      })\n    ),\n    Xe,\n    _tiptap_extension_dropcursor__WEBPACK_IMPORTED_MODULE_4__.Dropcursor.configure({ width: 5, color: \"#ddeeff\" }),\n    // This needs to be at the bottom of this list, because Key events (such as enter, when selecting a /command),\n    // should be handled before Enter handlers in other components like splitListItem\n    ro\n  ];\n  if (n.collaboration) {\n    if (t.push(\n      _tiptap_extension_collaboration__WEBPACK_IMPORTED_MODULE_2__[\"default\"].configure({\n        fragment: n.collaboration.fragment\n      })\n    ), (e = n.collaboration.provider) != null && e.awareness) {\n      const o = (r) => {\n        const i = document.createElement(\"span\");\n        i.classList.add(R[\"collaboration-cursor__caret\"]), i.setAttribute(\"style\", `border-color: ${r.color}`);\n        const s = document.createElement(\"span\");\n        s.classList.add(R[\"collaboration-cursor__label\"]), s.setAttribute(\"style\", `background-color: ${r.color}`), s.insertBefore(document.createTextNode(r.name), null);\n        const l = document.createTextNode(\"⁠\"), a = document.createTextNode(\"⁠\");\n        return i.insertBefore(l, null), i.insertBefore(s, null), i.insertBefore(a, null), i;\n      };\n      t.push(\n        _tiptap_extension_collaboration_cursor__WEBPACK_IMPORTED_MODULE_3__[\"default\"].configure({\n          user: n.collaboration.user,\n          render: n.collaboration.renderCursor || o,\n          provider: n.collaboration.provider\n        })\n      );\n    }\n  } else\n    t.push(_tiptap_extension_history__WEBPACK_IMPORTED_MODULE_7__.History);\n  return t;\n};\nfunction ot(n, t) {\n  let e, o;\n  if (t.firstChild.descendants((r, i) => e ? !1 : r.type.name !== \"blockContainer\" || r.attrs.id !== n ? !0 : (e = r, o = i + 1, !1)), e === void 0 || o === void 0)\n    throw Error(\"Could not find block in the editor with matching ID.\");\n  return {\n    node: e,\n    posBeforeNode: o\n  };\n}\nfunction Ft(n, t, e = \"before\", o) {\n  const r = typeof t == \"string\" ? t : t.id, i = [];\n  for (const d of n)\n    i.push(F(d, o.schema));\n  let s = -1;\n  const { node: l, posBeforeNode: a } = ot(r, o.state.doc);\n  if (e === \"before\" && (s = a), e === \"after\" && (s = a + l.nodeSize), e === \"nested\") {\n    if (l.childCount < 2) {\n      s = a + l.firstChild.nodeSize + 1;\n      const d = o.state.schema.nodes.blockGroup.create(\n        {},\n        i\n      );\n      o.view.dispatch(\n        o.state.tr.insert(s, d)\n      );\n      return;\n    }\n    s = a + l.firstChild.nodeSize + 2;\n  }\n  o.view.dispatch(o.state.tr.insert(s, i));\n}\nfunction so(n, t, e) {\n  const o = typeof n == \"string\" ? n : n.id, { posBeforeNode: r } = ot(o, e.state.doc);\n  e.commands.BNUpdateBlock(r + 1, t);\n}\nfunction $t(n, t) {\n  const e = new Set(\n    n.map(\n      (r) => typeof r == \"string\" ? r : r.id\n    )\n  );\n  let o = 0;\n  if (t.state.doc.descendants((r, i) => {\n    if (e.size === 0)\n      return !1;\n    if (r.type.name !== \"blockContainer\" || !e.has(r.attrs.id))\n      return !0;\n    e.delete(r.attrs.id);\n    const s = t.state.doc.nodeSize;\n    t.commands.BNDeleteBlock(i - o + 1);\n    const l = t.state.doc.nodeSize;\n    return o += s - l, !1;\n  }), e.size > 0) {\n    const r = [...e].join(`\n`);\n    throw Error(\n      \"Blocks with the following IDs could not be found in the editor: \" + r\n    );\n  }\n}\nfunction ao(n, t, e) {\n  Ft(t, n[0], \"before\", e), $t(n, e);\n}\nfunction lo() {\n  const n = (t) => {\n    let e = t.children.length;\n    for (let o = 0; o < e; o++) {\n      const r = t.children[o];\n      if (r.type === \"element\" && (n(r), r.tagName === \"u\"))\n        if (r.children.length > 0) {\n          t.children.splice(o, 1, ...r.children);\n          const i = r.children.length - 1;\n          e += i, o += i;\n        } else\n          t.children.splice(o, 1), e--, o--;\n    }\n  };\n  return n;\n}\nfunction co(n) {\n  const t = /* @__PURE__ */ new Set([\n    ...n.orderedListItemBlockTypes,\n    ...n.unorderedListItemBlockTypes\n  ]), e = (o) => {\n    let r = o.children.length, i;\n    for (let s = 0; s < r; s++) {\n      const a = o.children[s].children[0], d = a.children[0], c = a.children.length === 2 ? a.children[1] : null, h = t.has(\n        d.properties.dataContentType\n      ), m = h ? n.orderedListItemBlockTypes.has(\n        d.properties.dataContentType\n      ) ? \"ol\" : \"ul\" : null;\n      if (c !== null && e(c), i && i.tagName !== m) {\n        o.children.splice(\n          s - i.children.length,\n          i.children.length,\n          i\n        );\n        const p = i.children.length - 1;\n        s -= p, r -= p, i = void 0;\n      }\n      if (h) {\n        i || (i = (0,hast_util_from_dom__WEBPACK_IMPORTED_MODULE_18__.fromDom)(\n          document.createElement(m)\n        ));\n        const p = (0,hast_util_from_dom__WEBPACK_IMPORTED_MODULE_18__.fromDom)(\n          document.createElement(\"li\")\n        );\n        p.children.push(d.children[0]), c !== null && p.children.push(...c.children), i.children.push(p);\n      } else if (c !== null) {\n        o.children.splice(s + 1, 0, ...c.children), o.children[s] = d.children[0];\n        const p = c.children.length;\n        s += p, r += p;\n      } else\n        o.children[s] = d.children[0];\n    }\n    i && o.children.splice(\n      r - i.children.length,\n      i.children.length,\n      i\n    );\n  };\n  return e;\n}\nasync function Wt(n, t) {\n  const e = document.createElement(\"div\"), o = prosemirror_model__WEBPACK_IMPORTED_MODULE_16__.DOMSerializer.fromSchema(t);\n  for (const i of n) {\n    const s = F(i, t), l = o.serializeNode(s);\n    e.appendChild(l);\n  }\n  return (await (0,unified__WEBPACK_IMPORTED_MODULE_19__.unified)().use(rehype_parse__WEBPACK_IMPORTED_MODULE_20__[\"default\"], { fragment: !0 }).use(co, {\n    orderedListItemBlockTypes: /* @__PURE__ */ new Set([\"numberedListItem\"]),\n    unorderedListItemBlockTypes: /* @__PURE__ */ new Set([\"bulletListItem\"])\n  }).use(rehype_stringify__WEBPACK_IMPORTED_MODULE_21__[\"default\"]).process(e.innerHTML)).value;\n}\nasync function Gt(n, t, e) {\n  const o = document.createElement(\"div\");\n  o.innerHTML = n.trim();\n  const i = prosemirror_model__WEBPACK_IMPORTED_MODULE_16__.DOMParser.fromSchema(e).parse(o), s = [];\n  for (let l = 0; l < i.firstChild.childCount; l++)\n    s.push(A(i.firstChild.child(l), t));\n  return s;\n}\nasync function uo(n, t) {\n  return (await (0,unified__WEBPACK_IMPORTED_MODULE_19__.unified)().use(rehype_parse__WEBPACK_IMPORTED_MODULE_20__[\"default\"], { fragment: !0 }).use(lo).use(rehype_remark__WEBPACK_IMPORTED_MODULE_22__[\"default\"]).use(remark_gfm__WEBPACK_IMPORTED_MODULE_23__[\"default\"]).use(remark_stringify__WEBPACK_IMPORTED_MODULE_24__[\"default\"]).process(await Wt(n, t))).value;\n}\nfunction po(n, t) {\n  const e = t.value ? t.value + `\n` : \"\", o = {};\n  t.lang && (o[\"data-language\"] = t.lang);\n  let r = {\n    type: \"element\",\n    tagName: \"code\",\n    properties: o,\n    children: [{ type: \"text\", value: e }]\n  };\n  return t.meta && (r.data = { meta: t.meta }), n.patch(t, r), r = n.applyData(t, r), r = {\n    type: \"element\",\n    tagName: \"pre\",\n    properties: {},\n    children: [r]\n  }, n.patch(t, r), r;\n}\nasync function ho(n, t, e) {\n  const o = await (0,unified__WEBPACK_IMPORTED_MODULE_19__.unified)().use(remark_parse__WEBPACK_IMPORTED_MODULE_25__[\"default\"]).use(remark_gfm__WEBPACK_IMPORTED_MODULE_23__[\"default\"]).use(remark_rehype__WEBPACK_IMPORTED_MODULE_26__[\"default\"], {\n    handlers: {\n      ...remark_rehype__WEBPACK_IMPORTED_MODULE_27__.handlers,\n      code: po\n    }\n  }).use(rehype_stringify__WEBPACK_IMPORTED_MODULE_21__[\"default\"]).process(n);\n  return Gt(o.value, t, e);\n}\nfunction ct(n) {\n  return \"data-\" + n.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\n}\nfunction mo(n) {\n  const t = {};\n  return Object.entries(n.propSchema).forEach(([e, o]) => {\n    t[e] = {\n      default: o.default,\n      keepOnSplit: !0,\n      // Props are displayed in kebab-case as HTML attributes. If a prop's\n      // value is the same as its default, we don't display an HTML\n      // attribute for it.\n      parseHTML: (r) => {\n        const i = r.getAttribute(ct(e));\n        if (i === null)\n          return null;\n        if (typeof o.default == \"boolean\")\n          return i === \"true\" ? !0 : i === \"false\" ? !1 : null;\n        if (typeof o.default == \"number\") {\n          const s = parseFloat(i);\n          return !Number.isNaN(s) && Number.isFinite(s) ? s : null;\n        }\n        return i;\n      },\n      renderHTML: (r) => r[e] !== o.default ? {\n        [ct(e)]: r[e]\n      } : {}\n    };\n  }), t;\n}\nfunction fo(n) {\n  return [\n    {\n      tag: \"div[data-content-type=\" + n.type + \"]\"\n    }\n  ];\n}\nfunction go(n, t) {\n  const e = document.createElement(\"div\");\n  e.setAttribute(\"data-content-type\", n.type);\n  for (const [r, i] of Object.entries(t))\n    e.setAttribute(r, i);\n  let o;\n  return n.containsInlineContent ? (o = document.createElement(\"div\"), e.appendChild(o)) : o = void 0, o !== void 0 ? {\n    dom: e,\n    contentDOM: o\n  } : {\n    dom: e\n  };\n}\nfunction ko(n) {\n  return {\n    node: W({\n      name: n.type,\n      content: n.containsInlineContent ? \"inline*\" : \"\",\n      selectable: !0,\n      addAttributes() {\n        return mo(n);\n      },\n      parseHTML() {\n        return fo(n);\n      },\n      renderHTML({ HTMLAttributes: e }) {\n        return go(n, e);\n      },\n      addNodeView() {\n        return ({ HTMLAttributes: e, getPos: o }) => {\n          var p, f;\n          const r = document.createElement(\"div\"), i = ((p = this.options.domAttributes) == null ? void 0 : p.blockContent) || {};\n          for (const [b, w] of Object.entries(\n            i\n          ))\n            b !== \"class\" && r.setAttribute(b, w);\n          r.className = B(\n            k.blockContent,\n            i.class\n          ), r.setAttribute(\"data-content-type\", n.type);\n          for (const [b, w] of Object.entries(e))\n            r.setAttribute(b, w);\n          const s = this.options.editor;\n          if (typeof o == \"boolean\")\n            throw new Error(\n              \"Cannot find node position as getPos is a boolean, not a function.\"\n            );\n          const l = o(), c = s._tiptapEditor.state.doc.resolve(l).node().attrs.id, h = s.getBlock(c);\n          if (h.type !== n.type)\n            throw new Error(\"Block type does not match\");\n          const m = n.render(h, s);\n          if (n.containsInlineContent) {\n            const b = m.contentDOM, w = ((f = this.options.domAttributes) == null ? void 0 : f.inlineContent) || {};\n            for (const [C, M] of Object.entries(\n              w\n            ))\n              C !== \"class\" && b.setAttribute(C, M);\n            b.className = B(\n              b.className,\n              k.inlineContent,\n              w.class\n            );\n          }\n          return r.appendChild(m.dom), \"contentDOM\" in m ? {\n            dom: r,\n            contentDOM: m.contentDOM,\n            destroy: m.destroy\n          } : {\n            dom: r,\n            destroy: m.destroy\n          };\n        };\n      }\n    }),\n    propSchema: n.propSchema\n  };\n}\nfunction W(n) {\n  return _tiptap_core__WEBPACK_IMPORTED_MODULE_13__.Node.create({\n    ...n,\n    group: \"blockContent\",\n    content: n.content\n  });\n}\nconst bo = {\n  ...T,\n  level: { default: 1, values: [1, 2, 3] }\n}, yo = W({\n  name: \"heading\",\n  content: \"inline*\",\n  addAttributes() {\n    return {\n      level: {\n        default: 1,\n        // instead of \"level\" attributes, use \"data-level\"\n        parseHTML: (n) => n.getAttribute(\"data-level\"),\n        renderHTML: (n) => ({\n          \"data-level\": n.level.toString()\n        })\n      }\n    };\n  },\n  addInputRules() {\n    return [\n      ...[1, 2, 3].map((n) => new _tiptap_core__WEBPACK_IMPORTED_MODULE_13__.InputRule({\n        find: new RegExp(`^(#{${n}})\\\\s$`),\n        handler: ({ state: t, chain: e, range: o }) => {\n          e().BNUpdateBlock(t.selection.from, {\n            type: \"heading\",\n            props: {\n              level: n\n            }\n          }).deleteRange({ from: o.from, to: o.to });\n        }\n      }))\n    ];\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Alt-1\": () => this.editor.commands.BNUpdateBlock(this.editor.state.selection.anchor, {\n        type: \"heading\",\n        props: {\n          level: 1\n        }\n      }),\n      \"Mod-Alt-2\": () => this.editor.commands.BNUpdateBlock(this.editor.state.selection.anchor, {\n        type: \"heading\",\n        props: {\n          level: 2\n        }\n      }),\n      \"Mod-Alt-3\": () => this.editor.commands.BNUpdateBlock(this.editor.state.selection.anchor, {\n        type: \"heading\",\n        props: {\n          level: 3\n        }\n      })\n    };\n  },\n  parseHTML() {\n    return [\n      {\n        tag: \"h1\",\n        attrs: { level: 1 },\n        node: \"heading\"\n      },\n      {\n        tag: \"h2\",\n        attrs: { level: 2 },\n        node: \"heading\"\n      },\n      {\n        tag: \"h3\",\n        attrs: { level: 3 },\n        node: \"heading\"\n      }\n    ];\n  },\n  renderHTML({ node: n, HTMLAttributes: t }) {\n    var r, i;\n    const e = ((r = this.options.domAttributes) == null ? void 0 : r.blockContent) || {}, o = ((i = this.options.domAttributes) == null ? void 0 : i.inlineContent) || {};\n    return [\n      \"div\",\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_13__.mergeAttributes)(t, {\n        ...e,\n        class: B(\n          k.blockContent,\n          e.class\n        ),\n        \"data-content-type\": this.name\n      }),\n      [\n        `h${n.attrs.level}`,\n        {\n          ...o,\n          class: B(\n            k.inlineContent,\n            o.class\n          )\n        },\n        0\n      ]\n    ];\n  }\n}), vo = {\n  node: yo,\n  propSchema: bo\n}, jt = (n) => {\n  const { node: t, contentType: e } = v(\n    n.state.doc,\n    n.state.selection.from\n  ), o = n.state.selection.anchor === n.state.selection.head;\n  return !e.name.endsWith(\"ListItem\") || !o ? !1 : n.commands.first(({ state: r, chain: i, commands: s }) => [\n    () => (\n      // Changes list item block to a text block if the content is empty.\n      s.command(() => t.textContent.length === 0 ? s.BNUpdateBlock(r.selection.from, {\n        type: \"paragraph\",\n        props: {}\n      }) : !1)\n    ),\n    () => (\n      // Splits the current block, moving content inside that's after the cursor to a new block of the same type\n      // below.\n      s.command(() => t.textContent.length > 0 ? (i().deleteSelection().BNSplitBlock(r.selection.from, !0).run(), !0) : !1)\n    )\n  ]);\n}, wo = {\n  ...T\n}, Co = W({\n  name: \"bulletListItem\",\n  content: \"inline*\",\n  addInputRules() {\n    return [\n      // Creates an unordered list when starting with \"-\", \"+\", or \"*\".\n      new _tiptap_core__WEBPACK_IMPORTED_MODULE_13__.InputRule({\n        find: new RegExp(\"^[-+*]\\\\s$\"),\n        handler: ({ state: n, chain: t, range: e }) => {\n          t().BNUpdateBlock(n.selection.from, {\n            type: \"bulletListItem\",\n            props: {}\n          }).deleteRange({ from: e.from, to: e.to });\n        }\n      })\n    ];\n  },\n  addKeyboardShortcuts() {\n    return {\n      Enter: () => jt(this.editor),\n      \"Mod-Shift-7\": () => this.editor.commands.BNUpdateBlock(this.editor.state.selection.anchor, {\n        type: \"bulletListItem\",\n        props: {}\n      })\n    };\n  },\n  parseHTML() {\n    return [\n      // Case for regular HTML list structure.\n      {\n        tag: \"li\",\n        getAttrs: (n) => {\n          if (typeof n == \"string\")\n            return !1;\n          const t = n.parentElement;\n          return t === null ? !1 : t.tagName === \"UL\" ? {} : !1;\n        },\n        node: \"bulletListItem\"\n      },\n      // Case for BlockNote list structure.\n      {\n        tag: \"p\",\n        getAttrs: (n) => {\n          if (typeof n == \"string\")\n            return !1;\n          const t = n.parentElement;\n          return t === null ? !1 : t.getAttribute(\"data-content-type\") === \"bulletListItem\" ? {} : !1;\n        },\n        priority: 300,\n        node: \"bulletListItem\"\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes: n }) {\n    var o, r;\n    const t = ((o = this.options.domAttributes) == null ? void 0 : o.blockContent) || {}, e = ((r = this.options.domAttributes) == null ? void 0 : r.inlineContent) || {};\n    return [\n      \"div\",\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_13__.mergeAttributes)(n, {\n        ...t,\n        class: B(\n          k.blockContent,\n          t.class\n        ),\n        \"data-content-type\": this.name\n      }),\n      [\n        \"p\",\n        {\n          ...e,\n          class: B(\n            k.inlineContent,\n            e.class\n          )\n        },\n        0\n      ]\n    ];\n  }\n}), Eo = {\n  node: Co,\n  propSchema: wo\n}, So = new prosemirror_state__WEBPACK_IMPORTED_MODULE_15__.PluginKey(\"numbered-list-indexing\"), Mo = () => new prosemirror_state__WEBPACK_IMPORTED_MODULE_15__.Plugin({\n  key: So,\n  appendTransaction: (n, t, e) => {\n    const o = e.tr;\n    o.setMeta(\"numberedListIndexing\", !0);\n    let r = !1;\n    return e.doc.descendants((i, s) => {\n      if (i.type.name === \"blockContainer\" && i.firstChild.type.name === \"numberedListItem\") {\n        let l = \"1\";\n        const a = s === 1, d = v(o.doc, s + 1);\n        if (d === void 0)\n          return;\n        if (!a) {\n          const m = v(o.doc, s - 2);\n          if (m === void 0)\n            return;\n          if (!(d.depth !== m.depth)) {\n            const f = m.contentNode;\n            if (m.contentType.name === \"numberedListItem\") {\n              const C = f.attrs.index;\n              l = (parseInt(C) + 1).toString();\n            }\n          }\n        }\n        d.contentNode.attrs.index !== l && (r = !0, o.setNodeMarkup(s + 1, void 0, {\n          index: l\n        }));\n      }\n    }), r ? o : null;\n  }\n}), To = {\n  ...T\n}, Bo = W({\n  name: \"numberedListItem\",\n  content: \"inline*\",\n  addAttributes() {\n    return {\n      index: {\n        default: null,\n        parseHTML: (n) => n.getAttribute(\"data-index\"),\n        renderHTML: (n) => ({\n          \"data-index\": n.index\n        })\n      }\n    };\n  },\n  addInputRules() {\n    return [\n      // Creates an ordered list when starting with \"1.\".\n      new _tiptap_core__WEBPACK_IMPORTED_MODULE_13__.InputRule({\n        find: new RegExp(\"^1\\\\.\\\\s$\"),\n        handler: ({ state: n, chain: t, range: e }) => {\n          t().BNUpdateBlock(n.selection.from, {\n            type: \"numberedListItem\",\n            props: {}\n          }).deleteRange({ from: e.from, to: e.to });\n        }\n      })\n    ];\n  },\n  addKeyboardShortcuts() {\n    return {\n      Enter: () => jt(this.editor),\n      \"Mod-Shift-8\": () => this.editor.commands.BNUpdateBlock(this.editor.state.selection.anchor, {\n        type: \"numberedListItem\",\n        props: {}\n      })\n    };\n  },\n  addProseMirrorPlugins() {\n    return [Mo()];\n  },\n  parseHTML() {\n    return [\n      // Case for regular HTML list structure.\n      // (e.g.: when pasting from other apps)\n      {\n        tag: \"li\",\n        getAttrs: (n) => {\n          if (typeof n == \"string\")\n            return !1;\n          const t = n.parentElement;\n          return t === null ? !1 : t.tagName === \"OL\" ? {} : !1;\n        },\n        node: \"numberedListItem\"\n      },\n      // Case for BlockNote list structure.\n      // (e.g.: when pasting from blocknote)\n      {\n        tag: \"p\",\n        getAttrs: (n) => {\n          if (typeof n == \"string\")\n            return !1;\n          const t = n.parentElement;\n          return t === null ? !1 : t.getAttribute(\"data-content-type\") === \"numberedListItem\" ? {} : !1;\n        },\n        priority: 300,\n        node: \"numberedListItem\"\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes: n }) {\n    var o, r;\n    const t = ((o = this.options.domAttributes) == null ? void 0 : o.blockContent) || {}, e = ((r = this.options.domAttributes) == null ? void 0 : r.inlineContent) || {};\n    return [\n      \"div\",\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_13__.mergeAttributes)(n, {\n        ...t,\n        class: B(\n          k.blockContent,\n          t.class\n        ),\n        \"data-content-type\": this.name\n      }),\n      // we use a <p> tag, because for <li> tags we'd need to add a <ul> parent for around siblings to be semantically correct,\n      // which would be quite cumbersome\n      [\n        \"p\",\n        {\n          ...e,\n          class: B(\n            k.inlineContent,\n            e.class\n          )\n        },\n        0\n      ]\n    ];\n  }\n}), xo = {\n  node: Bo,\n  propSchema: To\n}, Io = {\n  ...T\n}, _o = W({\n  name: \"paragraph\",\n  content: \"inline*\",\n  parseHTML() {\n    return [\n      {\n        tag: \"p\",\n        priority: 200,\n        node: \"paragraph\"\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes: n }) {\n    var o, r;\n    const t = ((o = this.options.domAttributes) == null ? void 0 : o.blockContent) || {}, e = ((r = this.options.domAttributes) == null ? void 0 : r.inlineContent) || {};\n    return [\n      \"div\",\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_13__.mergeAttributes)(\n        {\n          ...t,\n          class: B(\n            k.blockContent,\n            t.class\n          ),\n          \"data-content-type\": this.name\n        },\n        n\n      ),\n      [\n        \"p\",\n        {\n          ...e,\n          class: B(\n            k.inlineContent,\n            e.class\n          )\n        },\n        0\n      ]\n    ];\n  }\n}), Ao = {\n  node: _o,\n  propSchema: Io\n};\nclass Ho {\n  constructor(t, e, o) {\n    u(this, \"imageToolbarState\");\n    u(this, \"updateImageToolbar\");\n    u(this, \"prevWasEditable\", null);\n    u(this, \"shouldShow\", (t) => \"node\" in t.selection && t.selection.node.type.name === \"image\" && t.selection.node.attrs.src === \"\");\n    u(this, \"mouseDownHandler\", () => {\n      var t;\n      (t = this.imageToolbarState) != null && t.show && (this.imageToolbarState.show = !1, this.updateImageToolbar());\n    });\n    // For dragging the whole editor.\n    u(this, \"dragstartHandler\", () => {\n      var t;\n      (t = this.imageToolbarState) != null && t.show && (this.imageToolbarState.show = !1, this.updateImageToolbar());\n    });\n    u(this, \"blurHandler\", (t) => {\n      var o;\n      const e = this.pmView.dom.parentElement;\n      // An element is clicked.\n      t && t.relatedTarget && // Element is inside the editor.\n      (e === t.relatedTarget || e.contains(t.relatedTarget)) || (o = this.imageToolbarState) != null && o.show && (this.imageToolbarState.show = !1, this.updateImageToolbar());\n    });\n    u(this, \"scrollHandler\", () => {\n      var t;\n      if ((t = this.imageToolbarState) != null && t.show) {\n        const e = document.querySelector(\n          `[data-node-type=\"blockContainer\"][data-id=\"${this.imageToolbarState.block.id}\"]`\n        );\n        this.imageToolbarState.referencePos = e.getBoundingClientRect(), this.updateImageToolbar();\n      }\n    });\n    this.pluginKey = t, this.pmView = e, this.updateImageToolbar = () => {\n      if (!this.imageToolbarState)\n        throw new Error(\"Attempting to update uninitialized image toolbar\");\n      o(this.imageToolbarState);\n    }, e.dom.addEventListener(\"mousedown\", this.mouseDownHandler), e.dom.addEventListener(\"dragstart\", this.dragstartHandler), e.dom.addEventListener(\"blur\", this.blurHandler), document.addEventListener(\"scroll\", this.scrollHandler);\n  }\n  update(t, e) {\n    var r, i;\n    const o = this.pluginKey.getState(t.state);\n    if (!((r = this.imageToolbarState) != null && r.show) && o.block) {\n      const s = document.querySelector(\n        `[data-node-type=\"blockContainer\"][data-id=\"${o.block.id}\"]`\n      );\n      this.imageToolbarState = {\n        show: !0,\n        referencePos: s.getBoundingClientRect(),\n        block: o.block\n      }, this.updateImageToolbar();\n      return;\n    }\n    (!t.state.selection.eq(e.selection) || !t.state.doc.eq(e.doc)) && (i = this.imageToolbarState) != null && i.show && (this.imageToolbarState.show = !1, this.updateImageToolbar());\n  }\n  destroy() {\n    this.pmView.dom.removeEventListener(\"mousedown\", this.mouseDownHandler), this.pmView.dom.removeEventListener(\"dragstart\", this.dragstartHandler), this.pmView.dom.removeEventListener(\"blur\", this.blurHandler), document.removeEventListener(\"scroll\", this.scrollHandler);\n  }\n}\nconst U = new prosemirror_state__WEBPACK_IMPORTED_MODULE_15__.PluginKey(\"ImageToolbarPlugin\");\nclass Lo extends $ {\n  constructor(e) {\n    super();\n    u(this, \"view\");\n    u(this, \"plugin\");\n    this.plugin = new prosemirror_state__WEBPACK_IMPORTED_MODULE_15__.Plugin({\n      key: U,\n      view: (o) => (this.view = new Ho(\n        // editor,\n        U,\n        o,\n        (r) => {\n          this.emit(\"update\", r);\n        }\n      ), this.view),\n      state: {\n        init: () => ({\n          block: void 0\n        }),\n        apply: (o) => {\n          var i;\n          return {\n            block: (i = o.getMeta(U)) == null ? void 0 : i.block\n          };\n        }\n      }\n    });\n  }\n  onUpdate(e) {\n    return this.on(\"update\", e);\n  }\n}\nconst No = {\n  textAlignment: T.textAlignment,\n  backgroundColor: T.backgroundColor,\n  // Image url.\n  url: {\n    default: \"\"\n  },\n  // Image caption.\n  caption: {\n    default: \"\"\n  },\n  // Image width in px.\n  width: {\n    default: 512\n  }\n}, ut = (n) => {\n  switch (n) {\n    case \"left\":\n      return \"flex-start\";\n    case \"center\":\n      return \"center\";\n    case \"right\":\n      return \"flex-end\";\n    default:\n      return \"flex-start\";\n  }\n}, pt = 64, Po = (n, t) => {\n  const e = document.createElement(\"div\");\n  e.className = k.wrapper, e.style.alignItems = ut(\n    n.props.textAlignment\n  );\n  const o = document.createElement(\"div\");\n  o.className = k.addImageButton, o.style.display = n.props.url === \"\" ? \"\" : \"none\";\n  const r = document.createElement(\"div\");\n  r.className = k.addImageButtonIcon;\n  const i = document.createElement(\"p\");\n  i.className = k.addImageButtonText, i.innerText = \"Add Image\";\n  const s = document.createElement(\"div\");\n  s.className = k.imageAndCaptionWrapper, s.style.display = n.props.url !== \"\" ? \"\" : \"none\";\n  const l = document.createElement(\"div\");\n  l.className = k.imageWrapper, l.style.display = n.props.url !== \"\" ? \"\" : \"none\";\n  const a = document.createElement(\"img\");\n  a.className = k.image, a.src = n.props.url, a.alt = \"placeholder\", a.contentEditable = \"false\", a.draggable = !1, a.style.width = `${Math.min(\n    n.props.width,\n    t.domElement.firstElementChild.clientWidth\n  )}px`;\n  const d = document.createElement(\"div\");\n  d.className = k.resizeHandle, d.style.left = \"4px\";\n  const c = document.createElement(\"div\");\n  c.className = k.resizeHandle, c.style.right = \"4px\";\n  const h = document.createElement(\"p\");\n  h.className = k.caption, h.innerText = n.props.caption, h.style.padding = n.props.caption ? \"4px\" : \"\";\n  const m = () => {\n    var nt;\n    const g = ((nt = t.getSelection()) == null ? void 0 : nt.blocks) || [];\n    [t.getTextCursorPosition().block, ...g].find(\n      (Yt) => Yt.id === n.id\n    ) !== void 0 ? (o.style.outline = \"4px solid rgb(100, 160, 255)\", s.style.outline = \"4px solid rgb(100, 160, 255)\") : (o.style.outline = \"\", s.style.outline = \"\");\n  };\n  t.onEditorContentChange(m), t.onEditorSelectionChange(m);\n  let p;\n  const f = (g) => {\n    if (!p)\n      return;\n    let x;\n    ut(n.props.textAlignment) === \"center\" ? p.handleUsed === \"left\" ? x = p.initialWidth + (p.initialClientX - g.clientX) * 2 : x = p.initialWidth + (g.clientX - p.initialClientX) * 2 : p.handleUsed === \"left\" ? x = p.initialWidth + p.initialClientX - g.clientX : x = p.initialWidth + g.clientX - p.initialClientX, x < pt ? a.style.width = `${pt}px` : x > t.domElement.firstElementChild.clientWidth ? a.style.width = `${t.domElement.firstElementChild.clientWidth}px` : a.style.width = `${x}px`;\n  }, b = (g) => {\n    p && ((!g.target || !l.contains(g.target)) && l.contains(d) && l.contains(c) && (d.style.display = \"none\", c.style.display = \"none\"), p = void 0, t.updateBlock(n, {\n      type: \"image\",\n      props: {\n        // Removes \"px\" from the end of the width string and converts to float.\n        width: parseFloat(a.style.width.slice(0, -2))\n      }\n    }));\n  }, w = (g) => {\n    g.preventDefault();\n  }, C = () => {\n    t._tiptapEditor.view.dispatch(\n      t._tiptapEditor.state.tr.setMeta(U, {\n        block: n\n      })\n    );\n  }, M = () => {\n    t.isEditable ? (d.style.display = \"block\", c.style.display = \"block\") : (d.style.display = \"none\", c.style.display = \"none\");\n  }, E = (g) => {\n    g.relatedTarget === d || g.relatedTarget === c || p || (d.style.display = \"none\", c.style.display = \"none\");\n  }, y = (g) => {\n    g.preventDefault(), d.style.display = \"block\", c.style.display = \"block\", p = {\n      handleUsed: \"left\",\n      initialWidth: n.props.width,\n      initialClientX: g.clientX\n    };\n  }, S = (g) => {\n    g.preventDefault(), d.style.display = \"block\", c.style.display = \"block\", p = {\n      handleUsed: \"right\",\n      initialWidth: n.props.width,\n      initialClientX: g.clientX\n    };\n  };\n  return e.appendChild(o), o.appendChild(r), o.appendChild(i), e.appendChild(s), s.appendChild(l), l.appendChild(a), l.appendChild(d), l.appendChild(c), s.appendChild(h), window.addEventListener(\"mousemove\", f), window.addEventListener(\"mouseup\", b), o.addEventListener(\"mousedown\", w), o.addEventListener(\"click\", C), a.addEventListener(\"mouseenter\", M), a.addEventListener(\"mouseleave\", E), d.addEventListener(\n    \"mousedown\",\n    y\n  ), c.addEventListener(\n    \"mousedown\",\n    S\n  ), {\n    dom: e,\n    destroy: () => {\n      window.removeEventListener(\"mousemove\", f), window.removeEventListener(\"mouseup\", b), o.removeEventListener(\n        \"mousedown\",\n        w\n      ), o.removeEventListener(\"click\", C), d.removeEventListener(\n        \"mousedown\",\n        y\n      ), c.removeEventListener(\n        \"mousedown\",\n        S\n      );\n    }\n  };\n}, Do = ko({\n  type: \"image\",\n  propSchema: No,\n  containsInlineContent: !1,\n  render: Po\n}), qt = {\n  paragraph: Ao,\n  heading: vo,\n  bulletListItem: Eo,\n  numberedListItem: xo,\n  image: Do\n};\nclass Oo {\n  constructor(t, e, o) {\n    u(this, \"formattingToolbarState\");\n    u(this, \"updateFormattingToolbar\");\n    u(this, \"preventHide\", !1);\n    u(this, \"preventShow\", !1);\n    u(this, \"prevWasEditable\", null);\n    u(this, \"shouldShow\", ({ view: t, state: e, from: o, to: r }) => {\n      const { doc: i, selection: s } = e, { empty: l } = s, a = !i.textBetween(o, r).length && (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_13__.isTextSelection)(e.selection);\n      return !(!t.hasFocus() || l || a);\n    });\n    u(this, \"viewMousedownHandler\", () => {\n      this.preventShow = !0;\n    });\n    u(this, \"viewMouseupHandler\", () => {\n      this.preventShow = !1, setTimeout(() => this.update(this.pmView));\n    });\n    // For dragging the whole editor.\n    u(this, \"dragstartHandler\", () => {\n      var t;\n      (t = this.formattingToolbarState) != null && t.show && (this.formattingToolbarState.show = !1, this.updateFormattingToolbar());\n    });\n    u(this, \"focusHandler\", () => {\n      setTimeout(() => this.update(this.pmView));\n    });\n    u(this, \"blurHandler\", (t) => {\n      var o;\n      if (this.preventHide) {\n        this.preventHide = !1;\n        return;\n      }\n      const e = this.pmView.dom.parentElement;\n      // An element is clicked.\n      t && t.relatedTarget && // Element is inside the editor.\n      (e === t.relatedTarget || e.contains(t.relatedTarget)) || (o = this.formattingToolbarState) != null && o.show && (this.formattingToolbarState.show = !1, this.updateFormattingToolbar());\n    });\n    u(this, \"scrollHandler\", () => {\n      var t;\n      (t = this.formattingToolbarState) != null && t.show && (this.formattingToolbarState.referencePos = this.getSelectionBoundingBox(), this.updateFormattingToolbar());\n    });\n    this.editor = t, this.pmView = e, this.updateFormattingToolbar = () => {\n      if (!this.formattingToolbarState)\n        throw new Error(\n          \"Attempting to update uninitialized formatting toolbar\"\n        );\n      o(this.formattingToolbarState);\n    }, e.dom.addEventListener(\"mousedown\", this.viewMousedownHandler), e.dom.addEventListener(\"mouseup\", this.viewMouseupHandler), e.dom.addEventListener(\"dragstart\", this.dragstartHandler), e.dom.addEventListener(\"focus\", this.focusHandler), e.dom.addEventListener(\"blur\", this.blurHandler), document.addEventListener(\"scroll\", this.scrollHandler);\n  }\n  update(t, e) {\n    var m, p;\n    const { state: o, composing: r } = t, { doc: i, selection: s } = o, l = e && e.doc.eq(i) && e.selection.eq(s);\n    if ((this.prevWasEditable === null || this.prevWasEditable === this.editor.isEditable) && (r || l))\n      return;\n    this.prevWasEditable = this.editor.isEditable;\n    const { ranges: a } = s, d = Math.min(...a.map((f) => f.$from.pos)), c = Math.max(...a.map((f) => f.$to.pos)), h = (m = this.shouldShow) == null ? void 0 : m.call(this, {\n      view: t,\n      state: o,\n      from: d,\n      to: c\n    });\n    if (this.editor.isEditable && !this.preventShow && (h || this.preventHide)) {\n      this.formattingToolbarState = {\n        show: !0,\n        referencePos: this.getSelectionBoundingBox()\n      }, this.updateFormattingToolbar();\n      return;\n    }\n    if ((p = this.formattingToolbarState) != null && p.show && !this.preventHide && (!h || this.preventShow || !this.editor.isEditable)) {\n      this.formattingToolbarState.show = !1, this.updateFormattingToolbar();\n      return;\n    }\n  }\n  destroy() {\n    this.pmView.dom.removeEventListener(\"mousedown\", this.viewMousedownHandler), this.pmView.dom.removeEventListener(\"mouseup\", this.viewMouseupHandler), this.pmView.dom.removeEventListener(\"dragstart\", this.dragstartHandler), this.pmView.dom.removeEventListener(\"focus\", this.focusHandler), this.pmView.dom.removeEventListener(\"blur\", this.blurHandler), document.removeEventListener(\"scroll\", this.scrollHandler);\n  }\n  getSelectionBoundingBox() {\n    const { state: t } = this.pmView, { selection: e } = t, { ranges: o } = e, r = Math.min(...o.map((s) => s.$from.pos)), i = Math.max(...o.map((s) => s.$to.pos));\n    if ((0,_tiptap_core__WEBPACK_IMPORTED_MODULE_13__.isNodeSelection)(e)) {\n      const s = this.pmView.nodeDOM(r);\n      if (s)\n        return s.getBoundingClientRect();\n    }\n    return (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_13__.posToDOMRect)(this.pmView, r, i);\n  }\n}\nconst Ro = new prosemirror_state__WEBPACK_IMPORTED_MODULE_15__.PluginKey(\n  \"FormattingToolbarPlugin\"\n);\nclass zo extends $ {\n  constructor(e) {\n    super();\n    u(this, \"view\");\n    u(this, \"plugin\");\n    this.plugin = new prosemirror_state__WEBPACK_IMPORTED_MODULE_15__.Plugin({\n      key: Ro,\n      view: (o) => (this.view = new Oo(e, o, (r) => {\n        this.emit(\"update\", r);\n      }), this.view)\n    });\n  }\n  onUpdate(e) {\n    return this.on(\"update\", e);\n  }\n}\nclass Vo {\n  constructor(t, e, o) {\n    u(this, \"hyperlinkToolbarState\");\n    u(this, \"updateHyperlinkToolbar\");\n    u(this, \"menuUpdateTimer\");\n    u(this, \"startMenuUpdateTimer\");\n    u(this, \"stopMenuUpdateTimer\");\n    u(this, \"mouseHoveredHyperlinkMark\");\n    u(this, \"mouseHoveredHyperlinkMarkRange\");\n    u(this, \"keyboardHoveredHyperlinkMark\");\n    u(this, \"keyboardHoveredHyperlinkMarkRange\");\n    u(this, \"hyperlinkMark\");\n    u(this, \"hyperlinkMarkRange\");\n    u(this, \"mouseOverHandler\", (t) => {\n      if (this.mouseHoveredHyperlinkMark = void 0, this.mouseHoveredHyperlinkMarkRange = void 0, this.stopMenuUpdateTimer(), t.target instanceof HTMLAnchorElement && t.target.nodeName === \"A\") {\n        const e = t.target, o = this.pmView.posAtDOM(e, 0) + 1, r = this.pmView.state.doc.resolve(\n          o\n        ), i = r.marks();\n        for (const s of i)\n          if (s.type.name === this.pmView.state.schema.mark(\"link\").type.name) {\n            this.mouseHoveredHyperlinkMark = s, this.mouseHoveredHyperlinkMarkRange = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_13__.getMarkRange)(\n              r,\n              s.type,\n              s.attrs\n            ) || void 0;\n            break;\n          }\n      }\n      return this.startMenuUpdateTimer(), !1;\n    });\n    u(this, \"clickHandler\", (t) => {\n      var o;\n      const e = this.pmView.dom.parentElement;\n      // Toolbar is open.\n      this.hyperlinkMark && // An element is clicked.\n      t && t.target && // The clicked element is not the editor.\n      !(e === t.target || e.contains(t.target)) && (o = this.hyperlinkToolbarState) != null && o.show && (this.hyperlinkToolbarState.show = !1, this.updateHyperlinkToolbar());\n    });\n    u(this, \"scrollHandler\", () => {\n      var t;\n      this.hyperlinkMark !== void 0 && (t = this.hyperlinkToolbarState) != null && t.show && (this.hyperlinkToolbarState.referencePos = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_13__.posToDOMRect)(\n        this.pmView,\n        this.hyperlinkMarkRange.from,\n        this.hyperlinkMarkRange.to\n      ), this.updateHyperlinkToolbar());\n    });\n    this.editor = t, this.pmView = e, this.updateHyperlinkToolbar = () => {\n      if (!this.hyperlinkToolbarState)\n        throw new Error(\"Attempting to update uninitialized hyperlink toolbar\");\n      o(this.hyperlinkToolbarState);\n    }, this.startMenuUpdateTimer = () => {\n      this.menuUpdateTimer = setTimeout(() => {\n        this.update();\n      }, 250);\n    }, this.stopMenuUpdateTimer = () => (this.menuUpdateTimer && (clearTimeout(this.menuUpdateTimer), this.menuUpdateTimer = void 0), !1), this.pmView.dom.addEventListener(\"mouseover\", this.mouseOverHandler), document.addEventListener(\"click\", this.clickHandler, !0), document.addEventListener(\"scroll\", this.scrollHandler);\n  }\n  editHyperlink(t, e) {\n    var r;\n    const o = this.pmView.state.tr.insertText(\n      e,\n      this.hyperlinkMarkRange.from,\n      this.hyperlinkMarkRange.to\n    );\n    o.addMark(\n      this.hyperlinkMarkRange.from,\n      this.hyperlinkMarkRange.from + e.length,\n      this.pmView.state.schema.mark(\"link\", { href: t })\n    ), this.pmView.dispatch(o), this.pmView.focus(), (r = this.hyperlinkToolbarState) != null && r.show && (this.hyperlinkToolbarState.show = !1, this.updateHyperlinkToolbar());\n  }\n  deleteHyperlink() {\n    var t;\n    this.pmView.dispatch(\n      this.pmView.state.tr.removeMark(\n        this.hyperlinkMarkRange.from,\n        this.hyperlinkMarkRange.to,\n        this.hyperlinkMark.type\n      ).setMeta(\"preventAutolink\", !0)\n    ), this.pmView.focus(), (t = this.hyperlinkToolbarState) != null && t.show && (this.hyperlinkToolbarState.show = !1, this.updateHyperlinkToolbar());\n  }\n  update() {\n    var e;\n    if (!this.pmView.hasFocus())\n      return;\n    const t = this.hyperlinkMark;\n    if (this.hyperlinkMark = void 0, this.hyperlinkMarkRange = void 0, this.keyboardHoveredHyperlinkMark = void 0, this.keyboardHoveredHyperlinkMarkRange = void 0, this.pmView.state.selection.empty) {\n      const o = this.pmView.state.selection.$from.marks();\n      for (const r of o)\n        if (r.type.name === this.pmView.state.schema.mark(\"link\").type.name) {\n          this.keyboardHoveredHyperlinkMark = r, this.keyboardHoveredHyperlinkMarkRange = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_13__.getMarkRange)(\n            this.pmView.state.selection.$from,\n            r.type,\n            r.attrs\n          ) || void 0;\n          break;\n        }\n    }\n    if (this.mouseHoveredHyperlinkMark && (this.hyperlinkMark = this.mouseHoveredHyperlinkMark, this.hyperlinkMarkRange = this.mouseHoveredHyperlinkMarkRange), this.keyboardHoveredHyperlinkMark && (this.hyperlinkMark = this.keyboardHoveredHyperlinkMark, this.hyperlinkMarkRange = this.keyboardHoveredHyperlinkMarkRange), this.hyperlinkMark && this.editor.isEditable) {\n      this.hyperlinkToolbarState = {\n        show: !0,\n        referencePos: (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_13__.posToDOMRect)(\n          this.pmView,\n          this.hyperlinkMarkRange.from,\n          this.hyperlinkMarkRange.to\n        ),\n        url: this.hyperlinkMark.attrs.href,\n        text: this.pmView.state.doc.textBetween(\n          this.hyperlinkMarkRange.from,\n          this.hyperlinkMarkRange.to\n        )\n      }, this.updateHyperlinkToolbar();\n      return;\n    }\n    if ((e = this.hyperlinkToolbarState) != null && e.show && t && (!this.hyperlinkMark || !this.editor.isEditable)) {\n      this.hyperlinkToolbarState.show = !1, this.updateHyperlinkToolbar();\n      return;\n    }\n  }\n  destroy() {\n    this.pmView.dom.removeEventListener(\"mouseover\", this.mouseOverHandler), document.removeEventListener(\"scroll\", this.scrollHandler), document.removeEventListener(\"click\", this.clickHandler, !0);\n  }\n}\nconst Uo = new prosemirror_state__WEBPACK_IMPORTED_MODULE_15__.PluginKey(\n  \"HyperlinkToolbarPlugin\"\n);\nclass Fo extends $ {\n  constructor(e) {\n    super();\n    u(this, \"view\");\n    u(this, \"plugin\");\n    /**\n     * Edit the currently hovered hyperlink.\n     */\n    u(this, \"editHyperlink\", (e, o) => {\n      this.view.editHyperlink(e, o);\n    });\n    /**\n     * Delete the currently hovered hyperlink.\n     */\n    u(this, \"deleteHyperlink\", () => {\n      this.view.deleteHyperlink();\n    });\n    /**\n     * When hovering on/off hyperlinks using the mouse cursor, the hyperlink\n     * toolbar will open & close with a delay.\n     *\n     * This function starts the delay timer, and should be used for when the mouse cursor enters the hyperlink toolbar.\n     */\n    u(this, \"startHideTimer\", () => {\n      this.view.startMenuUpdateTimer();\n    });\n    /**\n     * When hovering on/off hyperlinks using the mouse cursor, the hyperlink\n     * toolbar will open & close with a delay.\n     *\n     * This function stops the delay timer, and should be used for when the mouse cursor exits the hyperlink toolbar.\n     */\n    u(this, \"stopHideTimer\", () => {\n      this.view.stopMenuUpdateTimer();\n    });\n    this.plugin = new prosemirror_state__WEBPACK_IMPORTED_MODULE_15__.Plugin({\n      key: Uo,\n      view: (o) => (this.view = new Vo(e, o, (r) => {\n        this.emit(\"update\", r);\n      }), this.view)\n    });\n  }\n  onUpdate(e) {\n    return this.on(\"update\", e);\n  }\n}\nclass z extends prosemirror_state__WEBPACK_IMPORTED_MODULE_15__.Selection {\n  constructor(e, o) {\n    super(e, o);\n    u(this, \"nodes\");\n    const r = e.node();\n    this.nodes = [], e.doc.nodesBetween(e.pos, o.pos, (i, s, l) => {\n      if (l !== null && l.eq(r))\n        return this.nodes.push(i), !1;\n    });\n  }\n  static create(e, o, r = o) {\n    return new z(e.resolve(o), e.resolve(r));\n  }\n  content() {\n    return new prosemirror_model__WEBPACK_IMPORTED_MODULE_16__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_16__.Fragment.from(this.nodes), 0, 0);\n  }\n  eq(e) {\n    if (!(e instanceof z) || this.nodes.length !== e.nodes.length || this.from !== e.from || this.to !== e.to)\n      return !1;\n    for (let o = 0; o < this.nodes.length; o++)\n      if (!this.nodes[o].eq(e.nodes[o]))\n        return !1;\n    return !0;\n  }\n  map(e, o) {\n    const r = o.mapResult(this.from), i = o.mapResult(this.to);\n    return i.deleted ? prosemirror_state__WEBPACK_IMPORTED_MODULE_15__.Selection.near(e.resolve(r.pos)) : r.deleted ? prosemirror_state__WEBPACK_IMPORTED_MODULE_15__.Selection.near(e.resolve(i.pos)) : new z(\n      e.resolve(r.pos),\n      e.resolve(i.pos)\n    );\n  }\n  toJSON() {\n    return { type: \"node\", anchor: this.anchor, head: this.head };\n  }\n}\nconst $o = prosemirror_view__WEBPACK_IMPORTED_MODULE_17__.__serializeForClipboard;\nlet H;\nfunction Xt(n, t) {\n  var r;\n  if (!t.dom.isConnected)\n    return;\n  const e = t.posAtCoords(n);\n  if (!e)\n    return;\n  let o = t.domAtPos(e.pos).node;\n  if (o !== t.dom) {\n    for (; o && o.parentNode && o.parentNode !== t.dom && !((r = o.hasAttribute) != null && r.call(o, \"data-id\")); )\n      o = o.parentNode;\n    if (o)\n      return { node: o, id: o.getAttribute(\"data-id\") };\n  }\n}\nfunction Wo(n, t) {\n  const e = Xt(n, t);\n  if (e && e.node.nodeType === 1) {\n    const o = t.docView, r = o.nearestDesc(e.node, !0);\n    return !r || r === o ? null : r.posBefore;\n  }\n  return null;\n}\nfunction Go(n, t) {\n  let e, o;\n  const r = t.resolve(n.from).node().type.spec.group === \"blockContent\", i = t.resolve(n.to).node().type.spec.group === \"blockContent\", s = Math.min(n.$anchor.depth, n.$head.depth);\n  if (r && i) {\n    const l = n.$from.start(s - 1), a = n.$to.end(s - 1);\n    e = t.resolve(l - 1).pos, o = t.resolve(a + 1).pos;\n  } else\n    e = n.from, o = n.to;\n  return { from: e, to: o };\n}\nfunction ht(n, t, e = t) {\n  t === e && (e += n.state.doc.resolve(t + 1).node().nodeSize);\n  const o = n.domAtPos(t).node.cloneNode(!0), r = n.domAtPos(t).node, i = (c, h) => Array.prototype.indexOf.call(c.children, h), s = i(\n    r,\n    // Expects from position to be just before the first selected block.\n    n.domAtPos(t + 1).node.parentElement\n  ), l = i(\n    r,\n    // Expects to position to be just after the last selected block.\n    n.domAtPos(e - 1).node.parentElement\n  );\n  for (let c = r.childElementCount - 1; c >= 0; c--)\n    (c > l || c < s) && o.removeChild(o.children[c]);\n  Kt(), H = o;\n  const d = n.dom.className.split(\" \").filter(\n    (c) => !c.includes(\"bn\") && !c.includes(\"ProseMirror\") && !c.includes(\"editor\")\n  ).join(\" \");\n  H.className = H.className + \" \" + R.dragPreview + \" \" + d, document.body.appendChild(H);\n}\nfunction Kt() {\n  H !== void 0 && (document.body.removeChild(H), H = void 0);\n}\nfunction jo(n, t) {\n  if (!n.dataTransfer)\n    return;\n  const e = t.dom.getBoundingClientRect(), o = {\n    left: e.left + e.width / 2,\n    // take middle of editor\n    top: n.clientY\n  }, r = Wo(o, t);\n  if (r != null) {\n    const i = t.state.selection, s = t.state.doc, { from: l, to: a } = Go(i, s), d = l <= r && r < a, c = i.$anchor.node() !== i.$head.node() || i instanceof z;\n    d && c ? (t.dispatch(\n      t.state.tr.setSelection(z.create(s, l, a))\n    ), ht(t, l, a)) : (t.dispatch(\n      t.state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_15__.NodeSelection.create(t.state.doc, r))\n    ), ht(t, r));\n    const h = t.state.selection.content(), { dom: m, text: p } = $o(t, h);\n    n.dataTransfer.clearData(), n.dataTransfer.setData(\"text/html\", m.innerHTML), n.dataTransfer.setData(\"text/plain\", p), n.dataTransfer.effectAllowed = \"move\", n.dataTransfer.setDragImage(H, 0, 0), t.dragging = { slice: h, move: !0 };\n  }\n}\nclass qo {\n  constructor(t, e, o) {\n    u(this, \"sideMenuState\");\n    // When true, the drag handle with be anchored at the same level as root elements\n    // When false, the drag handle with be just to the left of the element\n    // TODO: Is there any case where we want this to be false?\n    u(this, \"horizontalPosAnchoredAtRoot\");\n    u(this, \"horizontalPosAnchor\");\n    u(this, \"hoveredBlock\");\n    // Used to check if currently dragged content comes from this editor instance.\n    u(this, \"isDragging\", !1);\n    u(this, \"menuFrozen\", !1);\n    /**\n     * Sets isDragging when dragging text.\n     */\n    u(this, \"onDragStart\", () => {\n      this.isDragging = !0;\n    });\n    /**\n     * If the event is outside the editor contents,\n     * we dispatch a fake event, so that we can still drop the content\n     * when dragging / dropping to the side of the editor\n     */\n    u(this, \"onDrop\", (t) => {\n      if (this.editor._tiptapEditor.commands.blur(), t.synthetic || !this.isDragging)\n        return;\n      const e = this.pmView.posAtCoords({\n        left: t.clientX,\n        top: t.clientY\n      });\n      if (this.isDragging = !1, !e || e.inside === -1) {\n        const o = new Event(\"drop\", t), r = this.pmView.dom.firstChild.getBoundingClientRect();\n        o.clientX = r.left + r.width / 2, o.clientY = t.clientY, o.dataTransfer = t.dataTransfer, o.preventDefault = () => t.preventDefault(), o.synthetic = !0, this.pmView.dom.dispatchEvent(o);\n      }\n    });\n    /**\n     * If the event is outside the editor contents,\n     * we dispatch a fake event, so that we can still drop the content\n     * when dragging / dropping to the side of the editor\n     */\n    u(this, \"onDragOver\", (t) => {\n      if (t.synthetic || !this.isDragging)\n        return;\n      const e = this.pmView.posAtCoords({\n        left: t.clientX,\n        top: t.clientY\n      });\n      if (!e || e.inside === -1) {\n        const o = new Event(\"dragover\", t), r = this.pmView.dom.firstChild.getBoundingClientRect();\n        o.clientX = r.left + r.width / 2, o.clientY = t.clientY, o.dataTransfer = t.dataTransfer, o.preventDefault = () => t.preventDefault(), o.synthetic = !0, this.pmView.dom.dispatchEvent(o);\n      }\n    });\n    u(this, \"onKeyDown\", (t) => {\n      var e;\n      (e = this.sideMenuState) != null && e.show && (this.sideMenuState.show = !1, this.updateSideMenu(this.sideMenuState)), this.menuFrozen = !1;\n    });\n    u(this, \"onMouseDown\", (t) => {\n      this.sideMenuState && !this.sideMenuState.show && (this.sideMenuState.show = !0, this.updateSideMenu(this.sideMenuState)), this.menuFrozen = !1;\n    });\n    u(this, \"onMouseMove\", (t) => {\n      var d, c, h, m, p;\n      if (this.menuFrozen)\n        return;\n      const e = this.pmView.dom.firstChild.getBoundingClientRect(), o = this.pmView.dom.getBoundingClientRect(), r = t.clientX >= o.left && t.clientX <= o.right && t.clientY >= o.top && t.clientY <= o.bottom, i = this.pmView.dom.parentElement;\n      if (\n        // Cursor is within the editor area\n        r && // An element is hovered\n        t && t.target && // Element is outside the editor\n        !(i === t.target || i.contains(t.target))\n      ) {\n        (d = this.sideMenuState) != null && d.show && (this.sideMenuState.show = !1, this.updateSideMenu(this.sideMenuState));\n        return;\n      }\n      this.horizontalPosAnchor = e.x;\n      const s = {\n        left: e.left + e.width / 2,\n        // take middle of editor\n        top: t.clientY\n      }, l = Xt(s, this.pmView);\n      if (!l || !this.editor.isEditable) {\n        (c = this.sideMenuState) != null && c.show && (this.sideMenuState.show = !1, this.updateSideMenu(this.sideMenuState));\n        return;\n      }\n      if ((h = this.sideMenuState) != null && h.show && ((m = this.hoveredBlock) != null && m.hasAttribute(\"data-id\")) && ((p = this.hoveredBlock) == null ? void 0 : p.getAttribute(\"data-id\")) === l.id)\n        return;\n      this.hoveredBlock = l.node;\n      const a = l.node.firstChild;\n      if (a && this.editor.isEditable) {\n        const f = a.getBoundingClientRect();\n        this.sideMenuState = {\n          show: !0,\n          referencePos: new DOMRect(\n            this.horizontalPosAnchoredAtRoot ? this.horizontalPosAnchor : f.x,\n            f.y,\n            f.width,\n            f.height\n          ),\n          block: this.editor.getBlock(\n            this.hoveredBlock.getAttribute(\"data-id\")\n          )\n        }, this.updateSideMenu(this.sideMenuState);\n      }\n    });\n    u(this, \"onScroll\", () => {\n      var t;\n      if ((t = this.sideMenuState) != null && t.show) {\n        const o = this.hoveredBlock.firstChild.getBoundingClientRect();\n        this.sideMenuState.referencePos = new DOMRect(\n          this.horizontalPosAnchoredAtRoot ? this.horizontalPosAnchor : o.x,\n          o.y,\n          o.width,\n          o.height\n        ), this.updateSideMenu(this.sideMenuState);\n      }\n    });\n    this.editor = t, this.pmView = e, this.updateSideMenu = o, this.horizontalPosAnchoredAtRoot = !0, this.horizontalPosAnchor = this.pmView.dom.firstChild.getBoundingClientRect().x, document.body.addEventListener(\"drop\", this.onDrop, !0), document.body.addEventListener(\"dragover\", this.onDragOver), this.pmView.dom.addEventListener(\"dragstart\", this.onDragStart), document.body.addEventListener(\"mousemove\", this.onMouseMove, !0), document.addEventListener(\"scroll\", this.onScroll), document.body.addEventListener(\"mousedown\", this.onMouseDown, !0), document.body.addEventListener(\"keydown\", this.onKeyDown, !0);\n  }\n  destroy() {\n    var t;\n    (t = this.sideMenuState) != null && t.show && (this.sideMenuState.show = !1, this.updateSideMenu(this.sideMenuState)), document.body.removeEventListener(\"mousemove\", this.onMouseMove), document.body.removeEventListener(\"dragover\", this.onDragOver), this.pmView.dom.removeEventListener(\"dragstart\", this.onDragStart), document.body.removeEventListener(\"drop\", this.onDrop, !0), document.removeEventListener(\"scroll\", this.onScroll), document.body.removeEventListener(\"mousedown\", this.onMouseDown, !0), document.body.removeEventListener(\"keydown\", this.onKeyDown, !0);\n  }\n  addBlock() {\n    var l;\n    (l = this.sideMenuState) != null && l.show && (this.sideMenuState.show = !1, this.updateSideMenu(this.sideMenuState)), this.menuFrozen = !0;\n    const e = this.hoveredBlock.firstChild.getBoundingClientRect(), o = this.pmView.posAtCoords({\n      left: e.left + e.width / 2,\n      top: e.top + e.height / 2\n    });\n    if (!o)\n      return;\n    const r = v(\n      this.editor._tiptapEditor.state.doc,\n      o.pos\n    );\n    if (r === void 0)\n      return;\n    const { contentNode: i, endPos: s } = r;\n    if (i.textContent.length !== 0) {\n      const a = s + 1, d = a + 2;\n      this.editor._tiptapEditor.chain().BNCreateBlock(a).BNUpdateBlock(d, { type: \"paragraph\", props: {} }).setTextSelection(d).run();\n    } else\n      this.editor._tiptapEditor.commands.setTextSelection(s);\n    this.pmView.focus(), this.pmView.dispatch(\n      this.pmView.state.tr.scrollIntoView().setMeta(et, {\n        // TODO import suggestion plugin key\n        activate: !0,\n        type: \"drag\"\n      })\n    );\n  }\n}\nconst Xo = new prosemirror_state__WEBPACK_IMPORTED_MODULE_15__.PluginKey(\"SideMenuPlugin\");\nclass Ko extends $ {\n  constructor(e) {\n    super();\n    u(this, \"sideMenuView\");\n    u(this, \"plugin\");\n    /**\n     * If the block is empty, opens the slash menu. If the block has content,\n     * creates a new block below and opens the slash menu in it.\n     */\n    u(this, \"addBlock\", () => this.sideMenuView.addBlock());\n    /**\n     * Handles drag & drop events for blocks.\n     */\n    u(this, \"blockDragStart\", (e) => {\n      this.sideMenuView.isDragging = !0, jo(e, this.editor.prosemirrorView);\n    });\n    /**\n     * Handles drag & drop events for blocks.\n     */\n    u(this, \"blockDragEnd\", () => Kt());\n    /**\n     * Freezes the side menu. When frozen, the side menu will stay\n     * attached to the same block regardless of which block is hovered by the\n     * mouse cursor.\n     */\n    u(this, \"freezeMenu\", () => this.sideMenuView.menuFrozen = !0);\n    /**\n     * Unfreezes the side menu. When frozen, the side menu will stay\n     * attached to the same block regardless of which block is hovered by the\n     * mouse cursor.\n     */\n    u(this, \"unfreezeMenu\", () => this.sideMenuView.menuFrozen = !1);\n    this.editor = e, this.plugin = new prosemirror_state__WEBPACK_IMPORTED_MODULE_15__.Plugin({\n      key: Xo,\n      view: (o) => (this.sideMenuView = new qo(\n        e,\n        o,\n        (r) => {\n          this.emit(\"update\", r);\n        }\n      ), this.sideMenuView)\n    });\n  }\n  onUpdate(e) {\n    return this.on(\"update\", e);\n  }\n}\nfunction N(n, t) {\n  const e = n.getTextCursorPosition().block;\n  if (e.content === void 0)\n    throw new Error(\n      \"Slash Menu open in a block that doesn't contain inline content.\"\n    );\n  e.content.length === 1 && e.content[0].type === \"text\" && e.content[0].text === \"/\" || e.content.length === 0 ? n.updateBlock(e, t) : (n.insertBlocks([t], e, \"after\"), n.setTextCursorPosition(n.getTextCursorPosition().nextBlock));\n}\nconst Yo = (n = qt) => {\n  var e, o, r;\n  const t = [];\n  return \"heading\" in n && \"level\" in n.heading.propSchema && ((e = n.heading.propSchema.level.values) != null && e.includes(1) && t.push({\n    name: \"Heading\",\n    aliases: [\"h\", \"heading1\", \"h1\"],\n    execute: (i) => N(i, {\n      type: \"heading\",\n      props: { level: 1 }\n    })\n  }), (o = n.heading.propSchema.level.values) != null && o.includes(2) && t.push({\n    name: \"Heading 2\",\n    aliases: [\"h2\", \"heading2\", \"subheading\"],\n    execute: (i) => N(i, {\n      type: \"heading\",\n      props: { level: 2 }\n    })\n  }), (r = n.heading.propSchema.level.values) != null && r.includes(3) && t.push({\n    name: \"Heading 3\",\n    aliases: [\"h3\", \"heading3\", \"subheading\"],\n    execute: (i) => N(i, {\n      type: \"heading\",\n      props: { level: 3 }\n    })\n  })), \"bulletListItem\" in n && t.push({\n    name: \"Bullet List\",\n    aliases: [\"ul\", \"list\", \"bulletlist\", \"bullet list\"],\n    execute: (i) => N(i, {\n      type: \"bulletListItem\"\n    })\n  }), \"numberedListItem\" in n && t.push({\n    name: \"Numbered List\",\n    aliases: [\"li\", \"list\", \"numberedlist\", \"numbered list\"],\n    execute: (i) => N(i, {\n      type: \"numberedListItem\"\n    })\n  }), \"paragraph\" in n && t.push({\n    name: \"Paragraph\",\n    aliases: [\"p\"],\n    execute: (i) => N(i, {\n      type: \"paragraph\"\n    })\n  }), \"image\" in n && t.push({\n    name: \"Image\",\n    aliases: [\n      \"image\",\n      \"imageUpload\",\n      \"upload\",\n      \"img\",\n      \"picture\",\n      \"media\",\n      \"url\",\n      \"drive\",\n      \"dropbox\"\n    ],\n    execute: (i) => {\n      N(i, {\n        type: \"image\"\n      }), i.setTextCursorPosition(\n        i.getTextCursorPosition().nextBlock,\n        \"start\"\n      ), i._tiptapEditor.view.dispatch(\n        i._tiptapEditor.state.tr.setMeta(U, {\n          block: i.getTextCursorPosition().prevBlock\n        })\n      );\n    }\n  }), t;\n}, Jo = {\n  enableInputRules: !0,\n  enablePasteRules: !0,\n  enableCoreExtensions: !1\n};\nclass _n {\n  constructor(t = {}) {\n    u(this, \"_tiptapEditor\");\n    u(this, \"blockCache\", /* @__PURE__ */ new WeakMap());\n    u(this, \"schema\");\n    u(this, \"ready\", !1);\n    u(this, \"sideMenu\");\n    u(this, \"formattingToolbar\");\n    u(this, \"slashMenu\");\n    u(this, \"hyperlinkToolbar\");\n    u(this, \"imageToolbar\");\n    u(this, \"uploadFile\");\n    var l, a, d, c, h, m, p, f, b, w, C, M;\n    this.options = t;\n    const e = {\n      defaultStyles: !0,\n      // TODO: There's a lot of annoying typing stuff to deal with here. If\n      //  BSchema is specified, then options.blockSchema should also be required.\n      //  If BSchema is not specified, then options.blockSchema should also not\n      //  be defined. Unfortunately, trying to implement these constraints seems\n      //  to be a huge pain, hence the `as any` casts.\n      blockSchema: t.blockSchema || qt,\n      ...t\n    };\n    this.sideMenu = new Ko(this), this.formattingToolbar = new zo(this), this.slashMenu = new Ze(\n      this,\n      e.slashMenuItems || Yo(e.blockSchema)\n    ), this.hyperlinkToolbar = new Fo(this), this.imageToolbar = new Lo(this);\n    const o = io({\n      editor: this,\n      domAttributes: e.domAttributes || {},\n      blockSchema: e.blockSchema,\n      collaboration: e.collaboration\n    }), r = _tiptap_core__WEBPACK_IMPORTED_MODULE_13__.Extension.create({\n      name: \"BlockNoteUIExtension\",\n      addProseMirrorPlugins: () => [\n        this.sideMenu.plugin,\n        this.formattingToolbar.plugin,\n        this.slashMenu.plugin,\n        this.hyperlinkToolbar.plugin,\n        this.imageToolbar.plugin\n      ]\n    });\n    o.push(r), this.schema = e.blockSchema, this.uploadFile = e.uploadFile;\n    const i = e.initialContent || (t.collaboration ? void 0 : [\n      {\n        type: \"paragraph\",\n        id: X.options.generateID()\n      }\n    ]), s = {\n      ...Jo,\n      ...e._tiptapOptions,\n      onBeforeCreate(E) {\n        var g, x;\n        if ((x = (g = e._tiptapOptions) == null ? void 0 : g.onBeforeCreate) == null || x.call(g, E), !i)\n          return;\n        const y = E.editor.schema, S = y.node(\n          \"doc\",\n          void 0,\n          y.node(\"blockGroup\", void 0, [\n            F({ id: \"initialBlock\", type: \"paragraph\" }, y)\n          ])\n        );\n        E.editor.options.content = S.toJSON();\n      },\n      onCreate: (E) => {\n        var y, S, g;\n        (S = (y = e._tiptapOptions) == null ? void 0 : y.onCreate) == null || S.call(y, E), i !== void 0 && this.replaceBlocks(this.topLevelBlocks, i), (g = e.onEditorReady) == null || g.call(e, this), this.ready = !0;\n      },\n      onUpdate: (E) => {\n        var y, S, g;\n        (S = (y = e._tiptapOptions) == null ? void 0 : y.onUpdate) == null || S.call(y, E), this.ready && ((g = e.onEditorContentChange) == null || g.call(e, this));\n      },\n      onSelectionUpdate: (E) => {\n        var y, S, g;\n        (S = (y = e._tiptapOptions) == null ? void 0 : y.onSelectionUpdate) == null || S.call(y, E), this.ready && ((g = e.onTextCursorPositionChange) == null || g.call(e, this));\n      },\n      editable: t.editable !== void 0 ? t.editable : ((l = e._tiptapOptions) == null ? void 0 : l.editable) !== void 0 ? (a = e._tiptapOptions) == null ? void 0 : a.editable : !0,\n      extensions: e.enableBlockNoteExtensions === !1 ? ((d = e._tiptapOptions) == null ? void 0 : d.extensions) || [] : [...((c = e._tiptapOptions) == null ? void 0 : c.extensions) || [], ...o],\n      editorProps: {\n        ...(h = e._tiptapOptions) == null ? void 0 : h.editorProps,\n        attributes: {\n          ...(p = (m = e._tiptapOptions) == null ? void 0 : m.editorProps) == null ? void 0 : p.attributes,\n          ...(f = e.domAttributes) == null ? void 0 : f.editor,\n          class: B(\n            R.bnEditor,\n            R.bnRoot,\n            ((w = (b = e.domAttributes) == null ? void 0 : b.editor) == null ? void 0 : w.class) || \"\",\n            e.defaultStyles ? R.defaultStyles : \"\",\n            ((M = (C = e.domAttributes) == null ? void 0 : C.editor) == null ? void 0 : M.class) || \"\"\n          )\n        }\n      }\n    };\n    e.parentElement && (s.element = e.parentElement), this._tiptapEditor = new _tiptap_core__WEBPACK_IMPORTED_MODULE_13__.Editor(s);\n  }\n  get prosemirrorView() {\n    return this._tiptapEditor.view;\n  }\n  get domElement() {\n    return this._tiptapEditor.view.dom;\n  }\n  isFocused() {\n    return this._tiptapEditor.view.hasFocus();\n  }\n  focus() {\n    this._tiptapEditor.view.focus();\n  }\n  /**\n   * Gets a snapshot of all top-level (non-nested) blocks in the editor.\n   * @returns A snapshot of all top-level (non-nested) blocks in the editor.\n   */\n  get topLevelBlocks() {\n    const t = [];\n    return this._tiptapEditor.state.doc.firstChild.descendants((e) => (t.push(A(e, this.schema, this.blockCache)), !1)), t;\n  }\n  /**\n   * Gets a snapshot of an existing block from the editor.\n   * @param blockIdentifier The identifier of an existing block that should be retrieved.\n   * @returns The block that matches the identifier, or `undefined` if no matching block was found.\n   */\n  getBlock(t) {\n    const e = typeof t == \"string\" ? t : t.id;\n    let o;\n    return this._tiptapEditor.state.doc.firstChild.descendants((r) => typeof o < \"u\" ? !1 : r.type.name !== \"blockContainer\" || r.attrs.id !== e ? !0 : (o = A(r, this.schema, this.blockCache), !1)), o;\n  }\n  /**\n   * Traverses all blocks in the editor depth-first, and executes a callback for each.\n   * @param callback The callback to execute for each block. Returning `false` stops the traversal.\n   * @param reverse Whether the blocks should be traversed in reverse order.\n   */\n  forEachBlock(t, e = !1) {\n    const o = this.topLevelBlocks.slice();\n    e && o.reverse();\n    function r(i) {\n      for (const s of i) {\n        if (!t(s))\n          return !1;\n        const l = e ? s.children.slice().reverse() : s.children;\n        if (!r(l))\n          return !1;\n      }\n      return !0;\n    }\n    r(o);\n  }\n  /**\n   * Executes a callback whenever the editor's contents change.\n   * @param callback The callback to execute.\n   */\n  onEditorContentChange(t) {\n    this._tiptapEditor.on(\"update\", t);\n  }\n  /**\n   * Executes a callback whenever the editor's selection changes.\n   * @param callback The callback to execute.\n   */\n  onEditorSelectionChange(t) {\n    this._tiptapEditor.on(\"selectionUpdate\", t);\n  }\n  /**\n   * Gets a snapshot of the current text cursor position.\n   * @returns A snapshot of the current text cursor position.\n   */\n  getTextCursorPosition() {\n    const { node: t, depth: e, startPos: o, endPos: r } = v(\n      this._tiptapEditor.state.doc,\n      this._tiptapEditor.state.selection.from\n    ), i = this._tiptapEditor.state.doc.resolve(r).index(e - 1), s = this._tiptapEditor.state.doc.resolve(r + 1).node().childCount;\n    let l;\n    i > 0 && (l = this._tiptapEditor.state.doc.resolve(o - 2).node());\n    let a;\n    return i < s - 1 && (a = this._tiptapEditor.state.doc.resolve(r + 2).node()), {\n      block: A(t, this.schema, this.blockCache),\n      prevBlock: l === void 0 ? void 0 : A(l, this.schema, this.blockCache),\n      nextBlock: a === void 0 ? void 0 : A(a, this.schema, this.blockCache)\n    };\n  }\n  /**\n   * Sets the text cursor position to the start or end of an existing block. Throws an error if the target block could\n   * not be found.\n   * @param targetBlock The identifier of an existing block that the text cursor should be moved to.\n   * @param placement Whether the text cursor should be placed at the start or end of the block.\n   */\n  setTextCursorPosition(t, e = \"start\") {\n    const o = typeof t == \"string\" ? t : t.id, { posBeforeNode: r } = ot(o, this._tiptapEditor.state.doc), { startPos: i, contentNode: s } = v(\n      this._tiptapEditor.state.doc,\n      r + 2\n    );\n    if (s.type.spec.content === \"\") {\n      this._tiptapEditor.commands.setNodeSelection(i);\n      return;\n    }\n    e === \"start\" ? this._tiptapEditor.commands.setTextSelection(i + 1) : this._tiptapEditor.commands.setTextSelection(\n      i + s.nodeSize - 1\n    );\n  }\n  /**\n   * Gets a snapshot of the current selection.\n   */\n  getSelection() {\n    if (this._tiptapEditor.state.selection.from === this._tiptapEditor.state.selection.to || \"node\" in this._tiptapEditor.state.selection)\n      return;\n    const t = [];\n    return this._tiptapEditor.state.doc.descendants((e, o) => e.type.spec.group !== \"blockContent\" || o + e.nodeSize < this._tiptapEditor.state.selection.from || o > this._tiptapEditor.state.selection.to ? !0 : (t.push(\n      A(\n        this._tiptapEditor.state.doc.resolve(o).node(),\n        this.schema,\n        this.blockCache\n      )\n    ), !1)), { blocks: t };\n  }\n  /**\n   * Checks if the editor is currently editable, or if it's locked.\n   * @returns True if the editor is editable, false otherwise.\n   */\n  get isEditable() {\n    return this._tiptapEditor.isEditable;\n  }\n  /**\n   * Makes the editor editable or locks it, depending on the argument passed.\n   * @param editable True to make the editor editable, or false to lock it.\n   */\n  set isEditable(t) {\n    this._tiptapEditor.setEditable(t);\n  }\n  /**\n   * Inserts new blocks into the editor. If a block's `id` is undefined, BlockNote generates one automatically. Throws an\n   * error if the reference block could not be found.\n   * @param blocksToInsert An array of partial blocks that should be inserted.\n   * @param referenceBlock An identifier for an existing block, at which the new blocks should be inserted.\n   * @param placement Whether the blocks should be inserted just before, just after, or nested inside the\n   * `referenceBlock`. Inserts the blocks at the start of the existing block's children if \"nested\" is used.\n   */\n  insertBlocks(t, e, o = \"before\") {\n    Ft(t, e, o, this._tiptapEditor);\n  }\n  /**\n   * Updates an existing block in the editor. Since updatedBlock is a PartialBlock object, some fields might not be\n   * defined. These undefined fields are kept as-is from the existing block. Throws an error if the block to update could\n   * not be found.\n   * @param blockToUpdate The block that should be updated.\n   * @param update A partial block which defines how the existing block should be changed.\n   */\n  updateBlock(t, e) {\n    so(t, e, this._tiptapEditor);\n  }\n  /**\n   * Removes existing blocks from the editor. Throws an error if any of the blocks could not be found.\n   * @param blocksToRemove An array of identifiers for existing blocks that should be removed.\n   */\n  removeBlocks(t) {\n    $t(t, this._tiptapEditor);\n  }\n  /**\n   * Replaces existing blocks in the editor with new blocks. If the blocks that should be removed are not adjacent or\n   * are at different nesting levels, `blocksToInsert` will be inserted at the position of the first block in\n   * `blocksToRemove`. Throws an error if any of the blocks to remove could not be found.\n   * @param blocksToRemove An array of blocks that should be replaced.\n   * @param blocksToInsert An array of partial blocks to replace the old ones with.\n   */\n  replaceBlocks(t, e) {\n    ao(t, e, this._tiptapEditor);\n  }\n  /**\n   * Gets the active text styles at the text cursor position or at the end of the current selection if it's active.\n   */\n  getActiveStyles() {\n    const t = {}, e = this._tiptapEditor.state.selection.$to.marks(), o = /* @__PURE__ */ new Set([\n      \"bold\",\n      \"italic\",\n      \"underline\",\n      \"strike\",\n      \"code\"\n    ]), r = /* @__PURE__ */ new Set([\"textColor\", \"backgroundColor\"]);\n    for (const i of e)\n      o.has(i.type.name) ? t[i.type.name] = !0 : r.has(i.type.name) && (t[i.type.name] = i.attrs.color);\n    return t;\n  }\n  /**\n   * Adds styles to the currently selected content.\n   * @param styles The styles to add.\n   */\n  addStyles(t) {\n    const e = /* @__PURE__ */ new Set([\n      \"bold\",\n      \"italic\",\n      \"underline\",\n      \"strike\",\n      \"code\"\n    ]), o = /* @__PURE__ */ new Set([\"textColor\", \"backgroundColor\"]);\n    this._tiptapEditor.view.focus();\n    for (const [r, i] of Object.entries(t))\n      e.has(r) ? this._tiptapEditor.commands.setMark(r) : o.has(r) && this._tiptapEditor.commands.setMark(r, { color: i });\n  }\n  /**\n   * Removes styles from the currently selected content.\n   * @param styles The styles to remove.\n   */\n  removeStyles(t) {\n    this._tiptapEditor.view.focus();\n    for (const e of Object.keys(t))\n      this._tiptapEditor.commands.unsetMark(e);\n  }\n  /**\n   * Toggles styles on the currently selected content.\n   * @param styles The styles to toggle.\n   */\n  toggleStyles(t) {\n    const e = /* @__PURE__ */ new Set([\n      \"bold\",\n      \"italic\",\n      \"underline\",\n      \"strike\",\n      \"code\"\n    ]), o = /* @__PURE__ */ new Set([\"textColor\", \"backgroundColor\"]);\n    this._tiptapEditor.view.focus();\n    for (const [r, i] of Object.entries(t))\n      e.has(r) ? this._tiptapEditor.commands.toggleMark(r) : o.has(r) && this._tiptapEditor.commands.toggleMark(r, { color: i });\n  }\n  /**\n   * Gets the currently selected text.\n   */\n  getSelectedText() {\n    return this._tiptapEditor.state.doc.textBetween(\n      this._tiptapEditor.state.selection.from,\n      this._tiptapEditor.state.selection.to\n    );\n  }\n  /**\n   * Gets the URL of the last link in the current selection, or `undefined` if there are no links in the selection.\n   */\n  getSelectedLinkUrl() {\n    return this._tiptapEditor.getAttributes(\"link\").href;\n  }\n  /**\n   * Creates a new link to replace the selected content.\n   * @param url The link URL.\n   * @param text The text to display the link with.\n   */\n  createLink(t, e) {\n    if (t === \"\")\n      return;\n    const { from: o, to: r } = this._tiptapEditor.state.selection;\n    e || (e = this._tiptapEditor.state.doc.textBetween(o, r));\n    const i = this._tiptapEditor.schema.mark(\"link\", { href: t });\n    this._tiptapEditor.view.dispatch(\n      this._tiptapEditor.view.state.tr.insertText(e, o, r).addMark(o, o + e.length, i)\n    );\n  }\n  /**\n   * Checks if the block containing the text cursor can be nested.\n   */\n  canNestBlock() {\n    const { startPos: t, depth: e } = v(\n      this._tiptapEditor.state.doc,\n      this._tiptapEditor.state.selection.from\n    );\n    return this._tiptapEditor.state.doc.resolve(t).index(e - 1) > 0;\n  }\n  /**\n   * Nests the block containing the text cursor into the block above it.\n   */\n  nestBlock() {\n    this._tiptapEditor.commands.sinkListItem(\"blockContainer\");\n  }\n  /**\n   * Checks if the block containing the text cursor is nested.\n   */\n  canUnnestBlock() {\n    const { depth: t } = v(\n      this._tiptapEditor.state.doc,\n      this._tiptapEditor.state.selection.from\n    );\n    return t > 2;\n  }\n  /**\n   * Lifts the block containing the text cursor out of its parent.\n   */\n  unnestBlock() {\n    this._tiptapEditor.commands.liftListItem(\"blockContainer\");\n  }\n  /**\n   * Serializes blocks into an HTML string. To better conform to HTML standards, children of blocks which aren't list\n   * items are un-nested in the output HTML.\n   * @param blocks An array of blocks that should be serialized into HTML.\n   * @returns The blocks, serialized as an HTML string.\n   */\n  async blocksToHTML(t) {\n    return Wt(t, this._tiptapEditor.schema);\n  }\n  /**\n   * Parses blocks from an HTML string. Tries to create `Block` objects out of any HTML block-level elements, and\n   * `InlineNode` objects from any HTML inline elements, though not all element types are recognized. If BlockNote\n   * doesn't recognize an HTML element's tag, it will parse it as a paragraph or plain text.\n   * @param html The HTML string to parse blocks from.\n   * @returns The blocks parsed from the HTML string.\n   */\n  async HTMLToBlocks(t) {\n    return Gt(t, this.schema, this._tiptapEditor.schema);\n  }\n  /**\n   * Serializes blocks into a Markdown string. The output is simplified as Markdown does not support all features of\n   * BlockNote - children of blocks which aren't list items are un-nested and certain styles are removed.\n   * @param blocks An array of blocks that should be serialized into Markdown.\n   * @returns The blocks, serialized as a Markdown string.\n   */\n  async blocksToMarkdown(t) {\n    return uo(t, this._tiptapEditor.schema);\n  }\n  /**\n   * Creates a list of blocks from a Markdown string. Tries to create `Block` and `InlineNode` objects based on\n   * Markdown syntax, though not all symbols are recognized. If BlockNote doesn't recognize a symbol, it will parse it\n   * as text.\n   * @param markdown The Markdown string to parse blocks from.\n   * @returns The blocks parsed from the Markdown string.\n   */\n  async markdownToBlocks(t) {\n    return ho(t, this.schema, this._tiptapEditor.schema);\n  }\n  /**\n   * Updates the user info for the current user that's shown to other collaborators.\n   */\n  updateCollaborationUserInfo(t) {\n    if (!this.options.collaboration)\n      throw new Error(\n        \"Cannot update collaboration user info when collaboration is disabled.\"\n      );\n    this._tiptapEditor.commands.updateUser(t);\n  }\n}\nconst An = async (n) => {\n  const t = new FormData();\n  return t.append(\"file\", n), (await (await fetch(\"https://tmpfiles.org/api/v1/upload\", {\n    method: \"POST\",\n    body: t\n  })).json()).data.url.replace(\n    \"tmpfiles.org/\",\n    \"tmpfiles.org/dl/\"\n  );\n};\n\n//# sourceMappingURL=blocknote.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJsb2Nrbm90ZS9jb3JlL2Rpc3QvYmxvY2tub3RlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0EsMENBQTBDLDBEQUEwRDtBQUNwRztBQUMyVjtBQUN2UztBQUNBO0FBQ0g7QUFDTztBQUNRO0FBQ0Y7QUFDQztBQUNMO0FBQ0Y7QUFDSjtBQUNJO0FBQ0o7QUFDVTtBQUNxQztBQUN1QjtBQUMxRjtBQUNPO0FBQ2dDO0FBQ3pDO0FBQ0M7QUFDRztBQUNOO0FBQ0U7QUFDNEI7QUFDeEI7QUFDTTtBQUNXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2REFBNkQ7QUFDakY7QUFDQTtBQUNBLG9CQUFvQiw2REFBNkQ7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMkRBQTJEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsT0FBTyxvREFBQztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw0Q0FBNEMsbUJBQW1CO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsUUFBUSwrQ0FB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QztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHlEQUFDO0FBQ2hCO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLDJEQUFFO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdJQUF3SSwyREFBQztBQUN6STtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFNBQVM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLDJEQUFFO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDJEQUFDO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5REFBQztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsc0JBQXNCLHNEQUFDO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5REFBQztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxREFBQyxDQUFDLHdEQUFDO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIseURBQUMsc0NBQXNDLHlEQUFDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFdBQVcsc0VBQTBCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx3R0FBd0c7QUFDbkg7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esb0RBQW9ELGlCQUFpQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNkRBQUU7QUFDaEM7QUFDQSw2Q0FBNkMsa0JBQWtCO0FBQy9ELHVOQUF1TjtBQUN2TjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDRCQUE0QjtBQUN4QztBQUNBO0FBQ0EsNEVBQTRFLDhCQUE4QjtBQUMxRyxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGVBQWUseURBQUM7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtHQUErRyxVQUFVO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFIQUFxSCxVQUFVO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0EsdURBQXVELFNBQVM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksd0JBQXdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBa0NFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8yOF9ub3Rpb24tY2xvbmUvLi9ub2RlX21vZHVsZXMvQGJsb2Nrbm90ZS9jb3JlL2Rpc3QvYmxvY2tub3RlLmpzP2Q4MDEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIEp0ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIFp0ID0gKG4sIHQsIGUpID0+IHQgaW4gbiA/IEp0KG4sIHQsIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWU6IGUgfSkgOiBuW3RdID0gZTtcbnZhciB1ID0gKG4sIHQsIGUpID0+IChadChuLCB0eXBlb2YgdCAhPSBcInN5bWJvbFwiID8gdCArIFwiXCIgOiB0LCBlKSwgZSk7XG5pbXBvcnQgeyBFeHRlbnNpb24gYXMgTCwgTWFyayBhcyBtdCwgY29tYmluZVRyYW5zYWN0aW9uU3RlcHMgYXMgUXQsIGdldENoYW5nZWRSYW5nZXMgYXMgdGUsIGZpbmRDaGlsZHJlbkluUmFuZ2UgYXMgZWUsIGZpbmRDaGlsZHJlbiBhcyBydCwgTm9kZSBhcyBxLCBtZXJnZUF0dHJpYnV0ZXMgYXMgRCwgZmluZFBhcmVudE5vZGUgYXMgb2UsIGV4dGVuc2lvbnMgYXMgViwgSW5wdXRSdWxlIGFzIFEsIGlzVGV4dFNlbGVjdGlvbiBhcyBuZSwgaXNOb2RlU2VsZWN0aW9uIGFzIHJlLCBwb3NUb0RPTVJlY3QgYXMgWSwgZ2V0TWFya1JhbmdlIGFzIGl0LCBFZGl0b3IgYXMgaWUgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG5pbXBvcnQgeyBCb2xkIGFzIHNlIH0gZnJvbSBcIkB0aXB0YXAvZXh0ZW5zaW9uLWJvbGRcIjtcbmltcG9ydCB7IENvZGUgYXMgYWUgfSBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24tY29kZVwiO1xuaW1wb3J0IGxlIGZyb20gXCJAdGlwdGFwL2V4dGVuc2lvbi1jb2xsYWJvcmF0aW9uXCI7XG5pbXBvcnQgZGUgZnJvbSBcIkB0aXB0YXAvZXh0ZW5zaW9uLWNvbGxhYm9yYXRpb24tY3Vyc29yXCI7XG5pbXBvcnQgeyBEcm9wY3Vyc29yIGFzIGNlIH0gZnJvbSBcIkB0aXB0YXAvZXh0ZW5zaW9uLWRyb3BjdXJzb3JcIjtcbmltcG9ydCB7IEdhcGN1cnNvciBhcyB1ZSB9IGZyb20gXCJAdGlwdGFwL2V4dGVuc2lvbi1nYXBjdXJzb3JcIjtcbmltcG9ydCB7IEhhcmRCcmVhayBhcyBwZSB9IGZyb20gXCJAdGlwdGFwL2V4dGVuc2lvbi1oYXJkLWJyZWFrXCI7XG5pbXBvcnQgeyBIaXN0b3J5IGFzIGhlIH0gZnJvbSBcIkB0aXB0YXAvZXh0ZW5zaW9uLWhpc3RvcnlcIjtcbmltcG9ydCB7IEl0YWxpYyBhcyBtZSB9IGZyb20gXCJAdGlwdGFwL2V4dGVuc2lvbi1pdGFsaWNcIjtcbmltcG9ydCB7IExpbmsgYXMgZmUgfSBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24tbGlua1wiO1xuaW1wb3J0IHsgU3RyaWtlIGFzIGdlIH0gZnJvbSBcIkB0aXB0YXAvZXh0ZW5zaW9uLXN0cmlrZVwiO1xuaW1wb3J0IHsgVGV4dCBhcyBrZSB9IGZyb20gXCJAdGlwdGFwL2V4dGVuc2lvbi10ZXh0XCI7XG5pbXBvcnQgeyBVbmRlcmxpbmUgYXMgYmUgfSBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24tdW5kZXJsaW5lXCI7XG5pbXBvcnQgeyBTbGljZSBhcyBQLCBGcmFnbWVudCBhcyBPLCBET01TZXJpYWxpemVyIGFzIEosIERPTVBhcnNlciBhcyB5ZSB9IGZyb20gXCJwcm9zZW1pcnJvci1tb2RlbFwiO1xuaW1wb3J0IHsgUGx1Z2luIGFzIEksIFBsdWdpbktleSBhcyBfLCBOb2RlU2VsZWN0aW9uIGFzIGZ0LCBUZXh0U2VsZWN0aW9uIGFzIHN0LCBTZWxlY3Rpb24gYXMgSyB9IGZyb20gXCJwcm9zZW1pcnJvci1zdGF0ZVwiO1xuaW1wb3J0IHsgdjQgYXMgdmUgfSBmcm9tIFwidXVpZFwiO1xuaW1wb3J0ICogYXMgd2UgZnJvbSBcInByb3NlbWlycm9yLXZpZXdcIjtcbmltcG9ydCB7IERlY29yYXRpb24gYXMgRywgRGVjb3JhdGlvblNldCBhcyBqIH0gZnJvbSBcInByb3NlbWlycm9yLXZpZXdcIjtcbmltcG9ydCBndCBmcm9tIFwicmVoeXBlLXBhcnNlXCI7XG5pbXBvcnQgQ2UgZnJvbSBcInJlaHlwZS1yZW1hcmtcIjtcbmltcG9ydCBrdCBmcm9tIFwicmVoeXBlLXN0cmluZ2lmeVwiO1xuaW1wb3J0IGJ0IGZyb20gXCJyZW1hcmstZ2ZtXCI7XG5pbXBvcnQgRWUgZnJvbSBcInJlbWFyay1wYXJzZVwiO1xuaW1wb3J0IFNlLCB7IGRlZmF1bHRIYW5kbGVycyBhcyBNZSB9IGZyb20gXCJyZW1hcmstcmVoeXBlXCI7XG5pbXBvcnQgVGUgZnJvbSBcInJlbWFyay1zdHJpbmdpZnlcIjtcbmltcG9ydCB7IHVuaWZpZWQgYXMgdHQgfSBmcm9tIFwidW5pZmllZFwiO1xuaW1wb3J0IHsgZnJvbURvbSBhcyBhdCB9IGZyb20gXCJoYXN0LXV0aWwtZnJvbS1kb21cIjtcbmNvbnN0IEJlID0gXCJfYm5FZGl0b3JfMTJqZTBfM1wiLCB4ZSA9IFwiX2JuUm9vdF8xMmplMF8xOVwiLCBJZSA9IFwiX2RlZmF1bHRTdHlsZXNfMTJqZTBfMzRcIiwgX2UgPSBcIl9kcmFnUHJldmlld18xMmplMF81N1wiLCBSID0ge1xuICBibkVkaXRvcjogQmUsXG4gIGJuUm9vdDogeGUsXG4gIGRlZmF1bHRTdHlsZXM6IEllLFxuICBkcmFnUHJldmlldzogX2UsXG4gIFwiY29sbGFib3JhdGlvbi1jdXJzb3JfX2NhcmV0XCI6IFwiX2NvbGxhYm9yYXRpb24tY3Vyc29yX19jYXJldF8xMmplMF82M1wiLFxuICBcImNvbGxhYm9yYXRpb24tY3Vyc29yX19sYWJlbFwiOiBcIl9jb2xsYWJvcmF0aW9uLWN1cnNvcl9fbGFiZWxfMTJqZTBfNzRcIlxufTtcbmZ1bmN0aW9uIHl0KG4pIHtcbiAgY29uc3QgdCA9IG4uYXR0cnMuaWQsIGUgPSBuLmZpcnN0Q2hpbGQsIG8gPSBlLnR5cGUsIHIgPSBuLmNoaWxkQ291bnQgPT09IDIgPyBuLmxhc3RDaGlsZC5jaGlsZENvdW50IDogMDtcbiAgcmV0dXJuIHtcbiAgICBpZDogdCxcbiAgICBub2RlOiBuLFxuICAgIGNvbnRlbnROb2RlOiBlLFxuICAgIGNvbnRlbnRUeXBlOiBvLFxuICAgIG51bUNoaWxkQmxvY2tzOiByXG4gIH07XG59XG5mdW5jdGlvbiB2KG4sIHQpIHtcbiAgY29uc3QgbyA9IG4ubm9kZVNpemUgLSAyO1xuICBpZiAodCA8PSAxKVxuICAgIGZvciAodCA9IDEgKyAxOyBuLnJlc29sdmUodCkucGFyZW50LnR5cGUubmFtZSAhPT0gXCJibG9ja0NvbnRhaW5lclwiICYmIHQgPCBvOyApXG4gICAgICB0Kys7XG4gIGVsc2UgaWYgKHQgPj0gbylcbiAgICBmb3IgKHQgPSBvIC0gMTsgbi5yZXNvbHZlKHQpLnBhcmVudC50eXBlLm5hbWUgIT09IFwiYmxvY2tDb250YWluZXJcIiAmJiB0ID4gMTsgKVxuICAgICAgdC0tO1xuICBuLnJlc29sdmUodCkucGFyZW50LnR5cGUubmFtZSA9PT0gXCJibG9ja0dyb3VwXCIgJiYgdCsrO1xuICBjb25zdCByID0gbi5yZXNvbHZlKHQpLCBpID0gci5kZXB0aDtcbiAgbGV0IHMgPSByLm5vZGUoaSksIGwgPSBpO1xuICBmb3IgKDsgOyApIHtcbiAgICBpZiAobCA8IDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiQ291bGQgbm90IGZpbmQgYmxvY2tDb250YWluZXIgbm9kZS4gVGhpcyBjYW4gb25seSBoYXBwZW4gaWYgdGhlIHVuZGVybHlpbmcgQmxvY2tOb3RlIHNjaGVtYSBoYXMgYmVlbiBlZGl0ZWQuXCJcbiAgICAgICk7XG4gICAgaWYgKHMudHlwZS5uYW1lID09PSBcImJsb2NrQ29udGFpbmVyXCIpXG4gICAgICBicmVhaztcbiAgICBsIC09IDEsIHMgPSByLm5vZGUobCk7XG4gIH1cbiAgY29uc3QgeyBpZDogYSwgY29udGVudE5vZGU6IGQsIGNvbnRlbnRUeXBlOiBjLCBudW1DaGlsZEJsb2NrczogaCB9ID0geXQocyksIG0gPSByLnN0YXJ0KGwpLCBwID0gci5lbmQobCk7XG4gIHJldHVybiB7XG4gICAgaWQ6IGEsXG4gICAgbm9kZTogcyxcbiAgICBjb250ZW50Tm9kZTogZCxcbiAgICBjb250ZW50VHlwZTogYyxcbiAgICBudW1DaGlsZEJsb2NrczogaCxcbiAgICBzdGFydFBvczogbSxcbiAgICBlbmRQb3M6IHAsXG4gICAgZGVwdGg6IGxcbiAgfTtcbn1cbmNvbnN0IFQgPSB7XG4gIGJhY2tncm91bmRDb2xvcjoge1xuICAgIGRlZmF1bHQ6IFwiZGVmYXVsdFwiXG4gIH0sXG4gIHRleHRDb2xvcjoge1xuICAgIGRlZmF1bHQ6IFwiZGVmYXVsdFwiXG4gIH0sXG4gIHRleHRBbGlnbm1lbnQ6IHtcbiAgICBkZWZhdWx0OiBcImxlZnRcIixcbiAgICB2YWx1ZXM6IFtcImxlZnRcIiwgXCJjZW50ZXJcIiwgXCJyaWdodFwiLCBcImp1c3RpZnlcIl1cbiAgfVxufSwgQWUgPSBMLmNyZWF0ZSh7XG4gIG5hbWU6IFwiYmxvY2tCYWNrZ3JvdW5kQ29sb3JcIixcbiAgYWRkR2xvYmFsQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0eXBlczogW1wiYmxvY2tDb250YWluZXJcIl0sXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IFQuYmFja2dyb3VuZENvbG9yLmRlZmF1bHQsXG4gICAgICAgICAgICBwYXJzZUhUTUw6IChuKSA9PiBuLmhhc0F0dHJpYnV0ZShcImRhdGEtYmFja2dyb3VuZC1jb2xvclwiKSA/IG4uZ2V0QXR0cmlidXRlKFwiZGF0YS1iYWNrZ3JvdW5kLWNvbG9yXCIpIDogVC5iYWNrZ3JvdW5kQ29sb3IuZGVmYXVsdCxcbiAgICAgICAgICAgIHJlbmRlckhUTUw6IChuKSA9PiBuLmJhY2tncm91bmRDb2xvciAhPT0gVC5iYWNrZ3JvdW5kQ29sb3IuZGVmYXVsdCAmJiB7XG4gICAgICAgICAgICAgIFwiZGF0YS1iYWNrZ3JvdW5kLWNvbG9yXCI6IG4uYmFja2dyb3VuZENvbG9yXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgXTtcbiAgfSxcbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldEJsb2NrQmFja2dyb3VuZENvbG9yOiAobiwgdCkgPT4gKHsgc3RhdGU6IGUsIHZpZXc6IG8gfSkgPT4ge1xuICAgICAgICBjb25zdCByID0gdihlLmRvYywgbik7XG4gICAgICAgIHJldHVybiByID09PSB2b2lkIDAgPyAhMSA6IChlLnRyLnNldE5vZGVBdHRyaWJ1dGUoXG4gICAgICAgICAgci5zdGFydFBvcyAtIDEsXG4gICAgICAgICAgXCJiYWNrZ3JvdW5kQ29sb3JcIixcbiAgICAgICAgICB0XG4gICAgICAgICksIG8uZm9jdXMoKSwgITApO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0pLCBIZSA9IG10LmNyZWF0ZSh7XG4gIG5hbWU6IFwiYmFja2dyb3VuZENvbG9yXCIsXG4gIGFkZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbG9yOiB7XG4gICAgICAgIGRlZmF1bHQ6IHZvaWQgMCxcbiAgICAgICAgcGFyc2VIVE1MOiAobikgPT4gbi5nZXRBdHRyaWJ1dGUoXCJkYXRhLWJhY2tncm91bmQtY29sb3JcIiksXG4gICAgICAgIHJlbmRlckhUTUw6IChuKSA9PiAoe1xuICAgICAgICAgIFwiZGF0YS1iYWNrZ3JvdW5kLWNvbG9yXCI6IG4uY29sb3JcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdGFnOiBcInNwYW5cIixcbiAgICAgICAgZ2V0QXR0cnM6IChuKSA9PiB0eXBlb2YgbiA9PSBcInN0cmluZ1wiID8gITEgOiBuLmhhc0F0dHJpYnV0ZShcImRhdGEtYmFja2dyb3VuZC1jb2xvclwiKSA/IHsgY29sb3I6IG4uZ2V0QXR0cmlidXRlKFwiZGF0YS1iYWNrZ3JvdW5kLWNvbG9yXCIpIH0gOiAhMVxuICAgICAgfVxuICAgIF07XG4gIH0sXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlczogbiB9KSB7XG4gICAgcmV0dXJuIFtcInNwYW5cIiwgbiwgMF07XG4gIH0sXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRCYWNrZ3JvdW5kQ29sb3I6IChuKSA9PiAoeyBjb21tYW5kczogdCB9KSA9PiBuICE9PSBULmJhY2tncm91bmRDb2xvci5kZWZhdWx0ID8gdC5zZXRNYXJrKHRoaXMubmFtZSwgeyBjb2xvcjogbiB9KSA6IHQudW5zZXRNYXJrKHRoaXMubmFtZSlcbiAgICB9O1xuICB9XG59KTtcbmZ1bmN0aW9uIExlKG4sIHQgPSBKU09OLnN0cmluZ2lmeSkge1xuICBjb25zdCBlID0ge307XG4gIHJldHVybiBuLmZpbHRlcigobykgPT4ge1xuICAgIGNvbnN0IHIgPSB0KG8pO1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSwgcikgPyAhMSA6IGVbcl0gPSAhMDtcbiAgfSk7XG59XG5mdW5jdGlvbiBOZShuKSB7XG4gIGNvbnN0IHQgPSBuLmZpbHRlcihcbiAgICAobywgcikgPT4gbi5pbmRleE9mKG8pICE9PSByXG4gICk7XG4gIHJldHVybiBMZSh0KTtcbn1cbmNvbnN0IFggPSBMLmNyZWF0ZSh7XG4gIG5hbWU6IFwidW5pcXVlSURcIixcbiAgLy8gd2XigJlsbCBzZXQgYSB2ZXJ5IGhpZ2ggcHJpb3JpdHkgdG8gbWFrZSBzdXJlIHRoaXMgcnVucyBmaXJzdFxuICAvLyBhbmQgaXMgY29tcGF0aWJsZSB3aXRoIGBhcHBlbmRUcmFuc2FjdGlvbmAgaG9va3Mgb2Ygb3RoZXIgZXh0ZW5zaW9uc1xuICBwcmlvcml0eTogMWU0LFxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhdHRyaWJ1dGVOYW1lOiBcImlkXCIsXG4gICAgICB0eXBlczogW10sXG4gICAgICBnZW5lcmF0ZUlEOiAoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93IDwgXCJ1XCIgJiYgd2luZG93Ll9fVEVTVF9PUFRJT05TKSB7XG4gICAgICAgICAgY29uc3QgbiA9IHdpbmRvdy5fX1RFU1RfT1BUSU9OUztcbiAgICAgICAgICByZXR1cm4gbi5tb2NrSUQgPT09IHZvaWQgMCA/IG4ubW9ja0lEID0gMCA6IG4ubW9ja0lEKyssIG4ubW9ja0lELnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZlKCk7XG4gICAgICB9LFxuICAgICAgZmlsdGVyVHJhbnNhY3Rpb246IG51bGxcbiAgICB9O1xuICB9LFxuICBhZGRHbG9iYWxBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHR5cGVzOiB0aGlzLm9wdGlvbnMudHlwZXMsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICBbdGhpcy5vcHRpb25zLmF0dHJpYnV0ZU5hbWVdOiB7XG4gICAgICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICAgICAgcGFyc2VIVE1MOiAobikgPT4gbi5nZXRBdHRyaWJ1dGUoYGRhdGEtJHt0aGlzLm9wdGlvbnMuYXR0cmlidXRlTmFtZX1gKSxcbiAgICAgICAgICAgIHJlbmRlckhUTUw6IChuKSA9PiAoe1xuICAgICAgICAgICAgICBbYGRhdGEtJHt0aGlzLm9wdGlvbnMuYXR0cmlidXRlTmFtZX1gXTogblt0aGlzLm9wdGlvbnMuYXR0cmlidXRlTmFtZV1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgXTtcbiAgfSxcbiAgLy8gY2hlY2sgaW5pdGlhbCBjb250ZW50IGZvciBtaXNzaW5nIGlkc1xuICAvLyBvbkNyZWF0ZSgpIHtcbiAgLy8gICAvLyBEb27igJl0IGRvIHRoaXMgd2hlbiB0aGUgY29sbGFib3JhdGlvbiBleHRlbnNpb24gaXMgYWN0aXZlXG4gIC8vICAgLy8gYmVjYXVzZSB0aGlzIG1heSB1cGRhdGUgdGhlIGNvbnRlbnQsIHNvIFkuanMgdHJpZXMgdG8gbWVyZ2UgdGhlc2UgY2hhbmdlcy5cbiAgLy8gICAvLyBUaGlzIGxlYWRzIHRvIGVtcHR5IGJsb2NrIG5vZGVzLlxuICAvLyAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL3VlYmVyZG9zaXMvdGlwdGFwL2lzc3Vlcy8yNDAwXG4gIC8vICAgaWYgKFxuICAvLyAgICAgdGhpcy5lZGl0b3IuZXh0ZW5zaW9uTWFuYWdlci5leHRlbnNpb25zLmZpbmQoXG4gIC8vICAgICAgIChleHRlbnNpb24pID0+IGV4dGVuc2lvbi5uYW1lID09PSBcImNvbGxhYm9yYXRpb25cIlxuICAvLyAgICAgKVxuICAvLyAgICkge1xuICAvLyAgICAgcmV0dXJuO1xuICAvLyAgIH1cbiAgLy8gICBjb25zdCB7IHZpZXcsIHN0YXRlIH0gPSB0aGlzLmVkaXRvcjtcbiAgLy8gICBjb25zdCB7IHRyLCBkb2MgfSA9IHN0YXRlO1xuICAvLyAgIGNvbnN0IHsgdHlwZXMsIGF0dHJpYnV0ZU5hbWUsIGdlbmVyYXRlSUQgfSA9IHRoaXMub3B0aW9ucztcbiAgLy8gICBjb25zdCBub2Rlc1dpdGhvdXRJZCA9IGZpbmRDaGlsZHJlbihkb2MsIChub2RlKSA9PiB7XG4gIC8vICAgICByZXR1cm4gKFxuICAvLyAgICAgICB0eXBlcy5pbmNsdWRlcyhub2RlLnR5cGUubmFtZSkgJiYgbm9kZS5hdHRyc1thdHRyaWJ1dGVOYW1lXSA9PT0gbnVsbFxuICAvLyAgICAgKTtcbiAgLy8gICB9KTtcbiAgLy8gICBub2Rlc1dpdGhvdXRJZC5mb3JFYWNoKCh7IG5vZGUsIHBvcyB9KSA9PiB7XG4gIC8vICAgICB0ci5zZXROb2RlTWFya3VwKHBvcywgdW5kZWZpbmVkLCB7XG4gIC8vICAgICAgIC4uLm5vZGUuYXR0cnMsXG4gIC8vICAgICAgIFthdHRyaWJ1dGVOYW1lXTogZ2VuZXJhdGVJRCgpLFxuICAvLyAgICAgfSk7XG4gIC8vICAgfSk7XG4gIC8vICAgdHIuc2V0TWV0YShcImFkZFRvSGlzdG9yeVwiLCBmYWxzZSk7XG4gIC8vICAgdmlldy5kaXNwYXRjaCh0cik7XG4gIC8vIH0sXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICBsZXQgbiA9IG51bGwsIHQgPSAhMTtcbiAgICByZXR1cm4gW1xuICAgICAgbmV3IEkoe1xuICAgICAgICBrZXk6IG5ldyBfKFwidW5pcXVlSURcIiksXG4gICAgICAgIGFwcGVuZFRyYW5zYWN0aW9uOiAoZSwgbywgcikgPT4ge1xuICAgICAgICAgIGNvbnN0IGkgPSBlLnNvbWUoKGYpID0+IGYuZG9jQ2hhbmdlZCkgJiYgIW8uZG9jLmVxKHIuZG9jKSwgcyA9IHRoaXMub3B0aW9ucy5maWx0ZXJUcmFuc2FjdGlvbiAmJiBlLnNvbWUoKGYpID0+IHtcbiAgICAgICAgICAgIGxldCBiLCB3O1xuICAgICAgICAgICAgcmV0dXJuICEoISgodyA9IChiID0gdGhpcy5vcHRpb25zKS5maWx0ZXJUcmFuc2FjdGlvbikgPT09IG51bGwgfHwgdyA9PT0gdm9pZCAwKSAmJiB3LmNhbGwoYiwgZikpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICghaSB8fCBzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNvbnN0IHsgdHI6IGwgfSA9IHIsIHsgdHlwZXM6IGEsIGF0dHJpYnV0ZU5hbWU6IGQsIGdlbmVyYXRlSUQ6IGMgfSA9IHRoaXMub3B0aW9ucywgaCA9IFF0KFxuICAgICAgICAgICAgby5kb2MsXG4gICAgICAgICAgICBlXG4gICAgICAgICAgKSwgeyBtYXBwaW5nOiBtIH0gPSBoO1xuICAgICAgICAgIGlmICh0ZShoKS5mb3JFYWNoKCh7IG5ld1JhbmdlOiBmIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGIgPSBlZShcbiAgICAgICAgICAgICAgci5kb2MsXG4gICAgICAgICAgICAgIGYsXG4gICAgICAgICAgICAgIChNKSA9PiBhLmluY2x1ZGVzKE0udHlwZS5uYW1lKVxuICAgICAgICAgICAgKSwgdyA9IGIubWFwKCh7IG5vZGU6IE0gfSkgPT4gTS5hdHRyc1tkXSkuZmlsdGVyKChNKSA9PiBNICE9PSBudWxsKSwgQyA9IE5lKHcpO1xuICAgICAgICAgICAgYi5mb3JFYWNoKCh7IG5vZGU6IE0sIHBvczogRSB9KSA9PiB7XG4gICAgICAgICAgICAgIGxldCB5O1xuICAgICAgICAgICAgICBjb25zdCBTID0gKHkgPSBsLmRvYy5ub2RlQXQoRSkpID09PSBudWxsIHx8IHkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHkuYXR0cnNbZF07XG4gICAgICAgICAgICAgIGlmIChTID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbC5zZXROb2RlTWFya3VwKEUsIHZvaWQgMCwge1xuICAgICAgICAgICAgICAgICAgLi4uTS5hdHRycyxcbiAgICAgICAgICAgICAgICAgIFtkXTogYygpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IHsgZGVsZXRlZDogZyB9ID0gbS5pbnZlcnQoKS5tYXBSZXN1bHQoRSk7XG4gICAgICAgICAgICAgIGcgJiYgQy5pbmNsdWRlcyhTKSAmJiBsLnNldE5vZGVNYXJrdXAoRSwgdm9pZCAwLCB7XG4gICAgICAgICAgICAgICAgLi4uTS5hdHRycyxcbiAgICAgICAgICAgICAgICBbZF06IGMoKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pLCAhIWwuc3RlcHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGw7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHdlIHJlZ2lzdGVyIGEgZ2xvYmFsIGRyYWcgaGFuZGxlciB0byB0cmFjayB0aGUgY3VycmVudCBkcmFnIHNvdXJjZSBlbGVtZW50XG4gICAgICAgIHZpZXcoZSkge1xuICAgICAgICAgIGNvbnN0IG8gPSAocikgPT4ge1xuICAgICAgICAgICAgbGV0IGk7XG4gICAgICAgICAgICBuID0gISgoaSA9IGUuZG9tLnBhcmVudEVsZW1lbnQpID09PSBudWxsIHx8IGkgPT09IHZvaWQgMCkgJiYgaS5jb250YWlucyhyLnRhcmdldCkgPyBlLmRvbS5wYXJlbnRFbGVtZW50IDogbnVsbDtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdzdGFydFwiLCBvKSwge1xuICAgICAgICAgICAgZGVzdHJveSgpIHtcbiAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkcmFnc3RhcnRcIiwgbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAvLyBgaGFuZGxlRE9NRXZlbnRzYCBpcyBjYWxsZWQgYmVmb3JlIGB0cmFuc2Zvcm1QYXN0ZWRgXG4gICAgICAgICAgLy8gc28gd2UgY2FuIGRvIHNvbWUgY2hlY2tzIGJlZm9yZVxuICAgICAgICAgIGhhbmRsZURPTUV2ZW50czoge1xuICAgICAgICAgICAgLy8gb25seSBjcmVhdGUgbmV3IGlkcyBmb3IgZHJvcHBlZCBjb250ZW50IHdoaWxlIGhvbGRpbmcgYGFsdGBcbiAgICAgICAgICAgIC8vIG9yIGNvbnRlbnQgaXMgZHJhZ2dlZCBmcm9tIGFub3RoZXIgZWRpdG9yXG4gICAgICAgICAgICBkcm9wOiAoZSwgbykgPT4ge1xuICAgICAgICAgICAgICBsZXQgcjtcbiAgICAgICAgICAgICAgcmV0dXJuIChuICE9PSBlLmRvbS5wYXJlbnRFbGVtZW50IHx8ICgociA9IG8uZGF0YVRyYW5zZmVyKSA9PT0gbnVsbCB8fCByID09PSB2b2lkIDAgPyB2b2lkIDAgOiByLmVmZmVjdEFsbG93ZWQpID09PSBcImNvcHlcIikgJiYgKG4gPSBudWxsLCB0ID0gITApLCAhMTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBhbHdheXMgY3JlYXRlIG5ldyBpZHMgb24gcGFzdGVkIGNvbnRlbnRcbiAgICAgICAgICAgIHBhc3RlOiAoKSA9PiAodCA9ICEwLCAhMSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIC8vIHdl4oCZbGwgcmVtb3ZlIGlkcyBmb3IgZXZlcnkgcGFzdGVkIG5vZGVcbiAgICAgICAgICAvLyBzbyB3ZSBjYW4gY3JlYXRlIGEgbmV3IG9uZSB3aXRoaW4gYGFwcGVuZFRyYW5zYWN0aW9uYFxuICAgICAgICAgIHRyYW5zZm9ybVBhc3RlZDogKGUpID0+IHtcbiAgICAgICAgICAgIGlmICghdClcbiAgICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgICAgICBjb25zdCB7IHR5cGVzOiBvLCBhdHRyaWJ1dGVOYW1lOiByIH0gPSB0aGlzLm9wdGlvbnMsIGkgPSAocykgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBsID0gW107XG4gICAgICAgICAgICAgIHJldHVybiBzLmZvckVhY2goKGEpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYS5pc1RleHQpIHtcbiAgICAgICAgICAgICAgICAgIGwucHVzaChhKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFvLmluY2x1ZGVzKGEudHlwZS5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgbC5wdXNoKGEuY29weShpKGEuY29udGVudCkpKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZCA9IGEudHlwZS5jcmVhdGUoXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmEuYXR0cnMsXG4gICAgICAgICAgICAgICAgICAgIFtyXTogbnVsbFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGkoYS5jb250ZW50KSxcbiAgICAgICAgICAgICAgICAgIGEubWFya3NcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGwucHVzaChkKTtcbiAgICAgICAgICAgICAgfSksIE8uZnJvbShsKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gdCA9ICExLCBuZXcgUChcbiAgICAgICAgICAgICAgaShlLmNvbnRlbnQpLFxuICAgICAgICAgICAgICBlLm9wZW5TdGFydCxcbiAgICAgICAgICAgICAgZS5vcGVuRW5kXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICBdO1xuICB9XG59KSwgUGUgPSAoKSA9PiAvTWFjLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSkgfHwgL0FwcGxlV2ViS2l0Ly50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmIC9Nb2JpbGVcXC9cXHcrLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuZnVuY3Rpb24geG4obikge1xuICByZXR1cm4gUGUoKSA/IG4ucmVwbGFjZShcIk1vZFwiLCBcIuKMmFwiKSA6IG4ucmVwbGFjZShcIk1vZFwiLCBcIkN0cmxcIik7XG59XG5mdW5jdGlvbiBCKC4uLm4pIHtcbiAgcmV0dXJuIG4uZmlsdGVyKCh0KSA9PiB0KS5qb2luKFwiIFwiKTtcbn1cbmNsYXNzIERlIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgc3VwZXIoYFVucmVhY2hhYmxlIGNhc2U6ICR7dH1gKTtcbiAgfVxufVxuY29uc3QgdnQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwiYm9sZFwiLFxuICBcIml0YWxpY1wiLFxuICBcInVuZGVybGluZVwiLFxuICBcInN0cmlrZVwiLFxuICBcImNvZGVcIlxuXSksIHd0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1widGV4dENvbG9yXCIsIFwiYmFja2dyb3VuZENvbG9yXCJdKTtcbmZ1bmN0aW9uIGx0KG4sIHQpIHtcbiAgY29uc3QgZSA9IFtdO1xuICBmb3IgKGNvbnN0IFtvLCByXSBvZiBPYmplY3QuZW50cmllcyhuLnN0eWxlcykpXG4gICAgdnQuaGFzKG8pID8gZS5wdXNoKHQubWFyayhvKSkgOiB3dC5oYXMobykgJiYgZS5wdXNoKHQubWFyayhvLCB7IGNvbG9yOiByIH0pKTtcbiAgcmV0dXJuIG4udGV4dC5zcGxpdCgvKFxcbikvZykuZmlsdGVyKChvKSA9PiBvLmxlbmd0aCA+IDApLm1hcCgobykgPT4gbyA9PT0gYFxuYCA/IHQubm9kZXMuaGFyZEJyZWFrLmNyZWF0ZSgpIDogdC50ZXh0KG8sIGUpKTtcbn1cbmZ1bmN0aW9uIE9lKG4sIHQpIHtcbiAgY29uc3QgZSA9IHQubWFya3MubGluay5jcmVhdGUoe1xuICAgIGhyZWY6IG4uaHJlZlxuICB9KTtcbiAgcmV0dXJuIEN0KG4uY29udGVudCwgdCkubWFwKChvKSA9PiB7XG4gICAgaWYgKG8udHlwZS5uYW1lID09PSBcInRleHRcIilcbiAgICAgIHJldHVybiBvLm1hcmsoWy4uLm8ubWFya3MsIGVdKTtcbiAgICBpZiAoby50eXBlLm5hbWUgPT09IFwiaGFyZEJyZWFrXCIpXG4gICAgICByZXR1cm4gbztcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmV4cGVjdGVkIG5vZGUgdHlwZVwiKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBDdChuLCB0KSB7XG4gIGNvbnN0IGUgPSBbXTtcbiAgaWYgKHR5cGVvZiBuID09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIGUucHVzaChcbiAgICAgIC4uLmx0KHsgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IG4sIHN0eWxlczoge30gfSwgdClcbiAgICApLCBlO1xuICBmb3IgKGNvbnN0IG8gb2YgbilcbiAgICBlLnB1c2goLi4ubHQobywgdCkpO1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIEV0KG4sIHQpIHtcbiAgY29uc3QgZSA9IFtdO1xuICBmb3IgKGNvbnN0IG8gb2YgbilcbiAgICBpZiAoby50eXBlID09PSBcImxpbmtcIilcbiAgICAgIGUucHVzaCguLi5PZShvLCB0KSk7XG4gICAgZWxzZSBpZiAoby50eXBlID09PSBcInRleHRcIilcbiAgICAgIGUucHVzaCguLi5DdChbb10sIHQpKTtcbiAgICBlbHNlXG4gICAgICB0aHJvdyBuZXcgRGUobyk7XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gRihuLCB0KSB7XG4gIGxldCBlID0gbi5pZDtcbiAgZSA9PT0gdm9pZCAwICYmIChlID0gWC5vcHRpb25zLmdlbmVyYXRlSUQoKSk7XG4gIGxldCBvID0gbi50eXBlO1xuICBvID09PSB2b2lkIDAgJiYgKG8gPSBcInBhcmFncmFwaFwiKTtcbiAgbGV0IHI7XG4gIGlmICghbi5jb250ZW50KVxuICAgIHIgPSB0Lm5vZGVzW29dLmNyZWF0ZShuLnByb3BzKTtcbiAgZWxzZSBpZiAodHlwZW9mIG4uY29udGVudCA9PSBcInN0cmluZ1wiKVxuICAgIHIgPSB0Lm5vZGVzW29dLmNyZWF0ZShcbiAgICAgIG4ucHJvcHMsXG4gICAgICB0LnRleHQobi5jb250ZW50KVxuICAgICk7XG4gIGVsc2Uge1xuICAgIGNvbnN0IGwgPSBFdChuLmNvbnRlbnQsIHQpO1xuICAgIHIgPSB0Lm5vZGVzW29dLmNyZWF0ZShuLnByb3BzLCBsKTtcbiAgfVxuICBjb25zdCBpID0gW107XG4gIGlmIChuLmNoaWxkcmVuKVxuICAgIGZvciAoY29uc3QgbCBvZiBuLmNoaWxkcmVuKVxuICAgICAgaS5wdXNoKEYobCwgdCkpO1xuICBjb25zdCBzID0gdC5ub2Rlcy5ibG9ja0dyb3VwLmNyZWF0ZSh7fSwgaSk7XG4gIHJldHVybiB0Lm5vZGVzLmJsb2NrQ29udGFpbmVyLmNyZWF0ZShcbiAgICB7XG4gICAgICBpZDogZSxcbiAgICAgIC4uLm4ucHJvcHNcbiAgICB9LFxuICAgIGkubGVuZ3RoID4gMCA/IFtyLCBzXSA6IHJcbiAgKTtcbn1cbmZ1bmN0aW9uIFJlKG4pIHtcbiAgY29uc3QgdCA9IFtdO1xuICBsZXQgZTtcbiAgcmV0dXJuIG4uY29udGVudC5mb3JFYWNoKChvKSA9PiB7XG4gICAgaWYgKG8udHlwZS5uYW1lID09PSBcImhhcmRCcmVha1wiKSB7XG4gICAgICBlID8gZS50eXBlID09PSBcInRleHRcIiA/IGUudGV4dCArPSBgXG5gIDogZS50eXBlID09PSBcImxpbmtcIiAmJiAoZS5jb250ZW50W2UuY29udGVudC5sZW5ndGggLSAxXS50ZXh0ICs9IGBcbmApIDogZSA9IHtcbiAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgIHRleHQ6IGBcbmAsXG4gICAgICAgIHN0eWxlczoge31cbiAgICAgIH07XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHIgPSB7fTtcbiAgICBsZXQgaTtcbiAgICBmb3IgKGNvbnN0IHMgb2Ygby5tYXJrcylcbiAgICAgIGlmIChzLnR5cGUubmFtZSA9PT0gXCJsaW5rXCIpXG4gICAgICAgIGkgPSBzO1xuICAgICAgZWxzZSBpZiAodnQuaGFzKHMudHlwZS5uYW1lKSlcbiAgICAgICAgcltzLnR5cGUubmFtZV0gPSAhMDtcbiAgICAgIGVsc2UgaWYgKHd0LmhhcyhzLnR5cGUubmFtZSkpXG4gICAgICAgIHJbcy50eXBlLm5hbWVdID0gcy5hdHRycy5jb2xvcjtcbiAgICAgIGVsc2VcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJNYXJrIGlzIG9mIGFuIHVucmVjb2duaXplZCB0eXBlOiBcIiArIHMudHlwZS5uYW1lKTtcbiAgICBlID8gZS50eXBlID09PSBcInRleHRcIiA/IGkgPyAodC5wdXNoKGUpLCBlID0ge1xuICAgICAgdHlwZTogXCJsaW5rXCIsXG4gICAgICBocmVmOiBpLmF0dHJzLmhyZWYsXG4gICAgICBjb250ZW50OiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICB0ZXh0OiBvLnRleHRDb250ZW50LFxuICAgICAgICAgIHN0eWxlczogclxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSkgOiBKU09OLnN0cmluZ2lmeShlLnN0eWxlcykgPT09IEpTT04uc3RyaW5naWZ5KHIpID8gZS50ZXh0ICs9IG8udGV4dENvbnRlbnQgOiAodC5wdXNoKGUpLCBlID0ge1xuICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICB0ZXh0OiBvLnRleHRDb250ZW50LFxuICAgICAgc3R5bGVzOiByXG4gICAgfSkgOiBlLnR5cGUgPT09IFwibGlua1wiICYmIChpID8gZS5ocmVmID09PSBpLmF0dHJzLmhyZWYgPyBKU09OLnN0cmluZ2lmeShcbiAgICAgIGUuY29udGVudFtlLmNvbnRlbnQubGVuZ3RoIC0gMV0uc3R5bGVzXG4gICAgKSA9PT0gSlNPTi5zdHJpbmdpZnkocikgPyBlLmNvbnRlbnRbZS5jb250ZW50Lmxlbmd0aCAtIDFdLnRleHQgKz0gby50ZXh0Q29udGVudCA6IGUuY29udGVudC5wdXNoKHtcbiAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgdGV4dDogby50ZXh0Q29udGVudCxcbiAgICAgIHN0eWxlczogclxuICAgIH0pIDogKHQucHVzaChlKSwgZSA9IHtcbiAgICAgIHR5cGU6IFwibGlua1wiLFxuICAgICAgaHJlZjogaS5hdHRycy5ocmVmLFxuICAgICAgY29udGVudDogW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgdGV4dDogby50ZXh0Q29udGVudCxcbiAgICAgICAgICBzdHlsZXM6IHJcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0pIDogKHQucHVzaChlKSwgZSA9IHtcbiAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgdGV4dDogby50ZXh0Q29udGVudCxcbiAgICAgIHN0eWxlczogclxuICAgIH0pKSA6IGkgPyBlID0ge1xuICAgICAgdHlwZTogXCJsaW5rXCIsXG4gICAgICBocmVmOiBpLmF0dHJzLmhyZWYsXG4gICAgICBjb250ZW50OiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICB0ZXh0OiBvLnRleHRDb250ZW50LFxuICAgICAgICAgIHN0eWxlczogclxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSA6IGUgPSB7XG4gICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgIHRleHQ6IG8udGV4dENvbnRlbnQsXG4gICAgICBzdHlsZXM6IHJcbiAgICB9O1xuICB9KSwgZSAmJiB0LnB1c2goZSksIHQ7XG59XG5mdW5jdGlvbiBBKG4sIHQsIGUpIHtcbiAgaWYgKG4udHlwZS5uYW1lICE9PSBcImJsb2NrQ29udGFpbmVyXCIpXG4gICAgdGhyb3cgRXJyb3IoXG4gICAgICBcIk5vZGUgbXVzdCBiZSBvZiB0eXBlIGJsb2NrQ29udGFpbmVyLCBidXQgaXMgb2YgdHlwZVwiICsgbi50eXBlLm5hbWUgKyBcIi5cIlxuICAgICk7XG4gIGNvbnN0IG8gPSBlID09IG51bGwgPyB2b2lkIDAgOiBlLmdldChuKTtcbiAgaWYgKG8pXG4gICAgcmV0dXJuIG87XG4gIGNvbnN0IHIgPSB5dChuKTtcbiAgbGV0IGkgPSByLmlkO1xuICBpID09PSBudWxsICYmIChpID0gWC5vcHRpb25zLmdlbmVyYXRlSUQoKSk7XG4gIGNvbnN0IHMgPSB7fTtcbiAgZm9yIChjb25zdCBbYywgaF0gb2YgT2JqZWN0LmVudHJpZXMoe1xuICAgIC4uLm4uYXR0cnMsXG4gICAgLi4uci5jb250ZW50Tm9kZS5hdHRyc1xuICB9KSkge1xuICAgIGNvbnN0IG0gPSB0W3IuY29udGVudFR5cGUubmFtZV07XG4gICAgaWYgKCFtKVxuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIFwiQmxvY2sgaXMgb2YgYW4gdW5yZWNvZ25pemVkIHR5cGU6IFwiICsgci5jb250ZW50VHlwZS5uYW1lXG4gICAgICApO1xuICAgIGNvbnN0IHAgPSBtLnByb3BTY2hlbWE7XG4gICAgYyBpbiBwICYmIChzW2NdID0gaCk7XG4gIH1cbiAgY29uc3QgbCA9IHRbci5jb250ZW50VHlwZS5uYW1lXSwgYSA9IFtdO1xuICBmb3IgKGxldCBjID0gMDsgYyA8IHIubnVtQ2hpbGRCbG9ja3M7IGMrKylcbiAgICBhLnB1c2goXG4gICAgICBBKG4ubGFzdENoaWxkLmNoaWxkKGMpLCB0LCBlKVxuICAgICk7XG4gIGNvbnN0IGQgPSB7XG4gICAgaWQ6IGksXG4gICAgdHlwZTogbC5ub2RlLm5hbWUsXG4gICAgcHJvcHM6IHMsXG4gICAgY29udGVudDogbC5ub2RlLmNvbmZpZy5jb250ZW50ID09PSBcImlubGluZSpcIiA/IFJlKHIuY29udGVudE5vZGUpIDogdm9pZCAwLFxuICAgIGNoaWxkcmVuOiBhXG4gIH07XG4gIHJldHVybiBlID09IG51bGwgfHwgZS5zZXQobiwgZCksIGQ7XG59XG5jb25zdCBkdCA9IG5ldyBfKFwicHJldmlvdXMtYmxvY2tzXCIpLCB6ZSA9IHtcbiAgLy8gTnVtYmVyZWQgTGlzdCBJdGVtc1xuICBpbmRleDogXCJpbmRleFwiLFxuICAvLyBIZWFkaW5nc1xuICBsZXZlbDogXCJsZXZlbFwiLFxuICAvLyBBbGwgQmxvY2tzXG4gIHR5cGU6IFwidHlwZVwiLFxuICBkZXB0aDogXCJkZXB0aFwiLFxuICBcImRlcHRoLWNoYW5nZVwiOiBcImRlcHRoLWNoYW5nZVwiXG59LCBWZSA9ICgpID0+IHtcbiAgbGV0IG47XG4gIHJldHVybiBuZXcgSSh7XG4gICAga2V5OiBkdCxcbiAgICB2aWV3KHQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVwZGF0ZTogYXN5bmMgKGUsIG8pID0+IHtcbiAgICAgICAgICB2YXIgcjtcbiAgICAgICAgICAoKHIgPSB0aGlzLmtleSkgPT0gbnVsbCA/IHZvaWQgMCA6IHIuZ2V0U3RhdGUoZS5zdGF0ZSkudXBkYXRlZEJsb2Nrcy5zaXplKSA+IDAgJiYgKG4gPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGUuZGlzcGF0Y2goXG4gICAgICAgICAgICAgIGUuc3RhdGUudHIuc2V0TWV0YShkdCwgeyBjbGVhclVwZGF0ZTogITAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSwgMCkpO1xuICAgICAgICB9LFxuICAgICAgICBkZXN0cm95OiAoKSA9PiB7XG4gICAgICAgICAgbiAmJiBjbGVhclRpbWVvdXQobik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICBzdGF0ZToge1xuICAgICAgaW5pdCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAvLyBCbG9jayBhdHRyaWJ1dGVzLCBieSBibG9jayBJRCwgZnJvbSBqdXN0IGJlZm9yZSB0aGUgcHJldmlvdXMgdHJhbnNhY3Rpb24uXG4gICAgICAgICAgcHJldlRyYW5zYWN0aW9uT2xkQmxvY2tBdHRyczoge30sXG4gICAgICAgICAgLy8gQmxvY2sgYXR0cmlidXRlcywgYnkgYmxvY2sgSUQsIGZyb20ganVzdCBiZWZvcmUgdGhlIGN1cnJlbnQgdHJhbnNhY3Rpb24uXG4gICAgICAgICAgY3VycmVudFRyYW5zYWN0aW9uT2xkQmxvY2tBdHRyczoge30sXG4gICAgICAgICAgLy8gU2V0IG9mIElEcyBvZiBibG9ja3Mgd2hvc2UgYXR0cmlidXRlcyBjaGFuZ2VkIGZyb20gdGhlIGN1cnJlbnQgdHJhbnNhY3Rpb24uXG4gICAgICAgICAgdXBkYXRlZEJsb2NrczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGFwcGx5KHQsIGUsIG8sIHIpIHtcbiAgICAgICAgaWYgKGUuY3VycmVudFRyYW5zYWN0aW9uT2xkQmxvY2tBdHRycyA9IHt9LCBlLnVwZGF0ZWRCbG9ja3MuY2xlYXIoKSwgIXQuZG9jQ2hhbmdlZCB8fCBvLmRvYy5lcShyLmRvYykpXG4gICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIGNvbnN0IGkgPSB7fSwgcyA9IHJ0KG8uZG9jLCAoZCkgPT4gZC5hdHRycy5pZCksIGwgPSBuZXcgTWFwKFxuICAgICAgICAgIHMubWFwKChkKSA9PiBbZC5ub2RlLmF0dHJzLmlkLCBkXSlcbiAgICAgICAgKSwgYSA9IHJ0KHIuZG9jLCAoZCkgPT4gZC5hdHRycy5pZCk7XG4gICAgICAgIGZvciAoY29uc3QgZCBvZiBhKSB7XG4gICAgICAgICAgY29uc3QgYyA9IGwuZ2V0KGQubm9kZS5hdHRycy5pZCksIGggPSBjID09IG51bGwgPyB2b2lkIDAgOiBjLm5vZGUuZmlyc3RDaGlsZCwgbSA9IGQubm9kZS5maXJzdENoaWxkO1xuICAgICAgICAgIGlmIChjICYmIGggJiYgbSkge1xuICAgICAgICAgICAgY29uc3QgcCA9IHtcbiAgICAgICAgICAgICAgaW5kZXg6IG0uYXR0cnMuaW5kZXgsXG4gICAgICAgICAgICAgIGxldmVsOiBtLmF0dHJzLmxldmVsLFxuICAgICAgICAgICAgICB0eXBlOiBtLnR5cGUubmFtZSxcbiAgICAgICAgICAgICAgZGVwdGg6IHIuZG9jLnJlc29sdmUoZC5wb3MpLmRlcHRoXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IGYgPSB7XG4gICAgICAgICAgICAgIGluZGV4OiBoLmF0dHJzLmluZGV4LFxuICAgICAgICAgICAgICBsZXZlbDogaC5hdHRycy5sZXZlbCxcbiAgICAgICAgICAgICAgdHlwZTogaC50eXBlLm5hbWUsXG4gICAgICAgICAgICAgIGRlcHRoOiBvLmRvYy5yZXNvbHZlKGMucG9zKS5kZXB0aFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlbZC5ub2RlLmF0dHJzLmlkXSA9IGYsIHQuZ2V0TWV0YShcIm51bWJlcmVkTGlzdEluZGV4aW5nXCIpICYmIChkLm5vZGUuYXR0cnMuaWQgaW4gZS5wcmV2VHJhbnNhY3Rpb25PbGRCbG9ja0F0dHJzICYmIChmID0gZS5wcmV2VHJhbnNhY3Rpb25PbGRCbG9ja0F0dHJzW2Qubm9kZS5hdHRycy5pZF0pLCBwLnR5cGUgPT09IFwibnVtYmVyZWRMaXN0SXRlbVwiICYmIChmLmluZGV4ID0gcC5pbmRleCkpLCBlLmN1cnJlbnRUcmFuc2FjdGlvbk9sZEJsb2NrQXR0cnNbZC5ub2RlLmF0dHJzLmlkXSA9IGYsIEpTT04uc3RyaW5naWZ5KGYpICE9PSBKU09OLnN0cmluZ2lmeShwKSAmJiAoZltcImRlcHRoLWNoYW5nZVwiXSA9IGYuZGVwdGggLSBwLmRlcHRoLCBlLnVwZGF0ZWRCbG9ja3MuYWRkKGQubm9kZS5hdHRycy5pZCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZS5wcmV2VHJhbnNhY3Rpb25PbGRCbG9ja0F0dHJzID0gaSwgZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICBkZWNvcmF0aW9ucyh0KSB7XG4gICAgICAgIGNvbnN0IGUgPSB0aGlzLmdldFN0YXRlKHQpO1xuICAgICAgICBpZiAoZS51cGRhdGVkQmxvY2tzLnNpemUgPT09IDApXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBvID0gW107XG4gICAgICAgIHJldHVybiB0LmRvYy5kZXNjZW5kYW50cygociwgaSkgPT4ge1xuICAgICAgICAgIGlmICghci5hdHRycy5pZCB8fCAhZS51cGRhdGVkQmxvY2tzLmhhcyhyLmF0dHJzLmlkKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBjb25zdCBzID0gZS5jdXJyZW50VHJhbnNhY3Rpb25PbGRCbG9ja0F0dHJzW3IuYXR0cnMuaWRdLCBsID0ge307XG4gICAgICAgICAgZm9yIChjb25zdCBbZCwgY10gb2YgT2JqZWN0LmVudHJpZXMocykpXG4gICAgICAgICAgICBsW1wiZGF0YS1wcmV2LVwiICsgemVbZF1dID0gYyB8fCBcIm5vbmVcIjtcbiAgICAgICAgICBjb25zdCBhID0gRy5ub2RlKGksIGkgKyByLm5vZGVTaXplLCB7XG4gICAgICAgICAgICAuLi5sXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgby5wdXNoKGEpO1xuICAgICAgICB9KSwgai5jcmVhdGUodC5kb2MsIG8pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59LCBTdCA9IFwiX2Jsb2NrT3V0ZXJfbnN0ZGZfNVwiLCBNdCA9IFwiX2Jsb2NrX25zdGRmXzVcIiwgVHQgPSBcIl9yZWFjdE5vZGVWaWV3UmVuZGVyZXJfbnN0ZGZfMTdcIiwgQnQgPSBcIl9ibG9ja0NvbnRlbnRfbnN0ZGZfMjJcIiwgeHQgPSBcIl9ibG9ja0dyb3VwX25zdGRmXzQzXCIsIEl0ID0gXCJfd3JhcHBlcl9uc3RkZl8yMjdcIiwgX3QgPSBcIl9hZGRJbWFnZUJ1dHRvbl9uc3RkZl8yMzVcIiwgQXQgPSBcIl9hZGRJbWFnZUJ1dHRvbkljb25fbnN0ZGZfMjUxXCIsIEh0ID0gXCJfYWRkSW1hZ2VCdXR0b25UZXh0X25zdGRmXzI1N1wiLCBMdCA9IFwiX2ltYWdlQW5kQ2FwdGlvbldyYXBwZXJfbnN0ZGZfMjYxXCIsIE50ID0gXCJfaW1hZ2VXcmFwcGVyX25zdGRmXzI2N1wiLCBQdCA9IFwiX2ltYWdlX25zdGRmXzI2MVwiLCBEdCA9IFwiX3Jlc2l6ZUhhbmRsZV9uc3RkZl8yODBcIiwgT3QgPSBcIl9jYXB0aW9uX25zdGRmXzI5MVwiLCBSdCA9IFwiX2lzRW1wdHlfbnN0ZGZfMjk3XCIsIHp0ID0gXCJfaW5saW5lQ29udGVudF9uc3RkZl8yOTdcIiwgVnQgPSBcIl9pc0ZpbHRlcl9uc3RkZl8yOThcIiwgVXQgPSBcIl9oYXNBbmNob3JfbnN0ZGZfMzEwXCIsIGsgPSB7XG4gIGJsb2NrT3V0ZXI6IFN0LFxuICBibG9jazogTXQsXG4gIHJlYWN0Tm9kZVZpZXdSZW5kZXJlcjogVHQsXG4gIGJsb2NrQ29udGVudDogQnQsXG4gIGJsb2NrR3JvdXA6IHh0LFxuICB3cmFwcGVyOiBJdCxcbiAgYWRkSW1hZ2VCdXR0b246IF90LFxuICBhZGRJbWFnZUJ1dHRvbkljb246IEF0LFxuICBhZGRJbWFnZUJ1dHRvblRleHQ6IEh0LFxuICBpbWFnZUFuZENhcHRpb25XcmFwcGVyOiBMdCxcbiAgaW1hZ2VXcmFwcGVyOiBOdCxcbiAgaW1hZ2U6IFB0LFxuICByZXNpemVIYW5kbGU6IER0LFxuICBjYXB0aW9uOiBPdCxcbiAgaXNFbXB0eTogUnQsXG4gIGlubGluZUNvbnRlbnQ6IHp0LFxuICBpc0ZpbHRlcjogVnQsXG4gIGhhc0FuY2hvcjogVXRcbn0sIEluID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgYWRkSW1hZ2VCdXR0b246IF90LFxuICBhZGRJbWFnZUJ1dHRvbkljb246IEF0LFxuICBhZGRJbWFnZUJ1dHRvblRleHQ6IEh0LFxuICBibG9jazogTXQsXG4gIGJsb2NrQ29udGVudDogQnQsXG4gIGJsb2NrR3JvdXA6IHh0LFxuICBibG9ja091dGVyOiBTdCxcbiAgY2FwdGlvbjogT3QsXG4gIGRlZmF1bHQ6IGssXG4gIGhhc0FuY2hvcjogVXQsXG4gIGltYWdlOiBQdCxcbiAgaW1hZ2VBbmRDYXB0aW9uV3JhcHBlcjogTHQsXG4gIGltYWdlV3JhcHBlcjogTnQsXG4gIGlubGluZUNvbnRlbnQ6IHp0LFxuICBpc0VtcHR5OiBSdCxcbiAgaXNGaWx0ZXI6IFZ0LFxuICByZWFjdE5vZGVWaWV3UmVuZGVyZXI6IFR0LFxuICByZXNpemVIYW5kbGU6IER0LFxuICB3cmFwcGVyOiBJdFxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKSwgVWUgPSB7XG4gIGJsb2NrQ29sb3I6IFwiZGF0YS1ibG9jay1jb2xvclwiLFxuICBibG9ja1N0eWxlOiBcImRhdGEtYmxvY2stc3R5bGVcIixcbiAgaWQ6IFwiZGF0YS1pZFwiLFxuICBkZXB0aDogXCJkYXRhLWRlcHRoXCIsXG4gIGRlcHRoQ2hhbmdlOiBcImRhdGEtZGVwdGgtY2hhbmdlXCJcbn0sIEZlID0gbmV3IF8oXCJub24tZWRpdGFibGUtYmxvY2tcIiksICRlID0gKCkgPT4gbmV3IEkoe1xuICBrZXk6IEZlLFxuICBwcm9wczoge1xuICAgIGhhbmRsZUtleURvd246IChuLCB0KSA9PiB7XG4gICAgICBcIm5vZGVcIiBpbiBuLnN0YXRlLnNlbGVjdGlvbiAmJiB0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG59KSwgV2UgPSBxLmNyZWF0ZSh7XG4gIG5hbWU6IFwiYmxvY2tDb250YWluZXJcIixcbiAgZ3JvdXA6IFwiYmxvY2tDb250YWluZXJcIixcbiAgLy8gQSBibG9jayBhbHdheXMgY29udGFpbnMgY29udGVudCwgYW5kIG9wdGlvbmFsbHkgYSBibG9ja0dyb3VwIHdoaWNoIGNvbnRhaW5zIG5lc3RlZCBibG9ja3NcbiAgY29udGVudDogXCJibG9ja0NvbnRlbnQgYmxvY2tHcm91cD9cIixcbiAgLy8gRW5zdXJlcyBjb250ZW50LXNwZWNpZmljIGtleWJvYXJkIGhhbmRsZXJzIHRyaWdnZXIgZmlyc3QuXG4gIHByaW9yaXR5OiA1MCxcbiAgZGVmaW5pbmc6ICEwLFxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdGFnOiBcImRpdlwiLFxuICAgICAgICBnZXRBdHRyczogKG4pID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIG4gPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICBjb25zdCB0ID0ge307XG4gICAgICAgICAgZm9yIChjb25zdCBbZSwgb10gb2YgT2JqZWN0LmVudHJpZXMoVWUpKVxuICAgICAgICAgICAgbi5nZXRBdHRyaWJ1dGUobykgJiYgKHRbZV0gPSBuLmdldEF0dHJpYnV0ZShvKSk7XG4gICAgICAgICAgcmV0dXJuIG4uZ2V0QXR0cmlidXRlKFwiZGF0YS1ub2RlLXR5cGVcIikgPT09IFwiYmxvY2tDb250YWluZXJcIiA/IHQgOiAhMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIF07XG4gIH0sXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlczogbiB9KSB7XG4gICAgdmFyIGU7XG4gICAgY29uc3QgdCA9ICgoZSA9IHRoaXMub3B0aW9ucy5kb21BdHRyaWJ1dGVzKSA9PSBudWxsID8gdm9pZCAwIDogZS5ibG9ja0NvbnRhaW5lcikgfHwge307XG4gICAgcmV0dXJuIFtcbiAgICAgIFwiZGl2XCIsXG4gICAgICBEKG4sIHtcbiAgICAgICAgY2xhc3M6IGsuYmxvY2tPdXRlcixcbiAgICAgICAgXCJkYXRhLW5vZGUtdHlwZVwiOiBcImJsb2NrLW91dGVyXCJcbiAgICAgIH0pLFxuICAgICAgW1xuICAgICAgICBcImRpdlwiLFxuICAgICAgICBEKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC4uLnQsXG4gICAgICAgICAgICBjbGFzczogQihrLmJsb2NrLCB0LmNsYXNzKSxcbiAgICAgICAgICAgIFwiZGF0YS1ub2RlLXR5cGVcIjogdGhpcy5uYW1lXG4gICAgICAgICAgfSxcbiAgICAgICAgICBuXG4gICAgICAgICksXG4gICAgICAgIDBcbiAgICAgIF1cbiAgICBdO1xuICB9LFxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gQ3JlYXRlcyBhIG5ldyB0ZXh0IGJsb2NrIGF0IGEgZ2l2ZW4gcG9zaXRpb24uXG4gICAgICBCTkNyZWF0ZUJsb2NrOiAobikgPT4gKHsgc3RhdGU6IHQsIGRpc3BhdGNoOiBlIH0pID0+IHtcbiAgICAgICAgY29uc3QgbyA9IHQuc2NoZW1hLm5vZGVzLmJsb2NrQ29udGFpbmVyLmNyZWF0ZUFuZEZpbGwoKTtcbiAgICAgICAgcmV0dXJuIGUgJiYgdC50ci5pbnNlcnQobiwgbyksICEwO1xuICAgICAgfSxcbiAgICAgIC8vIERlbGV0ZXMgYSBibG9jayBhdCBhIGdpdmVuIHBvc2l0aW9uLlxuICAgICAgQk5EZWxldGVCbG9jazogKG4pID0+ICh7IHN0YXRlOiB0LCBkaXNwYXRjaDogZSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IG8gPSB2KHQuZG9jLCBuKTtcbiAgICAgICAgaWYgKG8gPT09IHZvaWQgMClcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIGNvbnN0IHsgc3RhcnRQb3M6IHIsIGVuZFBvczogaSB9ID0gbztcbiAgICAgICAgcmV0dXJuIGUgJiYgdC50ci5kZWxldGVSYW5nZShyLCBpKSwgITA7XG4gICAgICB9LFxuICAgICAgLy8gVXBkYXRlcyBhIGJsb2NrIGF0IGEgZ2l2ZW4gcG9zaXRpb24uXG4gICAgICBCTlVwZGF0ZUJsb2NrOiAobiwgdCkgPT4gKHsgc3RhdGU6IGUsIGRpc3BhdGNoOiBvIH0pID0+IHtcbiAgICAgICAgY29uc3QgciA9IHYoZS5kb2MsIG4pO1xuICAgICAgICBpZiAociA9PT0gdm9pZCAwKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgY29uc3QgeyBzdGFydFBvczogaSwgZW5kUG9zOiBzLCBub2RlOiBsLCBjb250ZW50Tm9kZTogYSB9ID0gcjtcbiAgICAgICAgaWYgKG8pIHtcbiAgICAgICAgICBpZiAodC5jaGlsZHJlbiAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBjb25zdCBwID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGYgb2YgdC5jaGlsZHJlbilcbiAgICAgICAgICAgICAgcC5wdXNoKEYoZiwgZS5zY2hlbWEpKTtcbiAgICAgICAgICAgIGwuY2hpbGRDb3VudCA9PT0gMiA/IGUudHIucmVwbGFjZShcbiAgICAgICAgICAgICAgaSArIGEubm9kZVNpemUgKyAxLFxuICAgICAgICAgICAgICBzIC0gMSxcbiAgICAgICAgICAgICAgbmV3IFAoTy5mcm9tKHApLCAwLCAwKVxuICAgICAgICAgICAgKSA6IGUudHIuaW5zZXJ0KFxuICAgICAgICAgICAgICBpICsgYS5ub2RlU2l6ZSxcbiAgICAgICAgICAgICAgZS5zY2hlbWEubm9kZXMuYmxvY2tHcm91cC5jcmVhdGUoe30sIHApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodC5jb250ZW50ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGxldCBwID0gW107XG4gICAgICAgICAgICB0eXBlb2YgdC5jb250ZW50ID09IFwic3RyaW5nXCIgPyBwLnB1c2goZS5zY2hlbWEudGV4dCh0LmNvbnRlbnQpKSA6IHAgPSBFdCh0LmNvbnRlbnQsIGUuc2NoZW1hKSwgZS50ci5yZXBsYWNlKFxuICAgICAgICAgICAgICBpICsgMSxcbiAgICAgICAgICAgICAgaSArIGEubm9kZVNpemUgLSAxLFxuICAgICAgICAgICAgICBuZXcgUChPLmZyb20ocCksIDAsIDApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBkID0gYS50eXBlLm5hbWUsIGMgPSB0LnR5cGUgfHwgZCwgaCA9IGUuc2NoZW1hLm5vZGVzW2RdLnNwZWMuY29udGVudCwgbSA9IGUuc2NoZW1hLm5vZGVzW2NdLnNwZWMuY29udGVudDtcbiAgICAgICAgICBoID09PSBcImlubGluZSpcIiAmJiBtID09PSBcIlwiID8gZS50ci5yZXBsYWNlV2l0aChcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBzLFxuICAgICAgICAgICAgZS5zY2hlbWEubm9kZXNbY10uY3JlYXRlKHtcbiAgICAgICAgICAgICAgLi4uYS5hdHRycyxcbiAgICAgICAgICAgICAgLi4udC5wcm9wc1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICApLnNldFNlbGVjdGlvbihcbiAgICAgICAgICAgIG5ldyBmdChlLnRyLmRvYy5yZXNvbHZlKGkpKVxuICAgICAgICAgICkgOiBlLnRyLnNldE5vZGVNYXJrdXAoXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgdC50eXBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLnNjaGVtYS5ub2Rlc1t0LnR5cGVdLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAuLi5hLmF0dHJzLFxuICAgICAgICAgICAgICAuLi50LnByb3BzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKSwgZS50ci5zZXROb2RlTWFya3VwKGkgLSAxLCB2b2lkIDAsIHtcbiAgICAgICAgICAgIC4uLmwuYXR0cnMsXG4gICAgICAgICAgICAuLi50LnByb3BzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfSxcbiAgICAgIC8vIEFwcGVuZHMgdGhlIHRleHQgY29udGVudHMgb2YgYSBibG9jayB0byB0aGUgbmVhcmVzdCBwcmV2aW91cyBibG9jaywgZ2l2ZW4gYSBwb3NpdGlvbiBiZXR3ZWVuIHRoZW0uIENoaWxkcmVuIG9mXG4gICAgICAvLyB0aGUgbWVyZ2VkIGJsb2NrIGFyZSBtb3ZlZCBvdXQgb2YgaXQgZmlyc3QsIHJhdGhlciB0aGFuIGFsc28gYmVpbmcgbWVyZ2VkLlxuICAgICAgLy9cbiAgICAgIC8vIEluIHRoZSBleGFtcGxlIGJlbG93LCB0aGUgcG9zaXRpb24gcGFzc2VkIGludG8gdGhlIGZ1bmN0aW9uIGlzIGJldHdlZW4gQmxvY2sxIGFuZCBCbG9jazIuXG4gICAgICAvL1xuICAgICAgLy8gQmxvY2sxXG4gICAgICAvLyAgICBCbG9jazJcbiAgICAgIC8vIEJsb2NrM1xuICAgICAgLy8gICAgQmxvY2s0XG4gICAgICAvLyAgICAgICAgQmxvY2s1XG4gICAgICAvL1xuICAgICAgLy8gQmVjb21lczpcbiAgICAgIC8vXG4gICAgICAvLyBCbG9jazFcbiAgICAgIC8vICAgIEJsb2NrMkJsb2NrM1xuICAgICAgLy8gQmxvY2s0XG4gICAgICAvLyAgICAgQmxvY2s1XG4gICAgICBCTk1lcmdlQmxvY2tzOiAobikgPT4gKHsgc3RhdGU6IHQsIGRpc3BhdGNoOiBlIH0pID0+IHtcbiAgICAgICAgY29uc3QgbyA9IHQuZG9jLnJlc29sdmUobiArIDEpLm5vZGUoKS50eXBlLm5hbWUgPT09IFwiYmxvY2tDb250YWluZXJcIiwgciA9IHQuZG9jLnJlc29sdmUobiAtIDEpLm5vZGUoKS50eXBlLm5hbWUgPT09IFwiYmxvY2tDb250YWluZXJcIjtcbiAgICAgICAgaWYgKCFvIHx8ICFyKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgY29uc3QgaSA9IHYoXG4gICAgICAgICAgdC5kb2MsXG4gICAgICAgICAgbiArIDFcbiAgICAgICAgKSwgeyBub2RlOiBzLCBjb250ZW50Tm9kZTogbCwgc3RhcnRQb3M6IGEsIGVuZFBvczogZCwgZGVwdGg6IGMgfSA9IGk7XG4gICAgICAgIGlmIChzLmNoaWxkQ291bnQgPT09IDIpIHtcbiAgICAgICAgICBjb25zdCBwID0gdC5kb2MucmVzb2x2ZShcbiAgICAgICAgICAgIGEgKyBsLm5vZGVTaXplICsgMVxuICAgICAgICAgICksIGYgPSB0LmRvYy5yZXNvbHZlKGQgLSAxKSwgYiA9IHAuYmxvY2tSYW5nZShmKTtcbiAgICAgICAgICBlICYmIHQudHIubGlmdChiLCBjIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGggPSBuIC0gMSwgbSA9IHYodC5kb2MsIGgpO1xuICAgICAgICBmb3IgKDsgbS5udW1DaGlsZEJsb2NrcyA+IDA7IClcbiAgICAgICAgICBpZiAoaC0tLCBtID0gdih0LmRvYywgaCksIG0gPT09IHZvaWQgMClcbiAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgcmV0dXJuIGUgJiYgKGUoXG4gICAgICAgICAgdC50ci5kZWxldGVSYW5nZShhLCBhICsgbC5ub2RlU2l6ZSkucmVwbGFjZShcbiAgICAgICAgICAgIGggLSAxLFxuICAgICAgICAgICAgYSxcbiAgICAgICAgICAgIG5ldyBQKGwuY29udGVudCwgMCwgMClcbiAgICAgICAgICApLnNjcm9sbEludG9WaWV3KClcbiAgICAgICAgKSwgdC50ci5zZXRTZWxlY3Rpb24oXG4gICAgICAgICAgbmV3IHN0KHQuZG9jLnJlc29sdmUoaCAtIDEpKVxuICAgICAgICApKSwgITA7XG4gICAgICB9LFxuICAgICAgLy8gU3BsaXRzIGEgYmxvY2sgYXQgYSBnaXZlbiBwb3NpdGlvbi4gQ29udGVudCBhZnRlciB0aGUgcG9zaXRpb24gaXMgbW92ZWQgdG8gYSBuZXcgYmxvY2sgYmVsb3csIGF0IHRoZSBzYW1lXG4gICAgICAvLyBuZXN0aW5nIGxldmVsLlxuICAgICAgQk5TcGxpdEJsb2NrOiAobiwgdCkgPT4gKHsgc3RhdGU6IGUsIGRpc3BhdGNoOiBvIH0pID0+IHtcbiAgICAgICAgY29uc3QgciA9IHYoZS5kb2MsIG4pO1xuICAgICAgICBpZiAociA9PT0gdm9pZCAwKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgY29uc3QgeyBjb250ZW50Tm9kZTogaSwgY29udGVudFR5cGU6IHMsIHN0YXJ0UG9zOiBsLCBlbmRQb3M6IGEsIGRlcHRoOiBkIH0gPSByLCBjID0gZS5kb2MuY3V0KGwgKyAxLCBuKSwgaCA9IGUuZG9jLmN1dChuLCBhIC0gMSksIG0gPSBlLnNjaGVtYS5ub2Rlcy5ibG9ja0NvbnRhaW5lci5jcmVhdGVBbmRGaWxsKCksIHAgPSBhICsgMSwgZiA9IHAgKyAyO1xuICAgICAgICByZXR1cm4gbyAmJiAoZS50ci5pbnNlcnQocCwgbSksIGUudHIucmVwbGFjZShcbiAgICAgICAgICBmLFxuICAgICAgICAgIGYgKyAxLFxuICAgICAgICAgIGguY29udGVudC5zaXplID4gMCA/IG5ldyBQKFxuICAgICAgICAgICAgTy5mcm9tKGgpLFxuICAgICAgICAgICAgZCArIDIsXG4gICAgICAgICAgICBkICsgMlxuICAgICAgICAgICkgOiB2b2lkIDBcbiAgICAgICAgKSwgdCAmJiBlLnRyLnNldEJsb2NrVHlwZShcbiAgICAgICAgICBmLFxuICAgICAgICAgIGYsXG4gICAgICAgICAgZS5zY2hlbWEubm9kZShzKS50eXBlLFxuICAgICAgICAgIGkuYXR0cnNcbiAgICAgICAgKSwgZS50ci5zZXRTZWxlY3Rpb24oXG4gICAgICAgICAgbmV3IHN0KGUuZG9jLnJlc29sdmUoZikpXG4gICAgICAgICksIGUudHIucmVwbGFjZShcbiAgICAgICAgICBsICsgMSxcbiAgICAgICAgICBhIC0gMSxcbiAgICAgICAgICBjLmNvbnRlbnQuc2l6ZSA+IDAgPyBuZXcgUChcbiAgICAgICAgICAgIE8uZnJvbShjKSxcbiAgICAgICAgICAgIGQgKyAyLFxuICAgICAgICAgICAgZCArIDJcbiAgICAgICAgICApIDogdm9pZCAwXG4gICAgICAgICkpLCAhMDtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIFtWZSgpLCAkZSgpXTtcbiAgfSxcbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEJhY2tzcGFjZTogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuZmlyc3QoKHsgY29tbWFuZHM6IG8gfSkgPT4gW1xuICAgICAgICAvLyBEZWxldGVzIHRoZSBzZWxlY3Rpb24gaWYgaXQncyBub3QgZW1wdHkuXG4gICAgICAgICgpID0+IG8uZGVsZXRlU2VsZWN0aW9uKCksXG4gICAgICAgIC8vIFVuZG9lcyBhbiBpbnB1dCBydWxlIGlmIG9uZSB3YXMgdHJpZ2dlcmVkIGluIHRoZSBsYXN0IGVkaXRvciBzdGF0ZSBjaGFuZ2UuXG4gICAgICAgICgpID0+IG8udW5kb0lucHV0UnVsZSgpLFxuICAgICAgICAvLyBSZXZlcnRzIGJsb2NrIGNvbnRlbnQgdHlwZSB0byBhIHBhcmFncmFwaCBpZiB0aGUgc2VsZWN0aW9uIGlzIGF0IHRoZSBzdGFydCBvZiB0aGUgYmxvY2suXG4gICAgICAgICgpID0+IG8uY29tbWFuZCgoeyBzdGF0ZTogciB9KSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBjb250ZW50VHlwZTogaSB9ID0gdihcbiAgICAgICAgICAgIHIuZG9jLFxuICAgICAgICAgICAgci5zZWxlY3Rpb24uZnJvbVxuICAgICAgICAgICksIHMgPSByLnNlbGVjdGlvbi4kYW5jaG9yLnBhcmVudE9mZnNldCA9PT0gMCwgbCA9IGkubmFtZSA9PT0gXCJwYXJhZ3JhcGhcIjtcbiAgICAgICAgICByZXR1cm4gcyAmJiAhbCA/IG8uQk5VcGRhdGVCbG9jayhyLnNlbGVjdGlvbi5mcm9tLCB7XG4gICAgICAgICAgICB0eXBlOiBcInBhcmFncmFwaFwiLFxuICAgICAgICAgICAgcHJvcHM6IHt9XG4gICAgICAgICAgfSkgOiAhMTtcbiAgICAgICAgfSksXG4gICAgICAgIC8vIFJlbW92ZXMgYSBsZXZlbCBvZiBuZXN0aW5nIGlmIHRoZSBibG9jayBpcyBpbmRlbnRlZCBpZiB0aGUgc2VsZWN0aW9uIGlzIGF0IHRoZSBzdGFydCBvZiB0aGUgYmxvY2suXG4gICAgICAgICgpID0+IG8uY29tbWFuZCgoeyBzdGF0ZTogciB9KSA9PiByLnNlbGVjdGlvbi4kYW5jaG9yLnBhcmVudE9mZnNldCA9PT0gMCA/IG8ubGlmdExpc3RJdGVtKFwiYmxvY2tDb250YWluZXJcIikgOiAhMSksXG4gICAgICAgIC8vIE1lcmdlcyBibG9jayB3aXRoIHRoZSBwcmV2aW91cyBvbmUgaWYgaXQgaXNuJ3QgaW5kZW50ZWQsIGlzbid0IHRoZSBmaXJzdCBibG9jayBpbiB0aGUgZG9jLCBhbmQgdGhlIHNlbGVjdGlvblxuICAgICAgICAvLyBpcyBhdCB0aGUgc3RhcnQgb2YgdGhlIGJsb2NrLlxuICAgICAgICAoKSA9PiBvLmNvbW1hbmQoKHsgc3RhdGU6IHIgfSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgZGVwdGg6IGksIHN0YXJ0UG9zOiBzIH0gPSB2KFxuICAgICAgICAgICAgci5kb2MsXG4gICAgICAgICAgICByLnNlbGVjdGlvbi5mcm9tXG4gICAgICAgICAgKSwgbCA9IHIuc2VsZWN0aW9uLiRhbmNob3IucGFyZW50T2Zmc2V0ID09PSAwLCBhID0gci5zZWxlY3Rpb24uYW5jaG9yID09PSByLnNlbGVjdGlvbi5oZWFkLCBkID0gcyA9PT0gMiwgYyA9IHMgLSAxO1xuICAgICAgICAgIHJldHVybiAhZCAmJiBsICYmIGEgJiYgaSA9PT0gMiA/IG8uQk5NZXJnZUJsb2NrcyhjKSA6ICExO1xuICAgICAgICB9KVxuICAgICAgXSksXG4gICAgICBEZWxldGU6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLmZpcnN0KCh7IGNvbW1hbmRzOiBvIH0pID0+IFtcbiAgICAgICAgLy8gRGVsZXRlcyB0aGUgc2VsZWN0aW9uIGlmIGl0J3Mgbm90IGVtcHR5LlxuICAgICAgICAoKSA9PiBvLmRlbGV0ZVNlbGVjdGlvbigpLFxuICAgICAgICAvLyBNZXJnZXMgYmxvY2sgd2l0aCB0aGUgbmV4dCBvbmUgKGF0IHRoZSBzYW1lIG5lc3RpbmcgbGV2ZWwgb3IgbG93ZXIpLFxuICAgICAgICAvLyBpZiBvbmUgZXhpc3RzLCB0aGUgYmxvY2sgaGFzIG5vIGNoaWxkcmVuLCBhbmQgdGhlIHNlbGVjdGlvbiBpcyBhdCB0aGVcbiAgICAgICAgLy8gZW5kIG9mIHRoZSBibG9jay5cbiAgICAgICAgKCkgPT4gby5jb21tYW5kKCh7IHN0YXRlOiByIH0pID0+IHtcbiAgICAgICAgICBjb25zdCB7IG5vZGU6IGksIGNvbnRlbnROb2RlOiBzLCBkZXB0aDogbCwgZW5kUG9zOiBhIH0gPSB2KFxuICAgICAgICAgICAgci5kb2MsXG4gICAgICAgICAgICByLnNlbGVjdGlvbi5mcm9tXG4gICAgICAgICAgKSwgZCA9IHIuc2VsZWN0aW9uLiRhbmNob3IucGFyZW50T2Zmc2V0ID09PSBzLmZpcnN0Q2hpbGQubm9kZVNpemUsIGMgPSByLnNlbGVjdGlvbi5hbmNob3IgPT09IHIuc2VsZWN0aW9uLmhlYWQsIGggPSBpLmNoaWxkQ291bnQgPT09IDI7XG4gICAgICAgICAgaWYgKGQgJiYgYyAmJiAhaCkge1xuICAgICAgICAgICAgbGV0IG0gPSBsLCBwID0gYSArIDIsIGYgPSByLmRvYy5yZXNvbHZlKHApLmRlcHRoO1xuICAgICAgICAgICAgZm9yICg7IGYgPCBtOyApXG4gICAgICAgICAgICAgIG0gPSBmLCBwICs9IDIsIGYgPSByLmRvYy5yZXNvbHZlKHApLmRlcHRoO1xuICAgICAgICAgICAgcmV0dXJuIG8uQk5NZXJnZUJsb2NrcyhwIC0gMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgfSlcbiAgICAgIF0pLFxuICAgICAgRW50ZXI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLmZpcnN0KCh7IGNvbW1hbmRzOiBvIH0pID0+IFtcbiAgICAgICAgLy8gUmVtb3ZlcyBhIGxldmVsIG9mIG5lc3RpbmcgaWYgdGhlIGJsb2NrIGlzIGVtcHR5ICYgaW5kZW50ZWQsIHdoaWxlIHRoZSBzZWxlY3Rpb24gaXMgYWxzbyBlbXB0eSAmIGF0IHRoZSBzdGFydFxuICAgICAgICAvLyBvZiB0aGUgYmxvY2suXG4gICAgICAgICgpID0+IG8uY29tbWFuZCgoeyBzdGF0ZTogciB9KSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBub2RlOiBpLCBkZXB0aDogcyB9ID0gdihcbiAgICAgICAgICAgIHIuZG9jLFxuICAgICAgICAgICAgci5zZWxlY3Rpb24uZnJvbVxuICAgICAgICAgICksIGwgPSByLnNlbGVjdGlvbi4kYW5jaG9yLnBhcmVudE9mZnNldCA9PT0gMCwgYSA9IHIuc2VsZWN0aW9uLmFuY2hvciA9PT0gci5zZWxlY3Rpb24uaGVhZCwgZCA9IGkudGV4dENvbnRlbnQubGVuZ3RoID09PSAwLCBjID0gcyA+IDI7XG4gICAgICAgICAgcmV0dXJuIGwgJiYgYSAmJiBkICYmIGMgPyBvLmxpZnRMaXN0SXRlbShcImJsb2NrQ29udGFpbmVyXCIpIDogITE7XG4gICAgICAgIH0pLFxuICAgICAgICAvLyBDcmVhdGVzIGEgbmV3IGJsb2NrIGFuZCBtb3ZlcyB0aGUgc2VsZWN0aW9uIHRvIGl0IGlmIHRoZSBjdXJyZW50IG9uZSBpcyBlbXB0eSwgd2hpbGUgdGhlIHNlbGVjdGlvbiBpcyBhbHNvXG4gICAgICAgIC8vIGVtcHR5ICYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBibG9jay5cbiAgICAgICAgKCkgPT4gby5jb21tYW5kKCh7IHN0YXRlOiByLCBjaGFpbjogaSB9KSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBub2RlOiBzLCBlbmRQb3M6IGwgfSA9IHYoXG4gICAgICAgICAgICByLmRvYyxcbiAgICAgICAgICAgIHIuc2VsZWN0aW9uLmZyb21cbiAgICAgICAgICApLCBhID0gci5zZWxlY3Rpb24uJGFuY2hvci5wYXJlbnRPZmZzZXQgPT09IDAsIGQgPSByLnNlbGVjdGlvbi5hbmNob3IgPT09IHIuc2VsZWN0aW9uLmhlYWQsIGMgPSBzLnRleHRDb250ZW50Lmxlbmd0aCA9PT0gMDtcbiAgICAgICAgICBpZiAoYSAmJiBkICYmIGMpIHtcbiAgICAgICAgICAgIGNvbnN0IGggPSBsICsgMSwgbSA9IGggKyAyO1xuICAgICAgICAgICAgcmV0dXJuIGkoKS5CTkNyZWF0ZUJsb2NrKGgpLnNldFRleHRTZWxlY3Rpb24obSkucnVuKCksICEwO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIH0pLFxuICAgICAgICAvLyBTcGxpdHMgdGhlIGN1cnJlbnQgYmxvY2ssIG1vdmluZyBjb250ZW50IGluc2lkZSB0aGF0J3MgYWZ0ZXIgdGhlIGN1cnNvciB0byBhIG5ldyB0ZXh0IGJsb2NrIGJlbG93LiBBbHNvXG4gICAgICAgIC8vIGRlbGV0ZXMgdGhlIHNlbGVjdGlvbiBiZWZvcmVoYW5kLCBpZiBpdCdzIG5vdCBlbXB0eS5cbiAgICAgICAgKCkgPT4gby5jb21tYW5kKCh7IHN0YXRlOiByLCBjaGFpbjogaSB9KSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBub2RlOiBzIH0gPSB2KFxuICAgICAgICAgICAgci5kb2MsXG4gICAgICAgICAgICByLnNlbGVjdGlvbi5mcm9tXG4gICAgICAgICAgKSwgbCA9IHIuc2VsZWN0aW9uLiRhbmNob3IucGFyZW50T2Zmc2V0ID09PSAwO1xuICAgICAgICAgIHJldHVybiBzLnRleHRDb250ZW50Lmxlbmd0aCA9PT0gMCA/ICExIDogKGkoKS5kZWxldGVTZWxlY3Rpb24oKS5CTlNwbGl0QmxvY2soci5zZWxlY3Rpb24uZnJvbSwgbCkucnVuKCksICEwKTtcbiAgICAgICAgfSlcbiAgICAgIF0pLFxuICAgICAgLy8gQWx3YXlzIHJldHVybmluZyB0cnVlIGZvciB0YWIga2V5IHByZXNzZXMgZW5zdXJlcyB0aGV5J3JlIG5vdCBjYXB0dXJlZCBieSB0aGUgYnJvd3Nlci4gT3RoZXJ3aXNlLCB0aGV5IGJsdXIgdGhlXG4gICAgICAvLyBlZGl0b3Igc2luY2UgdGhlIGJyb3dzZXIgd2lsbCB0cnkgdG8gdXNlIHRhYiBmb3Iga2V5Ym9hcmQgbmF2aWdhdGlvbi5cbiAgICAgIFRhYjogKCkgPT4gKHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNpbmtMaXN0SXRlbShcImJsb2NrQ29udGFpbmVyXCIpLCAhMCksXG4gICAgICBcIlNoaWZ0LVRhYlwiOiAoKSA9PiAodGhpcy5lZGl0b3IuY29tbWFuZHMubGlmdExpc3RJdGVtKFwiYmxvY2tDb250YWluZXJcIiksICEwKSxcbiAgICAgIFwiTW9kLUFsdC0wXCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLkJOQ3JlYXRlQmxvY2soXG4gICAgICAgIHRoaXMuZWRpdG9yLnN0YXRlLnNlbGVjdGlvbi5hbmNob3IgKyAyXG4gICAgICApXG4gICAgfTtcbiAgfVxufSksIEdlID0gcS5jcmVhdGUoe1xuICBuYW1lOiBcImJsb2NrR3JvdXBcIixcbiAgZ3JvdXA6IFwiYmxvY2tHcm91cFwiLFxuICBjb250ZW50OiBcImJsb2NrQ29udGFpbmVyK1wiLFxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdGFnOiBcImRpdlwiLFxuICAgICAgICBnZXRBdHRyczogKG4pID0+IHR5cGVvZiBuID09IFwic3RyaW5nXCIgPyAhMSA6IG4uZ2V0QXR0cmlidXRlKFwiZGF0YS1ub2RlLXR5cGVcIikgPT09IFwiYmxvY2tHcm91cFwiID8gbnVsbCA6ICExXG4gICAgICB9XG4gICAgXTtcbiAgfSxcbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzOiBuIH0pIHtcbiAgICB2YXIgZTtcbiAgICBjb25zdCB0ID0gKChlID0gdGhpcy5vcHRpb25zLmRvbUF0dHJpYnV0ZXMpID09IG51bGwgPyB2b2lkIDAgOiBlLmJsb2NrR3JvdXApIHx8IHt9O1xuICAgIHJldHVybiBbXG4gICAgICBcImRpdlwiLFxuICAgICAgRChcbiAgICAgICAge1xuICAgICAgICAgIC4uLnQsXG4gICAgICAgICAgY2xhc3M6IEIoXG4gICAgICAgICAgICBrLmJsb2NrR3JvdXAsXG4gICAgICAgICAgICB0LmNsYXNzXG4gICAgICAgICAgKSxcbiAgICAgICAgICBcImRhdGEtbm9kZS10eXBlXCI6IFwiYmxvY2tHcm91cFwiXG4gICAgICAgIH0sXG4gICAgICAgIG5cbiAgICAgICksXG4gICAgICAwXG4gICAgXTtcbiAgfVxufSksIGplID0gcS5jcmVhdGUoe1xuICBuYW1lOiBcImRvY1wiLFxuICB0b3BOb2RlOiAhMCxcbiAgY29udGVudDogXCJibG9ja0dyb3VwXCJcbn0pLCBxZSA9IChuKSA9PiB7XG4gIGNvbnN0IHQgPSBKLmZyb21TY2hlbWEobik7XG4gIHJldHVybiBuZXcgSihcbiAgICB7XG4gICAgICAuLi50Lm5vZGVzXG4gICAgICAvLyBUT0RPOiBJZiBhIHNlcmlhbGl6ZXIgaXMgZGVmaW5lZCBpbiB0aGUgY29uZmlnIGZvciBhIGN1c3RvbSBibG9jaywgaXRcbiAgICAgIC8vICBzaG91bGQgYmUgYWRkZWQgaGVyZS4gV2Ugc3RpbGwgbmVlZCB0byBmaWd1cmUgb3V0IGhvdyB0aGUgc2VyaWFsaXplclxuICAgICAgLy8gIHNob3VsZCBiZSBkZWZpbmVkIGluIHRoZSBjdXN0b20gYmxvY2tzIEFQSSB0aG91Z2gsIGFuZCBpbXBsZW1lbnQgdGhhdCxcbiAgICAgIC8vICBiZWZvcmUgd2UgY2FuIGRvIHRoaXMuXG4gICAgfSxcbiAgICB0Lm1hcmtzXG4gICk7XG59LCBYZSA9IEwuY3JlYXRlKHtcbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgSSh7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgY2xpcGJvYXJkU2VyaWFsaXplcjogcWUodGhpcy5lZGl0b3Iuc2NoZW1hKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIF07XG4gIH1cbn0pO1xuY2xhc3MgJCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG4gICAgdSh0aGlzLCBcImNhbGxiYWNrc1wiLCB7fSk7XG4gIH1cbiAgb24odCwgZSkge1xuICAgIHJldHVybiB0aGlzLmNhbGxiYWNrc1t0XSB8fCAodGhpcy5jYWxsYmFja3NbdF0gPSBbXSksIHRoaXMuY2FsbGJhY2tzW3RdLnB1c2goZSksICgpID0+IHRoaXMub2ZmKHQsIGUpO1xuICB9XG4gIGVtaXQodCwgLi4uZSkge1xuICAgIGNvbnN0IG8gPSB0aGlzLmNhbGxiYWNrc1t0XTtcbiAgICBvICYmIG8uZm9yRWFjaCgocikgPT4gci5hcHBseSh0aGlzLCBlKSk7XG4gIH1cbiAgb2ZmKHQsIGUpIHtcbiAgICBjb25zdCBvID0gdGhpcy5jYWxsYmFja3NbdF07XG4gICAgbyAmJiAoZSA/IHRoaXMuY2FsbGJhY2tzW3RdID0gby5maWx0ZXIoKHIpID0+IHIgIT09IGUpIDogZGVsZXRlIHRoaXMuY2FsbGJhY2tzW3RdKTtcbiAgfVxuICByZW1vdmVBbGxMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5jYWxsYmFja3MgPSB7fTtcbiAgfVxufVxuY29uc3QgS2UgPSBvZShcbiAgKG4pID0+IG4udHlwZS5uYW1lID09PSBcImJsb2NrQ29udGFpbmVyXCJcbik7XG5jbGFzcyBZZSB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIG8gPSAoKSA9PiB7XG4gIH0pIHtcbiAgICB1KHRoaXMsIFwic3VnZ2VzdGlvbnNNZW51U3RhdGVcIik7XG4gICAgdSh0aGlzLCBcInVwZGF0ZVN1Z2dlc3Rpb25zTWVudVwiKTtcbiAgICB1KHRoaXMsIFwicGx1Z2luU3RhdGVcIik7XG4gICAgdSh0aGlzLCBcImhhbmRsZVNjcm9sbFwiLCAoKSA9PiB7XG4gICAgICB2YXIgdDtcbiAgICAgIGlmICgodCA9IHRoaXMuc3VnZ2VzdGlvbnNNZW51U3RhdGUpICE9IG51bGwgJiYgdC5zaG93KSB7XG4gICAgICAgIGNvbnN0IGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgIGBbZGF0YS1kZWNvcmF0aW9uLWlkPVwiJHt0aGlzLnBsdWdpblN0YXRlLmRlY29yYXRpb25JZH1cIl1gXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuc3VnZ2VzdGlvbnNNZW51U3RhdGUucmVmZXJlbmNlUG9zID0gZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgdGhpcy51cGRhdGVTdWdnZXN0aW9uc01lbnUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmVkaXRvciA9IHQsIHRoaXMucGx1Z2luS2V5ID0gZSwgdGhpcy5wbHVnaW5TdGF0ZSA9IFooKSwgdGhpcy51cGRhdGVTdWdnZXN0aW9uc01lbnUgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuc3VnZ2VzdGlvbnNNZW51U3RhdGUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0dGVtcHRpbmcgdG8gdXBkYXRlIHVuaW5pdGlhbGl6ZWQgc3VnZ2VzdGlvbnMgbWVudVwiKTtcbiAgICAgIG8odGhpcy5zdWdnZXN0aW9uc01lbnVTdGF0ZSk7XG4gICAgfSwgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLmhhbmRsZVNjcm9sbCk7XG4gIH1cbiAgdXBkYXRlKHQsIGUpIHtcbiAgICBjb25zdCBvID0gdGhpcy5wbHVnaW5LZXkuZ2V0U3RhdGUoZSksIHIgPSB0aGlzLnBsdWdpbktleS5nZXRTdGF0ZSh0LnN0YXRlKSwgaSA9ICFvLmFjdGl2ZSAmJiByLmFjdGl2ZSwgcyA9IG8uYWN0aXZlICYmICFyLmFjdGl2ZSwgbCA9IG8uYWN0aXZlICYmIHIuYWN0aXZlO1xuICAgIGlmICghaSAmJiAhbCAmJiAhcylcbiAgICAgIHJldHVybjtcbiAgICBpZiAodGhpcy5wbHVnaW5TdGF0ZSA9IHMgPyBvIDogciwgcyB8fCAhdGhpcy5lZGl0b3IuaXNFZGl0YWJsZSkge1xuICAgICAgdGhpcy5zdWdnZXN0aW9uc01lbnVTdGF0ZS5zaG93ID0gITEsIHRoaXMudXBkYXRlU3VnZ2VzdGlvbnNNZW51KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGEgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgYFtkYXRhLWRlY29yYXRpb24taWQ9XCIke3RoaXMucGx1Z2luU3RhdGUuZGVjb3JhdGlvbklkfVwiXWBcbiAgICApO1xuICAgIHRoaXMuZWRpdG9yLmlzRWRpdGFibGUgJiYgKHRoaXMuc3VnZ2VzdGlvbnNNZW51U3RhdGUgPSB7XG4gICAgICBzaG93OiAhMCxcbiAgICAgIHJlZmVyZW5jZVBvczogYS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIGZpbHRlcmVkSXRlbXM6IHRoaXMucGx1Z2luU3RhdGUuaXRlbXMsXG4gICAgICBrZXlib2FyZEhvdmVyZWRJdGVtSW5kZXg6IHRoaXMucGx1Z2luU3RhdGUua2V5Ym9hcmRIb3ZlcmVkSXRlbUluZGV4XG4gICAgfSwgdGhpcy51cGRhdGVTdWdnZXN0aW9uc01lbnUoKSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMuaGFuZGxlU2Nyb2xsKTtcbiAgfVxufVxuZnVuY3Rpb24gWigpIHtcbiAgcmV0dXJuIHtcbiAgICBhY3RpdmU6ICExLFxuICAgIHRyaWdnZXJDaGFyYWN0ZXI6IHZvaWQgMCxcbiAgICBxdWVyeVN0YXJ0UG9zOiB2b2lkIDAsXG4gICAgaXRlbXM6IFtdLFxuICAgIGtleWJvYXJkSG92ZXJlZEl0ZW1JbmRleDogdm9pZCAwLFxuICAgIG5vdEZvdW5kQ291bnQ6IDAsXG4gICAgZGVjb3JhdGlvbklkOiB2b2lkIDBcbiAgfTtcbn1cbmNvbnN0IEplID0gKG4sIHQsIGUsIG8sIHIgPSAoKSA9PiBbXSwgaSA9ICgpID0+IHtcbn0pID0+IHtcbiAgaWYgKG8ubGVuZ3RoICE9PSAxKVxuICAgIHRocm93IG5ldyBFcnJvcihcIidjaGFyJyBzaG91bGQgYmUgYSBzaW5nbGUgY2hhcmFjdGVyXCIpO1xuICBsZXQgcztcbiAgY29uc3QgbCA9IChhKSA9PiB7XG4gICAgYS5kaXNwYXRjaChhLnN0YXRlLnRyLnNldE1ldGEoZSwgeyBkZWFjdGl2YXRlOiAhMCB9KSk7XG4gIH07XG4gIHJldHVybiB7XG4gICAgcGx1Z2luOiBuZXcgSSh7XG4gICAgICBrZXk6IGUsXG4gICAgICB2aWV3OiAoKSA9PiAocyA9IG5ldyBZZShcbiAgICAgICAgbixcbiAgICAgICAgZSxcbiAgICAgICAgdFxuICAgICAgKSwgcyksXG4gICAgICBzdGF0ZToge1xuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBwbHVnaW4ncyBpbnRlcm5hbCBzdGF0ZS5cbiAgICAgICAgaW5pdCgpIHtcbiAgICAgICAgICByZXR1cm4gWigpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBBcHBseSBjaGFuZ2VzIHRvIHRoZSBwbHVnaW4gc3RhdGUgZnJvbSBhbiBlZGl0b3IgdHJhbnNhY3Rpb24uXG4gICAgICAgIGFwcGx5KGEsIGQsIGMsIGgpIHtcbiAgICAgICAgICB2YXIgcCwgZiwgYiwgdztcbiAgICAgICAgICBpZiAoYS5nZXRNZXRhKFwib3JkZXJlZExpc3RJbmRleGluZ1wiKSAhPT0gdm9pZCAwKVxuICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgaWYgKChwID0gYS5nZXRNZXRhKGUpKSAhPSBudWxsICYmIHAuYWN0aXZhdGUpXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBhY3RpdmU6ICEwLFxuICAgICAgICAgICAgICB0cmlnZ2VyQ2hhcmFjdGVyOiAoKGYgPSBhLmdldE1ldGEoZSkpID09IG51bGwgPyB2b2lkIDAgOiBmLnRyaWdnZXJDaGFyYWN0ZXIpIHx8IFwiXCIsXG4gICAgICAgICAgICAgIHF1ZXJ5U3RhcnRQb3M6IGguc2VsZWN0aW9uLmZyb20sXG4gICAgICAgICAgICAgIGl0ZW1zOiByKFwiXCIpLFxuICAgICAgICAgICAgICBrZXlib2FyZEhvdmVyZWRJdGVtSW5kZXg6IDAsXG4gICAgICAgICAgICAgIC8vIFRPRE86IE1heWJlIHNob3VsZCBiZSAxIGlmIHRoZSBtZW51IGhhcyBubyBwb3NzaWJsZSBpdGVtcz8gUHJvYmFibHkgcmVkdW5kYW50IHNpbmNlIGEgbWVudSB3aXRoIG5vIGl0ZW1zXG4gICAgICAgICAgICAgIC8vICBpcyB1c2VsZXNzIGluIHByYWN0aWNlLlxuICAgICAgICAgICAgICBub3RGb3VuZENvdW50OiAwLFxuICAgICAgICAgICAgICBkZWNvcmF0aW9uSWQ6IGBpZF8ke01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDQyOTQ5NjcyOTUpfWBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKCFkLmFjdGl2ZSlcbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgIGNvbnN0IG0gPSB7IC4uLmQgfTtcbiAgICAgICAgICBpZiAobS5pdGVtcyA9IHIoXG4gICAgICAgICAgICBoLmRvYy50ZXh0QmV0d2VlbihcbiAgICAgICAgICAgICAgZC5xdWVyeVN0YXJ0UG9zLFxuICAgICAgICAgICAgICBoLnNlbGVjdGlvbi5mcm9tXG4gICAgICAgICAgICApXG4gICAgICAgICAgKSwgbS5ub3RGb3VuZENvdW50ID0gMCwgbS5pdGVtcy5sZW5ndGggPT09IDAgJiYgKG0ubm90Rm91bmRDb3VudCA9IE1hdGgubWF4KFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIGQubm90Rm91bmRDb3VudCArIChoLnNlbGVjdGlvbi5mcm9tIC0gYy5zZWxlY3Rpb24uZnJvbSlcbiAgICAgICAgICApKSwgLy8gSGlnaGxpZ2h0aW5nIHRleHQgc2hvdWxkIGhpZGUgdGhlIG1lbnUuXG4gICAgICAgICAgaC5zZWxlY3Rpb24uZnJvbSAhPT0gaC5zZWxlY3Rpb24udG8gfHwgLy8gVHJhbnNhY3Rpb25zIHdpdGggcGx1Z2luIG1ldGFkYXRhIHtkZWFjdGl2YXRlOiB0cnVlfSBzaG91bGQgaGlkZSB0aGUgbWVudS5cbiAgICAgICAgICAoYiA9IGEuZ2V0TWV0YShlKSkgIT0gbnVsbCAmJiBiLmRlYWN0aXZhdGUgfHwgLy8gQ2VydGFpbiBtb3VzZSBldmVudHMgc2hvdWxkIGhpZGUgdGhlIG1lbnUuXG4gICAgICAgICAgLy8gVE9ETzogQ2hhbmdlIHRvIGdsb2JhbCBtb3VzZWRvd24gbGlzdGVuZXIuXG4gICAgICAgICAgYS5nZXRNZXRhKFwiZm9jdXNcIikgfHwgYS5nZXRNZXRhKFwiYmx1clwiKSB8fCBhLmdldE1ldGEoXCJwb2ludGVyXCIpIHx8IC8vIE1vdmluZyB0aGUgY2FyZXQgYmVmb3JlIHRoZSBjaGFyYWN0ZXIgd2hpY2ggdHJpZ2dlcmVkIHRoZSBtZW51IHNob3VsZCBoaWRlIGl0LlxuICAgICAgICAgIGQuYWN0aXZlICYmIGguc2VsZWN0aW9uLmZyb20gPCBkLnF1ZXJ5U3RhcnRQb3MgfHwgLy8gRW50ZXJpbmcgbW9yZSB0aGFuIDMgY2hhcmFjdGVycywgYWZ0ZXIgdGhlIGxhc3QgcXVlcnkgdGhhdCBtYXRjaGVkIHdpdGggYXQgbGVhc3QgMSBtZW51IGl0ZW0sIHNob3VsZCBoaWRlXG4gICAgICAgICAgLy8gdGhlIG1lbnUuXG4gICAgICAgICAgbS5ub3RGb3VuZENvdW50ID4gMylcbiAgICAgICAgICAgIHJldHVybiBaKCk7XG4gICAgICAgICAgaWYgKCgodyA9IGEuZ2V0TWV0YShlKSkgPT0gbnVsbCA/IHZvaWQgMCA6IHcuc2VsZWN0ZWRJdGVtSW5kZXhDaGFuZ2VkKSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBsZXQgQyA9IGEuZ2V0TWV0YShlKS5zZWxlY3RlZEl0ZW1JbmRleENoYW5nZWQ7XG4gICAgICAgICAgICBDIDwgMCA/IEMgPSBkLml0ZW1zLmxlbmd0aCAtIDEgOiBDID49IGQuaXRlbXMubGVuZ3RoICYmIChDID0gMCksIG0ua2V5Ym9hcmRIb3ZlcmVkSXRlbUluZGV4ID0gQztcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIGMuc2VsZWN0aW9uLmZyb20gIT09IGguc2VsZWN0aW9uLmZyb20gJiYgKG0ua2V5Ym9hcmRIb3ZlcmVkSXRlbUluZGV4ID0gMCk7XG4gICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwcm9wczoge1xuICAgICAgICBoYW5kbGVLZXlEb3duKGEsIGQpIHtcbiAgICAgICAgICBjb25zdCBjID0gdGhpcy5nZXRTdGF0ZShhLnN0YXRlKS5hY3RpdmU7XG4gICAgICAgICAgaWYgKGQua2V5ID09PSBvICYmICFjKVxuICAgICAgICAgICAgcmV0dXJuIGEuZGlzcGF0Y2goXG4gICAgICAgICAgICAgIGEuc3RhdGUudHIuaW5zZXJ0VGV4dChvKS5zY3JvbGxJbnRvVmlldygpLnNldE1ldGEoZSwge1xuICAgICAgICAgICAgICAgIGFjdGl2YXRlOiAhMCxcbiAgICAgICAgICAgICAgICB0cmlnZ2VyQ2hhcmFjdGVyOiBvXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApLCAhMDtcbiAgICAgICAgICBpZiAoIWMpXG4gICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgdHJpZ2dlckNoYXJhY3RlcjogaCxcbiAgICAgICAgICAgIHF1ZXJ5U3RhcnRQb3M6IG0sXG4gICAgICAgICAgICBpdGVtczogcCxcbiAgICAgICAgICAgIGtleWJvYXJkSG92ZXJlZEl0ZW1JbmRleDogZlxuICAgICAgICAgIH0gPSBlLmdldFN0YXRlKGEuc3RhdGUpO1xuICAgICAgICAgIHJldHVybiBkLmtleSA9PT0gXCJBcnJvd1VwXCIgPyAoYS5kaXNwYXRjaChcbiAgICAgICAgICAgIGEuc3RhdGUudHIuc2V0TWV0YShlLCB7XG4gICAgICAgICAgICAgIHNlbGVjdGVkSXRlbUluZGV4Q2hhbmdlZDogZiAtIDFcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKSwgITApIDogZC5rZXkgPT09IFwiQXJyb3dEb3duXCIgPyAoYS5kaXNwYXRjaChcbiAgICAgICAgICAgIGEuc3RhdGUudHIuc2V0TWV0YShlLCB7XG4gICAgICAgICAgICAgIHNlbGVjdGVkSXRlbUluZGV4Q2hhbmdlZDogZiArIDFcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKSwgITApIDogZC5rZXkgPT09IFwiRW50ZXJcIiA/IChwLmxlbmd0aCA9PT0gMCB8fCAobChhKSwgbi5fdGlwdGFwRWRpdG9yLmNoYWluKCkuZm9jdXMoKS5kZWxldGVSYW5nZSh7XG4gICAgICAgICAgICBmcm9tOiBtIC0gaC5sZW5ndGgsXG4gICAgICAgICAgICB0bzogbi5fdGlwdGFwRWRpdG9yLnN0YXRlLnNlbGVjdGlvbi5mcm9tXG4gICAgICAgICAgfSkucnVuKCksIGkoe1xuICAgICAgICAgICAgaXRlbTogcFtmXSxcbiAgICAgICAgICAgIGVkaXRvcjogblxuICAgICAgICAgIH0pKSwgITApIDogZC5rZXkgPT09IFwiRXNjYXBlXCIgPyAobChhKSwgITApIDogITE7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFNldHVwIGRlY29yYXRvciBvbiB0aGUgY3VycmVudGx5IGFjdGl2ZSBzdWdnZXN0aW9uLlxuICAgICAgICBkZWNvcmF0aW9ucyhhKSB7XG4gICAgICAgICAgY29uc3QgeyBhY3RpdmU6IGQsIGRlY29yYXRpb25JZDogYywgcXVlcnlTdGFydFBvczogaCwgdHJpZ2dlckNoYXJhY3RlcjogbSB9ID0gdGhpcy5nZXRTdGF0ZShhKTtcbiAgICAgICAgICBpZiAoIWQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICBpZiAobSA9PT0gXCJcIikge1xuICAgICAgICAgICAgY29uc3QgcCA9IEtlKGEuc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIGlmIChwKVxuICAgICAgICAgICAgICByZXR1cm4gai5jcmVhdGUoYS5kb2MsIFtcbiAgICAgICAgICAgICAgICBHLm5vZGUoXG4gICAgICAgICAgICAgICAgICBwLnBvcyxcbiAgICAgICAgICAgICAgICAgIHAucG9zICsgcC5ub2RlLm5vZGVTaXplLFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBub2RlTmFtZTogXCJzcGFuXCIsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzOiBcInN1Z2dlc3Rpb24tZGVjb3JhdG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZGF0YS1kZWNvcmF0aW9uLWlkXCI6IGNcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gai5jcmVhdGUoYS5kb2MsIFtcbiAgICAgICAgICAgIEcuaW5saW5lKFxuICAgICAgICAgICAgICBoIC0gbS5sZW5ndGgsXG4gICAgICAgICAgICAgIGgsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBub2RlTmFtZTogXCJzcGFuXCIsXG4gICAgICAgICAgICAgICAgY2xhc3M6IFwic3VnZ2VzdGlvbi1kZWNvcmF0b3JcIixcbiAgICAgICAgICAgICAgICBcImRhdGEtZGVjb3JhdGlvbi1pZFwiOiBjXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClcbiAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pLFxuICAgIGl0ZW1DYWxsYmFjazogKGEpID0+IHtcbiAgICAgIGwobi5fdGlwdGFwRWRpdG9yLnZpZXcpLCBuLl90aXB0YXBFZGl0b3IuY2hhaW4oKS5mb2N1cygpLmRlbGV0ZVJhbmdlKHtcbiAgICAgICAgZnJvbTogcy5wbHVnaW5TdGF0ZS5xdWVyeVN0YXJ0UG9zIC0gcy5wbHVnaW5TdGF0ZS50cmlnZ2VyQ2hhcmFjdGVyLmxlbmd0aCxcbiAgICAgICAgdG86IG4uX3RpcHRhcEVkaXRvci5zdGF0ZS5zZWxlY3Rpb24uZnJvbVxuICAgICAgfSkucnVuKCksIGkoe1xuICAgICAgICBpdGVtOiBhLFxuICAgICAgICBlZGl0b3I6IG5cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn0sIGV0ID0gbmV3IF8oXCJTbGFzaE1lbnVQbHVnaW5cIik7XG5jbGFzcyBaZSBleHRlbmRzICQge1xuICBjb25zdHJ1Y3RvcihlLCBvKSB7XG4gICAgc3VwZXIoKTtcbiAgICB1KHRoaXMsIFwicGx1Z2luXCIpO1xuICAgIHUodGhpcywgXCJpdGVtQ2FsbGJhY2tcIik7XG4gICAgY29uc3QgciA9IEplKFxuICAgICAgZSxcbiAgICAgIChpKSA9PiB7XG4gICAgICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiLCBpKTtcbiAgICAgIH0sXG4gICAgICBldCxcbiAgICAgIFwiL1wiLFxuICAgICAgKGkpID0+IG8uZmlsdGVyKFxuICAgICAgICAoeyBuYW1lOiBzLCBhbGlhc2VzOiBsIH0pID0+IHMudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKGkudG9Mb3dlckNhc2UoKSkgfHwgbCAmJiBsLmZpbHRlcihcbiAgICAgICAgICAoYSkgPT4gYS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoaS50b0xvd2VyQ2FzZSgpKVxuICAgICAgICApLmxlbmd0aCAhPT0gMFxuICAgICAgKSxcbiAgICAgICh7IGl0ZW06IGksIGVkaXRvcjogcyB9KSA9PiBpLmV4ZWN1dGUocylcbiAgICApO1xuICAgIHRoaXMucGx1Z2luID0gci5wbHVnaW4sIHRoaXMuaXRlbUNhbGxiYWNrID0gci5pdGVtQ2FsbGJhY2s7XG4gIH1cbiAgb25VcGRhdGUoZSkge1xuICAgIHJldHVybiB0aGlzLm9uKFwidXBkYXRlXCIsIGUpO1xuICB9XG59XG5jb25zdCBRZSA9IG5ldyBfKFwiYmxvY2tub3RlLXBsYWNlaG9sZGVyXCIpLCB0byA9IEwuY3JlYXRlKHtcbiAgbmFtZTogXCJwbGFjZWhvbGRlclwiLFxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBlbXB0eUVkaXRvckNsYXNzOiBcImlzLWVkaXRvci1lbXB0eVwiLFxuICAgICAgZW1wdHlOb2RlQ2xhc3M6IFwiaXMtZW1wdHlcIixcbiAgICAgIGlzRmlsdGVyQ2xhc3M6IFwiaXMtZmlsdGVyXCIsXG4gICAgICBoYXNBbmNob3JDbGFzczogXCJoYXMtYW5jaG9yXCIsXG4gICAgICBwbGFjZWhvbGRlcjogXCJXcml0ZSBzb21ldGhpbmcg4oCmXCIsXG4gICAgICBzaG93T25seVdoZW5FZGl0YWJsZTogITAsXG4gICAgICBzaG93T25seUN1cnJlbnQ6ICEwLFxuICAgICAgaW5jbHVkZUNoaWxkcmVuOiAhMVxuICAgIH07XG4gIH0sXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbmV3IEkoe1xuICAgICAgICBrZXk6IFFlLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGRlY29yYXRpb25zOiAobikgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBkb2M6IHQsIHNlbGVjdGlvbjogZSB9ID0gbiwgbyA9IGV0LmdldFN0YXRlKG4pLCByID0gdGhpcy5lZGl0b3IuaXNFZGl0YWJsZSB8fCAhdGhpcy5vcHRpb25zLnNob3dPbmx5V2hlbkVkaXRhYmxlLCB7IGFuY2hvcjogaSB9ID0gZSwgcyA9IFtdO1xuICAgICAgICAgICAgaWYgKHIpXG4gICAgICAgICAgICAgIHJldHVybiB0LmRlc2NlbmRhbnRzKChsLCBhKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZCA9IGkgPj0gYSAmJiBpIDw9IGEgKyBsLm5vZGVTaXplLCBjID0gIWwuaXNMZWFmICYmICFsLmNoaWxkQ291bnQ7XG4gICAgICAgICAgICAgICAgaWYgKChkIHx8ICF0aGlzLm9wdGlvbnMuc2hvd09ubHlDdXJyZW50KSAmJiBjKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBoID0gW3RoaXMub3B0aW9ucy5lbXB0eU5vZGVDbGFzc107XG4gICAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5pc0VtcHR5ICYmIGgucHVzaCh0aGlzLm9wdGlvbnMuZW1wdHlFZGl0b3JDbGFzcyksIGQgJiYgaC5wdXNoKHRoaXMub3B0aW9ucy5oYXNBbmNob3JDbGFzcyksIChvID09IG51bGwgPyB2b2lkIDAgOiBvLnRyaWdnZXJDaGFyYWN0ZXIpID09PSBcIlwiICYmIChvICE9IG51bGwgJiYgby5hY3RpdmUpICYmIGgucHVzaCh0aGlzLm9wdGlvbnMuaXNGaWx0ZXJDbGFzcyk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBtID0gRy5ub2RlKGEsIGEgKyBsLm5vZGVTaXplLCB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzOiBoLmpvaW4oXCIgXCIpXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIHMucHVzaChtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5pbmNsdWRlQ2hpbGRyZW47XG4gICAgICAgICAgICAgIH0pLCBqLmNyZWF0ZSh0LCBzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgXTtcbiAgfVxufSksIGVvID0gTC5jcmVhdGUoe1xuICBuYW1lOiBcInRleHRBbGlnbm1lbnRcIixcbiAgYWRkR2xvYmFsQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICAvLyBBdHRyaWJ1dGUgaXMgYXBwbGllZCB0byBibG9jayBjb250ZW50IGluc3RlYWQgb2YgY29udGFpbmVyIHNvIHRoYXQgY2hpbGQgYmxvY2tzIGRvbid0IGluaGVyaXQgdGhlIHRleHRcbiAgICAgICAgLy8gYWxpZ25tZW50IHN0eWxpbmcuXG4gICAgICAgIHR5cGVzOiBbXCJwYXJhZ3JhcGhcIiwgXCJoZWFkaW5nXCIsIFwiYnVsbGV0TGlzdEl0ZW1cIiwgXCJudW1iZXJlZExpc3RJdGVtXCJdLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgdGV4dEFsaWdubWVudDoge1xuICAgICAgICAgICAgZGVmYXVsdDogXCJsZWZ0XCIsXG4gICAgICAgICAgICBwYXJzZUhUTUw6IChuKSA9PiBuLmdldEF0dHJpYnV0ZShcImRhdGEtdGV4dC1hbGlnbm1lbnRcIiksXG4gICAgICAgICAgICByZW5kZXJIVE1MOiAobikgPT4gbi50ZXh0QWxpZ25tZW50ICE9PSBcImxlZnRcIiAmJiB7XG4gICAgICAgICAgICAgIFwiZGF0YS10ZXh0LWFsaWdubWVudFwiOiBuLnRleHRBbGlnbm1lbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdO1xuICB9LFxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0VGV4dEFsaWdubWVudDogKG4pID0+ICh7IHN0YXRlOiB0IH0pID0+IHtcbiAgICAgICAgY29uc3QgZSA9IFtdLCBvID0gdihcbiAgICAgICAgICB0LmRvYyxcbiAgICAgICAgICB0LnNlbGVjdGlvbi5mcm9tXG4gICAgICAgICk7XG4gICAgICAgIGlmIChvID09PSB2b2lkIDApXG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICBsZXQgciA9IG8uc3RhcnRQb3M7XG4gICAgICAgIGZvciAoOyByIDwgdC5zZWxlY3Rpb24udG87IClcbiAgICAgICAgICB0LmRvYy5yZXNvbHZlKHIpLm5vZGUoKS50eXBlLnNwZWMuZ3JvdXAgPT09IFwiYmxvY2tDb250ZW50XCIgPyAoZS5wdXNoKHIgLSAxKSwgciArPSB0LmRvYy5yZXNvbHZlKHIpLm5vZGUoKS5ub2RlU2l6ZSAtIDEpIDogciArPSAxO1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgZSlcbiAgICAgICAgICB0LnRyLnNldE5vZGVBdHRyaWJ1dGUoaSwgXCJ0ZXh0QWxpZ25tZW50XCIsIG4pO1xuICAgICAgICByZXR1cm4gITA7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSksIG9vID0gTC5jcmVhdGUoe1xuICBuYW1lOiBcImJsb2NrVGV4dENvbG9yXCIsXG4gIGFkZEdsb2JhbEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdHlwZXM6IFtcImJsb2NrQ29udGFpbmVyXCJdLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgdGV4dENvbG9yOiB7XG4gICAgICAgICAgICBkZWZhdWx0OiBULnRleHRDb2xvci5kZWZhdWx0LFxuICAgICAgICAgICAgcGFyc2VIVE1MOiAobikgPT4gbi5oYXNBdHRyaWJ1dGUoXCJkYXRhLXRleHQtY29sb3JcIikgPyBuLmdldEF0dHJpYnV0ZShcImRhdGEtdGV4dC1jb2xvclwiKSA6IFQudGV4dENvbG9yLmRlZmF1bHQsXG4gICAgICAgICAgICByZW5kZXJIVE1MOiAobikgPT4gbi50ZXh0Q29sb3IgIT09IFQudGV4dENvbG9yLmRlZmF1bHQgJiYge1xuICAgICAgICAgICAgICBcImRhdGEtdGV4dC1jb2xvclwiOiBuLnRleHRDb2xvclxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIF07XG4gIH0sXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRCbG9ja1RleHRDb2xvcjogKG4sIHQpID0+ICh7IHN0YXRlOiBlLCB2aWV3OiBvIH0pID0+IHtcbiAgICAgICAgY29uc3QgciA9IHYoZS5kb2MsIG4pO1xuICAgICAgICByZXR1cm4gciA9PT0gdm9pZCAwID8gITEgOiAoZS50ci5zZXROb2RlQXR0cmlidXRlKHIuc3RhcnRQb3MgLSAxLCBcInRleHRDb2xvclwiLCB0KSwgby5mb2N1cygpLCAhMCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSksIG5vID0gbXQuY3JlYXRlKHtcbiAgbmFtZTogXCJ0ZXh0Q29sb3JcIixcbiAgYWRkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29sb3I6IHtcbiAgICAgICAgZGVmYXVsdDogdm9pZCAwLFxuICAgICAgICBwYXJzZUhUTUw6IChuKSA9PiBuLmdldEF0dHJpYnV0ZShcImRhdGEtdGV4dC1jb2xvclwiKSxcbiAgICAgICAgcmVuZGVySFRNTDogKG4pID0+ICh7XG4gICAgICAgICAgXCJkYXRhLXRleHQtY29sb3JcIjogbi5jb2xvclxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6IFwic3BhblwiLFxuICAgICAgICBnZXRBdHRyczogKG4pID0+IHR5cGVvZiBuID09IFwic3RyaW5nXCIgPyAhMSA6IG4uaGFzQXR0cmlidXRlKFwiZGF0YS10ZXh0LWNvbG9yXCIpID8geyBjb2xvcjogbi5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRleHQtY29sb3JcIikgfSA6ICExXG4gICAgICB9XG4gICAgXTtcbiAgfSxcbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzOiBuIH0pIHtcbiAgICByZXR1cm4gW1wic3BhblwiLCBuLCAwXTtcbiAgfSxcbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldFRleHRDb2xvcjogKG4pID0+ICh7IGNvbW1hbmRzOiB0IH0pID0+IG4gIT09IFQudGV4dENvbG9yLmRlZmF1bHQgPyB0LnNldE1hcmsodGhpcy5uYW1lLCB7IGNvbG9yOiBuIH0pIDogdC51bnNldE1hcmsodGhpcy5uYW1lKVxuICAgIH07XG4gIH1cbn0pLCBybyA9IEwuY3JlYXRlKHtcbiAgbmFtZTogXCJ0cmFpbGluZ05vZGVcIixcbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIGNvbnN0IG4gPSBuZXcgXyh0aGlzLm5hbWUpO1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgSSh7XG4gICAgICAgIGtleTogbixcbiAgICAgICAgYXBwZW5kVHJhbnNhY3Rpb246ICh0LCBlLCBvKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBkb2M6IHIsIHRyOiBpLCBzY2hlbWE6IHMgfSA9IG8sIGwgPSBuLmdldFN0YXRlKG8pLCBhID0gci5jb250ZW50LnNpemUgLSAyLCBkID0gcy5ub2Rlcy5ibG9ja0NvbnRhaW5lciwgYyA9IHMubm9kZXMucGFyYWdyYXBoO1xuICAgICAgICAgIGlmIChsKVxuICAgICAgICAgICAgcmV0dXJuIGkuaW5zZXJ0KFxuICAgICAgICAgICAgICBhLFxuICAgICAgICAgICAgICBkLmNyZWF0ZSh2b2lkIDAsIGMuY3JlYXRlKCkpXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBzdGF0ZToge1xuICAgICAgICAgIGluaXQ6ICh0LCBlKSA9PiB7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhcHBseTogKHQsIGUpID0+IHtcbiAgICAgICAgICAgIGlmICghdC5kb2NDaGFuZ2VkKVxuICAgICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgICAgIGxldCBvID0gdC5kb2MubGFzdENoaWxkO1xuICAgICAgICAgICAgaWYgKCFvIHx8IG8udHlwZS5uYW1lICE9PSBcImJsb2NrR3JvdXBcIilcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgYmxvY2tHcm91cFwiKTtcbiAgICAgICAgICAgIGlmIChvID0gby5sYXN0Q2hpbGQsICFvIHx8IG8udHlwZS5uYW1lICE9PSBcImJsb2NrQ29udGFpbmVyXCIpXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGJsb2NrQ29udGFpbmVyXCIpO1xuICAgICAgICAgICAgY29uc3QgciA9IG8uZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGlmICghcilcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgYmxvY2tDb250ZW50XCIpO1xuICAgICAgICAgICAgcmV0dXJuIG8ubm9kZVNpemUgPiA0IHx8IHIudHlwZS5zcGVjLmNvbnRlbnQgIT09IFwiaW5saW5lKlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICBdO1xuICB9XG59KSwgaW8gPSAobikgPT4ge1xuICB2YXIgZTtcbiAgY29uc3QgdCA9IFtcbiAgICBWLkNsaXBib2FyZFRleHRTZXJpYWxpemVyLFxuICAgIFYuQ29tbWFuZHMsXG4gICAgVi5FZGl0YWJsZSxcbiAgICBWLkZvY3VzRXZlbnRzLFxuICAgIFYuVGFiaW5kZXgsXG4gICAgLy8gRGV2VG9vbHMsXG4gICAgdWUsXG4gICAgLy8gRHJvcEN1cnNvcixcbiAgICB0by5jb25maWd1cmUoe1xuICAgICAgZW1wdHlOb2RlQ2xhc3M6IGsuaXNFbXB0eSxcbiAgICAgIGhhc0FuY2hvckNsYXNzOiBrLmhhc0FuY2hvcixcbiAgICAgIGlzRmlsdGVyQ2xhc3M6IGsuaXNGaWx0ZXIsXG4gICAgICBpbmNsdWRlQ2hpbGRyZW46ICEwLFxuICAgICAgc2hvd09ubHlDdXJyZW50OiAhMVxuICAgIH0pLFxuICAgIFguY29uZmlndXJlKHtcbiAgICAgIHR5cGVzOiBbXCJibG9ja0NvbnRhaW5lclwiXVxuICAgIH0pLFxuICAgIHBlLFxuICAgIC8vIENvbW1lbnRzLFxuICAgIC8vIGJhc2ljczpcbiAgICBrZSxcbiAgICAvLyBtYXJrczpcbiAgICBzZSxcbiAgICBhZSxcbiAgICBtZSxcbiAgICBnZSxcbiAgICBiZSxcbiAgICBmZSxcbiAgICBubyxcbiAgICBvbyxcbiAgICBIZSxcbiAgICBBZSxcbiAgICBlbyxcbiAgICAvLyBub2Rlc1xuICAgIGplLFxuICAgIFdlLmNvbmZpZ3VyZSh7XG4gICAgICBkb21BdHRyaWJ1dGVzOiBuLmRvbUF0dHJpYnV0ZXNcbiAgICB9KSxcbiAgICBHZS5jb25maWd1cmUoe1xuICAgICAgZG9tQXR0cmlidXRlczogbi5kb21BdHRyaWJ1dGVzXG4gICAgfSksXG4gICAgLi4uT2JqZWN0LnZhbHVlcyhuLmJsb2NrU2NoZW1hKS5tYXAoXG4gICAgICAobykgPT4gby5ub2RlLmNvbmZpZ3VyZSh7XG4gICAgICAgIGVkaXRvcjogbi5lZGl0b3IsXG4gICAgICAgIGRvbUF0dHJpYnV0ZXM6IG4uZG9tQXR0cmlidXRlc1xuICAgICAgfSlcbiAgICApLFxuICAgIFhlLFxuICAgIGNlLmNvbmZpZ3VyZSh7IHdpZHRoOiA1LCBjb2xvcjogXCIjZGRlZWZmXCIgfSksXG4gICAgLy8gVGhpcyBuZWVkcyB0byBiZSBhdCB0aGUgYm90dG9tIG9mIHRoaXMgbGlzdCwgYmVjYXVzZSBLZXkgZXZlbnRzIChzdWNoIGFzIGVudGVyLCB3aGVuIHNlbGVjdGluZyBhIC9jb21tYW5kKSxcbiAgICAvLyBzaG91bGQgYmUgaGFuZGxlZCBiZWZvcmUgRW50ZXIgaGFuZGxlcnMgaW4gb3RoZXIgY29tcG9uZW50cyBsaWtlIHNwbGl0TGlzdEl0ZW1cbiAgICByb1xuICBdO1xuICBpZiAobi5jb2xsYWJvcmF0aW9uKSB7XG4gICAgaWYgKHQucHVzaChcbiAgICAgIGxlLmNvbmZpZ3VyZSh7XG4gICAgICAgIGZyYWdtZW50OiBuLmNvbGxhYm9yYXRpb24uZnJhZ21lbnRcbiAgICAgIH0pXG4gICAgKSwgKGUgPSBuLmNvbGxhYm9yYXRpb24ucHJvdmlkZXIpICE9IG51bGwgJiYgZS5hd2FyZW5lc3MpIHtcbiAgICAgIGNvbnN0IG8gPSAocikgPT4ge1xuICAgICAgICBjb25zdCBpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIGkuY2xhc3NMaXN0LmFkZChSW1wiY29sbGFib3JhdGlvbi1jdXJzb3JfX2NhcmV0XCJdKSwgaS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBgYm9yZGVyLWNvbG9yOiAke3IuY29sb3J9YCk7XG4gICAgICAgIGNvbnN0IHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgcy5jbGFzc0xpc3QuYWRkKFJbXCJjb2xsYWJvcmF0aW9uLWN1cnNvcl9fbGFiZWxcIl0pLCBzLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIGBiYWNrZ3JvdW5kLWNvbG9yOiAke3IuY29sb3J9YCksIHMuaW5zZXJ0QmVmb3JlKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHIubmFtZSksIG51bGwpO1xuICAgICAgICBjb25zdCBsID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCLigaBcIiksIGEgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIuKBoFwiKTtcbiAgICAgICAgcmV0dXJuIGkuaW5zZXJ0QmVmb3JlKGwsIG51bGwpLCBpLmluc2VydEJlZm9yZShzLCBudWxsKSwgaS5pbnNlcnRCZWZvcmUoYSwgbnVsbCksIGk7XG4gICAgICB9O1xuICAgICAgdC5wdXNoKFxuICAgICAgICBkZS5jb25maWd1cmUoe1xuICAgICAgICAgIHVzZXI6IG4uY29sbGFib3JhdGlvbi51c2VyLFxuICAgICAgICAgIHJlbmRlcjogbi5jb2xsYWJvcmF0aW9uLnJlbmRlckN1cnNvciB8fCBvLFxuICAgICAgICAgIHByb3ZpZGVyOiBuLmNvbGxhYm9yYXRpb24ucHJvdmlkZXJcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2VcbiAgICB0LnB1c2goaGUpO1xuICByZXR1cm4gdDtcbn07XG5mdW5jdGlvbiBvdChuLCB0KSB7XG4gIGxldCBlLCBvO1xuICBpZiAodC5maXJzdENoaWxkLmRlc2NlbmRhbnRzKChyLCBpKSA9PiBlID8gITEgOiByLnR5cGUubmFtZSAhPT0gXCJibG9ja0NvbnRhaW5lclwiIHx8IHIuYXR0cnMuaWQgIT09IG4gPyAhMCA6IChlID0gciwgbyA9IGkgKyAxLCAhMSkpLCBlID09PSB2b2lkIDAgfHwgbyA9PT0gdm9pZCAwKVxuICAgIHRocm93IEVycm9yKFwiQ291bGQgbm90IGZpbmQgYmxvY2sgaW4gdGhlIGVkaXRvciB3aXRoIG1hdGNoaW5nIElELlwiKTtcbiAgcmV0dXJuIHtcbiAgICBub2RlOiBlLFxuICAgIHBvc0JlZm9yZU5vZGU6IG9cbiAgfTtcbn1cbmZ1bmN0aW9uIEZ0KG4sIHQsIGUgPSBcImJlZm9yZVwiLCBvKSB7XG4gIGNvbnN0IHIgPSB0eXBlb2YgdCA9PSBcInN0cmluZ1wiID8gdCA6IHQuaWQsIGkgPSBbXTtcbiAgZm9yIChjb25zdCBkIG9mIG4pXG4gICAgaS5wdXNoKEYoZCwgby5zY2hlbWEpKTtcbiAgbGV0IHMgPSAtMTtcbiAgY29uc3QgeyBub2RlOiBsLCBwb3NCZWZvcmVOb2RlOiBhIH0gPSBvdChyLCBvLnN0YXRlLmRvYyk7XG4gIGlmIChlID09PSBcImJlZm9yZVwiICYmIChzID0gYSksIGUgPT09IFwiYWZ0ZXJcIiAmJiAocyA9IGEgKyBsLm5vZGVTaXplKSwgZSA9PT0gXCJuZXN0ZWRcIikge1xuICAgIGlmIChsLmNoaWxkQ291bnQgPCAyKSB7XG4gICAgICBzID0gYSArIGwuZmlyc3RDaGlsZC5ub2RlU2l6ZSArIDE7XG4gICAgICBjb25zdCBkID0gby5zdGF0ZS5zY2hlbWEubm9kZXMuYmxvY2tHcm91cC5jcmVhdGUoXG4gICAgICAgIHt9LFxuICAgICAgICBpXG4gICAgICApO1xuICAgICAgby52aWV3LmRpc3BhdGNoKFxuICAgICAgICBvLnN0YXRlLnRyLmluc2VydChzLCBkKVxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcyA9IGEgKyBsLmZpcnN0Q2hpbGQubm9kZVNpemUgKyAyO1xuICB9XG4gIG8udmlldy5kaXNwYXRjaChvLnN0YXRlLnRyLmluc2VydChzLCBpKSk7XG59XG5mdW5jdGlvbiBzbyhuLCB0LCBlKSB7XG4gIGNvbnN0IG8gPSB0eXBlb2YgbiA9PSBcInN0cmluZ1wiID8gbiA6IG4uaWQsIHsgcG9zQmVmb3JlTm9kZTogciB9ID0gb3QobywgZS5zdGF0ZS5kb2MpO1xuICBlLmNvbW1hbmRzLkJOVXBkYXRlQmxvY2sociArIDEsIHQpO1xufVxuZnVuY3Rpb24gJHQobiwgdCkge1xuICBjb25zdCBlID0gbmV3IFNldChcbiAgICBuLm1hcChcbiAgICAgIChyKSA9PiB0eXBlb2YgciA9PSBcInN0cmluZ1wiID8gciA6IHIuaWRcbiAgICApXG4gICk7XG4gIGxldCBvID0gMDtcbiAgaWYgKHQuc3RhdGUuZG9jLmRlc2NlbmRhbnRzKChyLCBpKSA9PiB7XG4gICAgaWYgKGUuc2l6ZSA9PT0gMClcbiAgICAgIHJldHVybiAhMTtcbiAgICBpZiAoci50eXBlLm5hbWUgIT09IFwiYmxvY2tDb250YWluZXJcIiB8fCAhZS5oYXMoci5hdHRycy5pZCkpXG4gICAgICByZXR1cm4gITA7XG4gICAgZS5kZWxldGUoci5hdHRycy5pZCk7XG4gICAgY29uc3QgcyA9IHQuc3RhdGUuZG9jLm5vZGVTaXplO1xuICAgIHQuY29tbWFuZHMuQk5EZWxldGVCbG9jayhpIC0gbyArIDEpO1xuICAgIGNvbnN0IGwgPSB0LnN0YXRlLmRvYy5ub2RlU2l6ZTtcbiAgICByZXR1cm4gbyArPSBzIC0gbCwgITE7XG4gIH0pLCBlLnNpemUgPiAwKSB7XG4gICAgY29uc3QgciA9IFsuLi5lXS5qb2luKGBcbmApO1xuICAgIHRocm93IEVycm9yKFxuICAgICAgXCJCbG9ja3Mgd2l0aCB0aGUgZm9sbG93aW5nIElEcyBjb3VsZCBub3QgYmUgZm91bmQgaW4gdGhlIGVkaXRvcjogXCIgKyByXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gYW8obiwgdCwgZSkge1xuICBGdCh0LCBuWzBdLCBcImJlZm9yZVwiLCBlKSwgJHQobiwgZSk7XG59XG5mdW5jdGlvbiBsbygpIHtcbiAgY29uc3QgbiA9ICh0KSA9PiB7XG4gICAgbGV0IGUgPSB0LmNoaWxkcmVuLmxlbmd0aDtcbiAgICBmb3IgKGxldCBvID0gMDsgbyA8IGU7IG8rKykge1xuICAgICAgY29uc3QgciA9IHQuY2hpbGRyZW5bb107XG4gICAgICBpZiAoci50eXBlID09PSBcImVsZW1lbnRcIiAmJiAobihyKSwgci50YWdOYW1lID09PSBcInVcIikpXG4gICAgICAgIGlmIChyLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0LmNoaWxkcmVuLnNwbGljZShvLCAxLCAuLi5yLmNoaWxkcmVuKTtcbiAgICAgICAgICBjb25zdCBpID0gci5jaGlsZHJlbi5sZW5ndGggLSAxO1xuICAgICAgICAgIGUgKz0gaSwgbyArPSBpO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICB0LmNoaWxkcmVuLnNwbGljZShvLCAxKSwgZS0tLCBvLS07XG4gICAgfVxuICB9O1xuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIGNvKG4pIHtcbiAgY29uc3QgdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgICAuLi5uLm9yZGVyZWRMaXN0SXRlbUJsb2NrVHlwZXMsXG4gICAgLi4ubi51bm9yZGVyZWRMaXN0SXRlbUJsb2NrVHlwZXNcbiAgXSksIGUgPSAobykgPT4ge1xuICAgIGxldCByID0gby5jaGlsZHJlbi5sZW5ndGgsIGk7XG4gICAgZm9yIChsZXQgcyA9IDA7IHMgPCByOyBzKyspIHtcbiAgICAgIGNvbnN0IGEgPSBvLmNoaWxkcmVuW3NdLmNoaWxkcmVuWzBdLCBkID0gYS5jaGlsZHJlblswXSwgYyA9IGEuY2hpbGRyZW4ubGVuZ3RoID09PSAyID8gYS5jaGlsZHJlblsxXSA6IG51bGwsIGggPSB0LmhhcyhcbiAgICAgICAgZC5wcm9wZXJ0aWVzLmRhdGFDb250ZW50VHlwZVxuICAgICAgKSwgbSA9IGggPyBuLm9yZGVyZWRMaXN0SXRlbUJsb2NrVHlwZXMuaGFzKFxuICAgICAgICBkLnByb3BlcnRpZXMuZGF0YUNvbnRlbnRUeXBlXG4gICAgICApID8gXCJvbFwiIDogXCJ1bFwiIDogbnVsbDtcbiAgICAgIGlmIChjICE9PSBudWxsICYmIGUoYyksIGkgJiYgaS50YWdOYW1lICE9PSBtKSB7XG4gICAgICAgIG8uY2hpbGRyZW4uc3BsaWNlKFxuICAgICAgICAgIHMgLSBpLmNoaWxkcmVuLmxlbmd0aCxcbiAgICAgICAgICBpLmNoaWxkcmVuLmxlbmd0aCxcbiAgICAgICAgICBpXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHAgPSBpLmNoaWxkcmVuLmxlbmd0aCAtIDE7XG4gICAgICAgIHMgLT0gcCwgciAtPSBwLCBpID0gdm9pZCAwO1xuICAgICAgfVxuICAgICAgaWYgKGgpIHtcbiAgICAgICAgaSB8fCAoaSA9IGF0KFxuICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobSlcbiAgICAgICAgKSk7XG4gICAgICAgIGNvbnN0IHAgPSBhdChcbiAgICAgICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlcIilcbiAgICAgICAgKTtcbiAgICAgICAgcC5jaGlsZHJlbi5wdXNoKGQuY2hpbGRyZW5bMF0pLCBjICE9PSBudWxsICYmIHAuY2hpbGRyZW4ucHVzaCguLi5jLmNoaWxkcmVuKSwgaS5jaGlsZHJlbi5wdXNoKHApO1xuICAgICAgfSBlbHNlIGlmIChjICE9PSBudWxsKSB7XG4gICAgICAgIG8uY2hpbGRyZW4uc3BsaWNlKHMgKyAxLCAwLCAuLi5jLmNoaWxkcmVuKSwgby5jaGlsZHJlbltzXSA9IGQuY2hpbGRyZW5bMF07XG4gICAgICAgIGNvbnN0IHAgPSBjLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgcyArPSBwLCByICs9IHA7XG4gICAgICB9IGVsc2VcbiAgICAgICAgby5jaGlsZHJlbltzXSA9IGQuY2hpbGRyZW5bMF07XG4gICAgfVxuICAgIGkgJiYgby5jaGlsZHJlbi5zcGxpY2UoXG4gICAgICByIC0gaS5jaGlsZHJlbi5sZW5ndGgsXG4gICAgICBpLmNoaWxkcmVuLmxlbmd0aCxcbiAgICAgIGlcbiAgICApO1xuICB9O1xuICByZXR1cm4gZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIFd0KG4sIHQpIHtcbiAgY29uc3QgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIG8gPSBKLmZyb21TY2hlbWEodCk7XG4gIGZvciAoY29uc3QgaSBvZiBuKSB7XG4gICAgY29uc3QgcyA9IEYoaSwgdCksIGwgPSBvLnNlcmlhbGl6ZU5vZGUocyk7XG4gICAgZS5hcHBlbmRDaGlsZChsKTtcbiAgfVxuICByZXR1cm4gKGF3YWl0IHR0KCkudXNlKGd0LCB7IGZyYWdtZW50OiAhMCB9KS51c2UoY28sIHtcbiAgICBvcmRlcmVkTGlzdEl0ZW1CbG9ja1R5cGVzOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJudW1iZXJlZExpc3RJdGVtXCJdKSxcbiAgICB1bm9yZGVyZWRMaXN0SXRlbUJsb2NrVHlwZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImJ1bGxldExpc3RJdGVtXCJdKVxuICB9KS51c2Uoa3QpLnByb2Nlc3MoZS5pbm5lckhUTUwpKS52YWx1ZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIEd0KG4sIHQsIGUpIHtcbiAgY29uc3QgbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIG8uaW5uZXJIVE1MID0gbi50cmltKCk7XG4gIGNvbnN0IGkgPSB5ZS5mcm9tU2NoZW1hKGUpLnBhcnNlKG8pLCBzID0gW107XG4gIGZvciAobGV0IGwgPSAwOyBsIDwgaS5maXJzdENoaWxkLmNoaWxkQ291bnQ7IGwrKylcbiAgICBzLnB1c2goQShpLmZpcnN0Q2hpbGQuY2hpbGQobCksIHQpKTtcbiAgcmV0dXJuIHM7XG59XG5hc3luYyBmdW5jdGlvbiB1byhuLCB0KSB7XG4gIHJldHVybiAoYXdhaXQgdHQoKS51c2UoZ3QsIHsgZnJhZ21lbnQ6ICEwIH0pLnVzZShsbykudXNlKENlKS51c2UoYnQpLnVzZShUZSkucHJvY2Vzcyhhd2FpdCBXdChuLCB0KSkpLnZhbHVlO1xufVxuZnVuY3Rpb24gcG8obiwgdCkge1xuICBjb25zdCBlID0gdC52YWx1ZSA/IHQudmFsdWUgKyBgXG5gIDogXCJcIiwgbyA9IHt9O1xuICB0LmxhbmcgJiYgKG9bXCJkYXRhLWxhbmd1YWdlXCJdID0gdC5sYW5nKTtcbiAgbGV0IHIgPSB7XG4gICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgdGFnTmFtZTogXCJjb2RlXCIsXG4gICAgcHJvcGVydGllczogbyxcbiAgICBjaGlsZHJlbjogW3sgdHlwZTogXCJ0ZXh0XCIsIHZhbHVlOiBlIH1dXG4gIH07XG4gIHJldHVybiB0Lm1ldGEgJiYgKHIuZGF0YSA9IHsgbWV0YTogdC5tZXRhIH0pLCBuLnBhdGNoKHQsIHIpLCByID0gbi5hcHBseURhdGEodCwgciksIHIgPSB7XG4gICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgdGFnTmFtZTogXCJwcmVcIixcbiAgICBwcm9wZXJ0aWVzOiB7fSxcbiAgICBjaGlsZHJlbjogW3JdXG4gIH0sIG4ucGF0Y2godCwgciksIHI7XG59XG5hc3luYyBmdW5jdGlvbiBobyhuLCB0LCBlKSB7XG4gIGNvbnN0IG8gPSBhd2FpdCB0dCgpLnVzZShFZSkudXNlKGJ0KS51c2UoU2UsIHtcbiAgICBoYW5kbGVyczoge1xuICAgICAgLi4uTWUsXG4gICAgICBjb2RlOiBwb1xuICAgIH1cbiAgfSkudXNlKGt0KS5wcm9jZXNzKG4pO1xuICByZXR1cm4gR3Qoby52YWx1ZSwgdCwgZSk7XG59XG5mdW5jdGlvbiBjdChuKSB7XG4gIHJldHVybiBcImRhdGEtXCIgKyBuLnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csIFwiJDEtJDJcIikudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIG1vKG4pIHtcbiAgY29uc3QgdCA9IHt9O1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMobi5wcm9wU2NoZW1hKS5mb3JFYWNoKChbZSwgb10pID0+IHtcbiAgICB0W2VdID0ge1xuICAgICAgZGVmYXVsdDogby5kZWZhdWx0LFxuICAgICAga2VlcE9uU3BsaXQ6ICEwLFxuICAgICAgLy8gUHJvcHMgYXJlIGRpc3BsYXllZCBpbiBrZWJhYi1jYXNlIGFzIEhUTUwgYXR0cmlidXRlcy4gSWYgYSBwcm9wJ3NcbiAgICAgIC8vIHZhbHVlIGlzIHRoZSBzYW1lIGFzIGl0cyBkZWZhdWx0LCB3ZSBkb24ndCBkaXNwbGF5IGFuIEhUTUxcbiAgICAgIC8vIGF0dHJpYnV0ZSBmb3IgaXQuXG4gICAgICBwYXJzZUhUTUw6IChyKSA9PiB7XG4gICAgICAgIGNvbnN0IGkgPSByLmdldEF0dHJpYnV0ZShjdChlKSk7XG4gICAgICAgIGlmIChpID09PSBudWxsKVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAodHlwZW9mIG8uZGVmYXVsdCA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgICByZXR1cm4gaSA9PT0gXCJ0cnVlXCIgPyAhMCA6IGkgPT09IFwiZmFsc2VcIiA/ICExIDogbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiBvLmRlZmF1bHQgPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIGNvbnN0IHMgPSBwYXJzZUZsb2F0KGkpO1xuICAgICAgICAgIHJldHVybiAhTnVtYmVyLmlzTmFOKHMpICYmIE51bWJlci5pc0Zpbml0ZShzKSA/IHMgOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfSxcbiAgICAgIHJlbmRlckhUTUw6IChyKSA9PiByW2VdICE9PSBvLmRlZmF1bHQgPyB7XG4gICAgICAgIFtjdChlKV06IHJbZV1cbiAgICAgIH0gOiB7fVxuICAgIH07XG4gIH0pLCB0O1xufVxuZnVuY3Rpb24gZm8obikge1xuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIHRhZzogXCJkaXZbZGF0YS1jb250ZW50LXR5cGU9XCIgKyBuLnR5cGUgKyBcIl1cIlxuICAgIH1cbiAgXTtcbn1cbmZ1bmN0aW9uIGdvKG4sIHQpIHtcbiAgY29uc3QgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIGUuc2V0QXR0cmlidXRlKFwiZGF0YS1jb250ZW50LXR5cGVcIiwgbi50eXBlKTtcbiAgZm9yIChjb25zdCBbciwgaV0gb2YgT2JqZWN0LmVudHJpZXModCkpXG4gICAgZS5zZXRBdHRyaWJ1dGUociwgaSk7XG4gIGxldCBvO1xuICByZXR1cm4gbi5jb250YWluc0lubGluZUNvbnRlbnQgPyAobyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIGUuYXBwZW5kQ2hpbGQobykpIDogbyA9IHZvaWQgMCwgbyAhPT0gdm9pZCAwID8ge1xuICAgIGRvbTogZSxcbiAgICBjb250ZW50RE9NOiBvXG4gIH0gOiB7XG4gICAgZG9tOiBlXG4gIH07XG59XG5mdW5jdGlvbiBrbyhuKSB7XG4gIHJldHVybiB7XG4gICAgbm9kZTogVyh7XG4gICAgICBuYW1lOiBuLnR5cGUsXG4gICAgICBjb250ZW50OiBuLmNvbnRhaW5zSW5saW5lQ29udGVudCA/IFwiaW5saW5lKlwiIDogXCJcIixcbiAgICAgIHNlbGVjdGFibGU6ICEwLFxuICAgICAgYWRkQXR0cmlidXRlcygpIHtcbiAgICAgICAgcmV0dXJuIG1vKG4pO1xuICAgICAgfSxcbiAgICAgIHBhcnNlSFRNTCgpIHtcbiAgICAgICAgcmV0dXJuIGZvKG4pO1xuICAgICAgfSxcbiAgICAgIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlczogZSB9KSB7XG4gICAgICAgIHJldHVybiBnbyhuLCBlKTtcbiAgICAgIH0sXG4gICAgICBhZGROb2RlVmlldygpIHtcbiAgICAgICAgcmV0dXJuICh7IEhUTUxBdHRyaWJ1dGVzOiBlLCBnZXRQb3M6IG8gfSkgPT4ge1xuICAgICAgICAgIHZhciBwLCBmO1xuICAgICAgICAgIGNvbnN0IHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCBpID0gKChwID0gdGhpcy5vcHRpb25zLmRvbUF0dHJpYnV0ZXMpID09IG51bGwgPyB2b2lkIDAgOiBwLmJsb2NrQ29udGVudCkgfHwge307XG4gICAgICAgICAgZm9yIChjb25zdCBbYiwgd10gb2YgT2JqZWN0LmVudHJpZXMoXG4gICAgICAgICAgICBpXG4gICAgICAgICAgKSlcbiAgICAgICAgICAgIGIgIT09IFwiY2xhc3NcIiAmJiByLnNldEF0dHJpYnV0ZShiLCB3KTtcbiAgICAgICAgICByLmNsYXNzTmFtZSA9IEIoXG4gICAgICAgICAgICBrLmJsb2NrQ29udGVudCxcbiAgICAgICAgICAgIGkuY2xhc3NcbiAgICAgICAgICApLCByLnNldEF0dHJpYnV0ZShcImRhdGEtY29udGVudC10eXBlXCIsIG4udHlwZSk7XG4gICAgICAgICAgZm9yIChjb25zdCBbYiwgd10gb2YgT2JqZWN0LmVudHJpZXMoZSkpXG4gICAgICAgICAgICByLnNldEF0dHJpYnV0ZShiLCB3KTtcbiAgICAgICAgICBjb25zdCBzID0gdGhpcy5vcHRpb25zLmVkaXRvcjtcbiAgICAgICAgICBpZiAodHlwZW9mIG8gPT0gXCJib29sZWFuXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIFwiQ2Fubm90IGZpbmQgbm9kZSBwb3NpdGlvbiBhcyBnZXRQb3MgaXMgYSBib29sZWFuLCBub3QgYSBmdW5jdGlvbi5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCBsID0gbygpLCBjID0gcy5fdGlwdGFwRWRpdG9yLnN0YXRlLmRvYy5yZXNvbHZlKGwpLm5vZGUoKS5hdHRycy5pZCwgaCA9IHMuZ2V0QmxvY2soYyk7XG4gICAgICAgICAgaWYgKGgudHlwZSAhPT0gbi50eXBlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmxvY2sgdHlwZSBkb2VzIG5vdCBtYXRjaFwiKTtcbiAgICAgICAgICBjb25zdCBtID0gbi5yZW5kZXIoaCwgcyk7XG4gICAgICAgICAgaWYgKG4uY29udGFpbnNJbmxpbmVDb250ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBiID0gbS5jb250ZW50RE9NLCB3ID0gKChmID0gdGhpcy5vcHRpb25zLmRvbUF0dHJpYnV0ZXMpID09IG51bGwgPyB2b2lkIDAgOiBmLmlubGluZUNvbnRlbnQpIHx8IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBbQywgTV0gb2YgT2JqZWN0LmVudHJpZXMoXG4gICAgICAgICAgICAgIHdcbiAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgIEMgIT09IFwiY2xhc3NcIiAmJiBiLnNldEF0dHJpYnV0ZShDLCBNKTtcbiAgICAgICAgICAgIGIuY2xhc3NOYW1lID0gQihcbiAgICAgICAgICAgICAgYi5jbGFzc05hbWUsXG4gICAgICAgICAgICAgIGsuaW5saW5lQ29udGVudCxcbiAgICAgICAgICAgICAgdy5jbGFzc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHIuYXBwZW5kQ2hpbGQobS5kb20pLCBcImNvbnRlbnRET01cIiBpbiBtID8ge1xuICAgICAgICAgICAgZG9tOiByLFxuICAgICAgICAgICAgY29udGVudERPTTogbS5jb250ZW50RE9NLFxuICAgICAgICAgICAgZGVzdHJveTogbS5kZXN0cm95XG4gICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgIGRvbTogcixcbiAgICAgICAgICAgIGRlc3Ryb3k6IG0uZGVzdHJveVxuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSksXG4gICAgcHJvcFNjaGVtYTogbi5wcm9wU2NoZW1hXG4gIH07XG59XG5mdW5jdGlvbiBXKG4pIHtcbiAgcmV0dXJuIHEuY3JlYXRlKHtcbiAgICAuLi5uLFxuICAgIGdyb3VwOiBcImJsb2NrQ29udGVudFwiLFxuICAgIGNvbnRlbnQ6IG4uY29udGVudFxuICB9KTtcbn1cbmNvbnN0IGJvID0ge1xuICAuLi5ULFxuICBsZXZlbDogeyBkZWZhdWx0OiAxLCB2YWx1ZXM6IFsxLCAyLCAzXSB9XG59LCB5byA9IFcoe1xuICBuYW1lOiBcImhlYWRpbmdcIixcbiAgY29udGVudDogXCJpbmxpbmUqXCIsXG4gIGFkZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxldmVsOiB7XG4gICAgICAgIGRlZmF1bHQ6IDEsXG4gICAgICAgIC8vIGluc3RlYWQgb2YgXCJsZXZlbFwiIGF0dHJpYnV0ZXMsIHVzZSBcImRhdGEtbGV2ZWxcIlxuICAgICAgICBwYXJzZUhUTUw6IChuKSA9PiBuLmdldEF0dHJpYnV0ZShcImRhdGEtbGV2ZWxcIiksXG4gICAgICAgIHJlbmRlckhUTUw6IChuKSA9PiAoe1xuICAgICAgICAgIFwiZGF0YS1sZXZlbFwiOiBuLmxldmVsLnRvU3RyaW5nKClcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICAuLi5bMSwgMiwgM10ubWFwKChuKSA9PiBuZXcgUSh7XG4gICAgICAgIGZpbmQ6IG5ldyBSZWdFeHAoYF4oI3ske259fSlcXFxccyRgKSxcbiAgICAgICAgaGFuZGxlcjogKHsgc3RhdGU6IHQsIGNoYWluOiBlLCByYW5nZTogbyB9KSA9PiB7XG4gICAgICAgICAgZSgpLkJOVXBkYXRlQmxvY2sodC5zZWxlY3Rpb24uZnJvbSwge1xuICAgICAgICAgICAgdHlwZTogXCJoZWFkaW5nXCIsXG4gICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICBsZXZlbDogblxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLmRlbGV0ZVJhbmdlKHsgZnJvbTogby5mcm9tLCB0bzogby50byB9KTtcbiAgICAgICAgfVxuICAgICAgfSkpXG4gICAgXTtcbiAgfSxcbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFwiTW9kLUFsdC0xXCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLkJOVXBkYXRlQmxvY2sodGhpcy5lZGl0b3Iuc3RhdGUuc2VsZWN0aW9uLmFuY2hvciwge1xuICAgICAgICB0eXBlOiBcImhlYWRpbmdcIixcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBsZXZlbDogMVxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIFwiTW9kLUFsdC0yXCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLkJOVXBkYXRlQmxvY2sodGhpcy5lZGl0b3Iuc3RhdGUuc2VsZWN0aW9uLmFuY2hvciwge1xuICAgICAgICB0eXBlOiBcImhlYWRpbmdcIixcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBsZXZlbDogMlxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIFwiTW9kLUFsdC0zXCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLkJOVXBkYXRlQmxvY2sodGhpcy5lZGl0b3Iuc3RhdGUuc2VsZWN0aW9uLmFuY2hvciwge1xuICAgICAgICB0eXBlOiBcImhlYWRpbmdcIixcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBsZXZlbDogM1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIH07XG4gIH0sXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6IFwiaDFcIixcbiAgICAgICAgYXR0cnM6IHsgbGV2ZWw6IDEgfSxcbiAgICAgICAgbm9kZTogXCJoZWFkaW5nXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHRhZzogXCJoMlwiLFxuICAgICAgICBhdHRyczogeyBsZXZlbDogMiB9LFxuICAgICAgICBub2RlOiBcImhlYWRpbmdcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdGFnOiBcImgzXCIsXG4gICAgICAgIGF0dHJzOiB7IGxldmVsOiAzIH0sXG4gICAgICAgIG5vZGU6IFwiaGVhZGluZ1wiXG4gICAgICB9XG4gICAgXTtcbiAgfSxcbiAgcmVuZGVySFRNTCh7IG5vZGU6IG4sIEhUTUxBdHRyaWJ1dGVzOiB0IH0pIHtcbiAgICB2YXIgciwgaTtcbiAgICBjb25zdCBlID0gKChyID0gdGhpcy5vcHRpb25zLmRvbUF0dHJpYnV0ZXMpID09IG51bGwgPyB2b2lkIDAgOiByLmJsb2NrQ29udGVudCkgfHwge30sIG8gPSAoKGkgPSB0aGlzLm9wdGlvbnMuZG9tQXR0cmlidXRlcykgPT0gbnVsbCA/IHZvaWQgMCA6IGkuaW5saW5lQ29udGVudCkgfHwge307XG4gICAgcmV0dXJuIFtcbiAgICAgIFwiZGl2XCIsXG4gICAgICBEKHQsIHtcbiAgICAgICAgLi4uZSxcbiAgICAgICAgY2xhc3M6IEIoXG4gICAgICAgICAgay5ibG9ja0NvbnRlbnQsXG4gICAgICAgICAgZS5jbGFzc1xuICAgICAgICApLFxuICAgICAgICBcImRhdGEtY29udGVudC10eXBlXCI6IHRoaXMubmFtZVxuICAgICAgfSksXG4gICAgICBbXG4gICAgICAgIGBoJHtuLmF0dHJzLmxldmVsfWAsXG4gICAgICAgIHtcbiAgICAgICAgICAuLi5vLFxuICAgICAgICAgIGNsYXNzOiBCKFxuICAgICAgICAgICAgay5pbmxpbmVDb250ZW50LFxuICAgICAgICAgICAgby5jbGFzc1xuICAgICAgICAgIClcbiAgICAgICAgfSxcbiAgICAgICAgMFxuICAgICAgXVxuICAgIF07XG4gIH1cbn0pLCB2byA9IHtcbiAgbm9kZTogeW8sXG4gIHByb3BTY2hlbWE6IGJvXG59LCBqdCA9IChuKSA9PiB7XG4gIGNvbnN0IHsgbm9kZTogdCwgY29udGVudFR5cGU6IGUgfSA9IHYoXG4gICAgbi5zdGF0ZS5kb2MsXG4gICAgbi5zdGF0ZS5zZWxlY3Rpb24uZnJvbVxuICApLCBvID0gbi5zdGF0ZS5zZWxlY3Rpb24uYW5jaG9yID09PSBuLnN0YXRlLnNlbGVjdGlvbi5oZWFkO1xuICByZXR1cm4gIWUubmFtZS5lbmRzV2l0aChcIkxpc3RJdGVtXCIpIHx8ICFvID8gITEgOiBuLmNvbW1hbmRzLmZpcnN0KCh7IHN0YXRlOiByLCBjaGFpbjogaSwgY29tbWFuZHM6IHMgfSkgPT4gW1xuICAgICgpID0+IChcbiAgICAgIC8vIENoYW5nZXMgbGlzdCBpdGVtIGJsb2NrIHRvIGEgdGV4dCBibG9jayBpZiB0aGUgY29udGVudCBpcyBlbXB0eS5cbiAgICAgIHMuY29tbWFuZCgoKSA9PiB0LnRleHRDb250ZW50Lmxlbmd0aCA9PT0gMCA/IHMuQk5VcGRhdGVCbG9jayhyLnNlbGVjdGlvbi5mcm9tLCB7XG4gICAgICAgIHR5cGU6IFwicGFyYWdyYXBoXCIsXG4gICAgICAgIHByb3BzOiB7fVxuICAgICAgfSkgOiAhMSlcbiAgICApLFxuICAgICgpID0+IChcbiAgICAgIC8vIFNwbGl0cyB0aGUgY3VycmVudCBibG9jaywgbW92aW5nIGNvbnRlbnQgaW5zaWRlIHRoYXQncyBhZnRlciB0aGUgY3Vyc29yIHRvIGEgbmV3IGJsb2NrIG9mIHRoZSBzYW1lIHR5cGVcbiAgICAgIC8vIGJlbG93LlxuICAgICAgcy5jb21tYW5kKCgpID0+IHQudGV4dENvbnRlbnQubGVuZ3RoID4gMCA/IChpKCkuZGVsZXRlU2VsZWN0aW9uKCkuQk5TcGxpdEJsb2NrKHIuc2VsZWN0aW9uLmZyb20sICEwKS5ydW4oKSwgITApIDogITEpXG4gICAgKVxuICBdKTtcbn0sIHdvID0ge1xuICAuLi5UXG59LCBDbyA9IFcoe1xuICBuYW1lOiBcImJ1bGxldExpc3RJdGVtXCIsXG4gIGNvbnRlbnQ6IFwiaW5saW5lKlwiLFxuICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICAvLyBDcmVhdGVzIGFuIHVub3JkZXJlZCBsaXN0IHdoZW4gc3RhcnRpbmcgd2l0aCBcIi1cIiwgXCIrXCIsIG9yIFwiKlwiLlxuICAgICAgbmV3IFEoe1xuICAgICAgICBmaW5kOiBuZXcgUmVnRXhwKFwiXlstKypdXFxcXHMkXCIpLFxuICAgICAgICBoYW5kbGVyOiAoeyBzdGF0ZTogbiwgY2hhaW46IHQsIHJhbmdlOiBlIH0pID0+IHtcbiAgICAgICAgICB0KCkuQk5VcGRhdGVCbG9jayhuLnNlbGVjdGlvbi5mcm9tLCB7XG4gICAgICAgICAgICB0eXBlOiBcImJ1bGxldExpc3RJdGVtXCIsXG4gICAgICAgICAgICBwcm9wczoge31cbiAgICAgICAgICB9KS5kZWxldGVSYW5nZSh7IGZyb206IGUuZnJvbSwgdG86IGUudG8gfSk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgXTtcbiAgfSxcbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEVudGVyOiAoKSA9PiBqdCh0aGlzLmVkaXRvciksXG4gICAgICBcIk1vZC1TaGlmdC03XCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLkJOVXBkYXRlQmxvY2sodGhpcy5lZGl0b3Iuc3RhdGUuc2VsZWN0aW9uLmFuY2hvciwge1xuICAgICAgICB0eXBlOiBcImJ1bGxldExpc3RJdGVtXCIsXG4gICAgICAgIHByb3BzOiB7fVxuICAgICAgfSlcbiAgICB9O1xuICB9LFxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIC8vIENhc2UgZm9yIHJlZ3VsYXIgSFRNTCBsaXN0IHN0cnVjdHVyZS5cbiAgICAgIHtcbiAgICAgICAgdGFnOiBcImxpXCIsXG4gICAgICAgIGdldEF0dHJzOiAobikgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2YgbiA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgIGNvbnN0IHQgPSBuLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgcmV0dXJuIHQgPT09IG51bGwgPyAhMSA6IHQudGFnTmFtZSA9PT0gXCJVTFwiID8ge30gOiAhMTtcbiAgICAgICAgfSxcbiAgICAgICAgbm9kZTogXCJidWxsZXRMaXN0SXRlbVwiXG4gICAgICB9LFxuICAgICAgLy8gQ2FzZSBmb3IgQmxvY2tOb3RlIGxpc3Qgc3RydWN0dXJlLlxuICAgICAge1xuICAgICAgICB0YWc6IFwicFwiLFxuICAgICAgICBnZXRBdHRyczogKG4pID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIG4gPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICBjb25zdCB0ID0gbi5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgIHJldHVybiB0ID09PSBudWxsID8gITEgOiB0LmdldEF0dHJpYnV0ZShcImRhdGEtY29udGVudC10eXBlXCIpID09PSBcImJ1bGxldExpc3RJdGVtXCIgPyB7fSA6ICExO1xuICAgICAgICB9LFxuICAgICAgICBwcmlvcml0eTogMzAwLFxuICAgICAgICBub2RlOiBcImJ1bGxldExpc3RJdGVtXCJcbiAgICAgIH1cbiAgICBdO1xuICB9LFxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXM6IG4gfSkge1xuICAgIHZhciBvLCByO1xuICAgIGNvbnN0IHQgPSAoKG8gPSB0aGlzLm9wdGlvbnMuZG9tQXR0cmlidXRlcykgPT0gbnVsbCA/IHZvaWQgMCA6IG8uYmxvY2tDb250ZW50KSB8fCB7fSwgZSA9ICgociA9IHRoaXMub3B0aW9ucy5kb21BdHRyaWJ1dGVzKSA9PSBudWxsID8gdm9pZCAwIDogci5pbmxpbmVDb250ZW50KSB8fCB7fTtcbiAgICByZXR1cm4gW1xuICAgICAgXCJkaXZcIixcbiAgICAgIEQobiwge1xuICAgICAgICAuLi50LFxuICAgICAgICBjbGFzczogQihcbiAgICAgICAgICBrLmJsb2NrQ29udGVudCxcbiAgICAgICAgICB0LmNsYXNzXG4gICAgICAgICksXG4gICAgICAgIFwiZGF0YS1jb250ZW50LXR5cGVcIjogdGhpcy5uYW1lXG4gICAgICB9KSxcbiAgICAgIFtcbiAgICAgICAgXCJwXCIsXG4gICAgICAgIHtcbiAgICAgICAgICAuLi5lLFxuICAgICAgICAgIGNsYXNzOiBCKFxuICAgICAgICAgICAgay5pbmxpbmVDb250ZW50LFxuICAgICAgICAgICAgZS5jbGFzc1xuICAgICAgICAgIClcbiAgICAgICAgfSxcbiAgICAgICAgMFxuICAgICAgXVxuICAgIF07XG4gIH1cbn0pLCBFbyA9IHtcbiAgbm9kZTogQ28sXG4gIHByb3BTY2hlbWE6IHdvXG59LCBTbyA9IG5ldyBfKFwibnVtYmVyZWQtbGlzdC1pbmRleGluZ1wiKSwgTW8gPSAoKSA9PiBuZXcgSSh7XG4gIGtleTogU28sXG4gIGFwcGVuZFRyYW5zYWN0aW9uOiAobiwgdCwgZSkgPT4ge1xuICAgIGNvbnN0IG8gPSBlLnRyO1xuICAgIG8uc2V0TWV0YShcIm51bWJlcmVkTGlzdEluZGV4aW5nXCIsICEwKTtcbiAgICBsZXQgciA9ICExO1xuICAgIHJldHVybiBlLmRvYy5kZXNjZW5kYW50cygoaSwgcykgPT4ge1xuICAgICAgaWYgKGkudHlwZS5uYW1lID09PSBcImJsb2NrQ29udGFpbmVyXCIgJiYgaS5maXJzdENoaWxkLnR5cGUubmFtZSA9PT0gXCJudW1iZXJlZExpc3RJdGVtXCIpIHtcbiAgICAgICAgbGV0IGwgPSBcIjFcIjtcbiAgICAgICAgY29uc3QgYSA9IHMgPT09IDEsIGQgPSB2KG8uZG9jLCBzICsgMSk7XG4gICAgICAgIGlmIChkID09PSB2b2lkIDApXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIWEpIHtcbiAgICAgICAgICBjb25zdCBtID0gdihvLmRvYywgcyAtIDIpO1xuICAgICAgICAgIGlmIChtID09PSB2b2lkIDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgaWYgKCEoZC5kZXB0aCAhPT0gbS5kZXB0aCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSBtLmNvbnRlbnROb2RlO1xuICAgICAgICAgICAgaWYgKG0uY29udGVudFR5cGUubmFtZSA9PT0gXCJudW1iZXJlZExpc3RJdGVtXCIpIHtcbiAgICAgICAgICAgICAgY29uc3QgQyA9IGYuYXR0cnMuaW5kZXg7XG4gICAgICAgICAgICAgIGwgPSAocGFyc2VJbnQoQykgKyAxKS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkLmNvbnRlbnROb2RlLmF0dHJzLmluZGV4ICE9PSBsICYmIChyID0gITAsIG8uc2V0Tm9kZU1hcmt1cChzICsgMSwgdm9pZCAwLCB7XG4gICAgICAgICAgaW5kZXg6IGxcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0pLCByID8gbyA6IG51bGw7XG4gIH1cbn0pLCBUbyA9IHtcbiAgLi4uVFxufSwgQm8gPSBXKHtcbiAgbmFtZTogXCJudW1iZXJlZExpc3RJdGVtXCIsXG4gIGNvbnRlbnQ6IFwiaW5saW5lKlwiLFxuICBhZGRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpbmRleDoge1xuICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICBwYXJzZUhUTUw6IChuKSA9PiBuLmdldEF0dHJpYnV0ZShcImRhdGEtaW5kZXhcIiksXG4gICAgICAgIHJlbmRlckhUTUw6IChuKSA9PiAoe1xuICAgICAgICAgIFwiZGF0YS1pbmRleFwiOiBuLmluZGV4XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgLy8gQ3JlYXRlcyBhbiBvcmRlcmVkIGxpc3Qgd2hlbiBzdGFydGluZyB3aXRoIFwiMS5cIi5cbiAgICAgIG5ldyBRKHtcbiAgICAgICAgZmluZDogbmV3IFJlZ0V4cChcIl4xXFxcXC5cXFxccyRcIiksXG4gICAgICAgIGhhbmRsZXI6ICh7IHN0YXRlOiBuLCBjaGFpbjogdCwgcmFuZ2U6IGUgfSkgPT4ge1xuICAgICAgICAgIHQoKS5CTlVwZGF0ZUJsb2NrKG4uc2VsZWN0aW9uLmZyb20sIHtcbiAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyZWRMaXN0SXRlbVwiLFxuICAgICAgICAgICAgcHJvcHM6IHt9XG4gICAgICAgICAgfSkuZGVsZXRlUmFuZ2UoeyBmcm9tOiBlLmZyb20sIHRvOiBlLnRvIH0pO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIF07XG4gIH0sXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBFbnRlcjogKCkgPT4ganQodGhpcy5lZGl0b3IpLFxuICAgICAgXCJNb2QtU2hpZnQtOFwiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5CTlVwZGF0ZUJsb2NrKHRoaXMuZWRpdG9yLnN0YXRlLnNlbGVjdGlvbi5hbmNob3IsIHtcbiAgICAgICAgdHlwZTogXCJudW1iZXJlZExpc3RJdGVtXCIsXG4gICAgICAgIHByb3BzOiB7fVxuICAgICAgfSlcbiAgICB9O1xuICB9LFxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIFtNbygpXTtcbiAgfSxcbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICAvLyBDYXNlIGZvciByZWd1bGFyIEhUTUwgbGlzdCBzdHJ1Y3R1cmUuXG4gICAgICAvLyAoZS5nLjogd2hlbiBwYXN0aW5nIGZyb20gb3RoZXIgYXBwcylcbiAgICAgIHtcbiAgICAgICAgdGFnOiBcImxpXCIsXG4gICAgICAgIGdldEF0dHJzOiAobikgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2YgbiA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgIGNvbnN0IHQgPSBuLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgcmV0dXJuIHQgPT09IG51bGwgPyAhMSA6IHQudGFnTmFtZSA9PT0gXCJPTFwiID8ge30gOiAhMTtcbiAgICAgICAgfSxcbiAgICAgICAgbm9kZTogXCJudW1iZXJlZExpc3RJdGVtXCJcbiAgICAgIH0sXG4gICAgICAvLyBDYXNlIGZvciBCbG9ja05vdGUgbGlzdCBzdHJ1Y3R1cmUuXG4gICAgICAvLyAoZS5nLjogd2hlbiBwYXN0aW5nIGZyb20gYmxvY2tub3RlKVxuICAgICAge1xuICAgICAgICB0YWc6IFwicFwiLFxuICAgICAgICBnZXRBdHRyczogKG4pID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIG4gPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICBjb25zdCB0ID0gbi5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgIHJldHVybiB0ID09PSBudWxsID8gITEgOiB0LmdldEF0dHJpYnV0ZShcImRhdGEtY29udGVudC10eXBlXCIpID09PSBcIm51bWJlcmVkTGlzdEl0ZW1cIiA/IHt9IDogITE7XG4gICAgICAgIH0sXG4gICAgICAgIHByaW9yaXR5OiAzMDAsXG4gICAgICAgIG5vZGU6IFwibnVtYmVyZWRMaXN0SXRlbVwiXG4gICAgICB9XG4gICAgXTtcbiAgfSxcbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzOiBuIH0pIHtcbiAgICB2YXIgbywgcjtcbiAgICBjb25zdCB0ID0gKChvID0gdGhpcy5vcHRpb25zLmRvbUF0dHJpYnV0ZXMpID09IG51bGwgPyB2b2lkIDAgOiBvLmJsb2NrQ29udGVudCkgfHwge30sIGUgPSAoKHIgPSB0aGlzLm9wdGlvbnMuZG9tQXR0cmlidXRlcykgPT0gbnVsbCA/IHZvaWQgMCA6IHIuaW5saW5lQ29udGVudCkgfHwge307XG4gICAgcmV0dXJuIFtcbiAgICAgIFwiZGl2XCIsXG4gICAgICBEKG4sIHtcbiAgICAgICAgLi4udCxcbiAgICAgICAgY2xhc3M6IEIoXG4gICAgICAgICAgay5ibG9ja0NvbnRlbnQsXG4gICAgICAgICAgdC5jbGFzc1xuICAgICAgICApLFxuICAgICAgICBcImRhdGEtY29udGVudC10eXBlXCI6IHRoaXMubmFtZVxuICAgICAgfSksXG4gICAgICAvLyB3ZSB1c2UgYSA8cD4gdGFnLCBiZWNhdXNlIGZvciA8bGk+IHRhZ3Mgd2UnZCBuZWVkIHRvIGFkZCBhIDx1bD4gcGFyZW50IGZvciBhcm91bmQgc2libGluZ3MgdG8gYmUgc2VtYW50aWNhbGx5IGNvcnJlY3QsXG4gICAgICAvLyB3aGljaCB3b3VsZCBiZSBxdWl0ZSBjdW1iZXJzb21lXG4gICAgICBbXG4gICAgICAgIFwicFwiLFxuICAgICAgICB7XG4gICAgICAgICAgLi4uZSxcbiAgICAgICAgICBjbGFzczogQihcbiAgICAgICAgICAgIGsuaW5saW5lQ29udGVudCxcbiAgICAgICAgICAgIGUuY2xhc3NcbiAgICAgICAgICApXG4gICAgICAgIH0sXG4gICAgICAgIDBcbiAgICAgIF1cbiAgICBdO1xuICB9XG59KSwgeG8gPSB7XG4gIG5vZGU6IEJvLFxuICBwcm9wU2NoZW1hOiBUb1xufSwgSW8gPSB7XG4gIC4uLlRcbn0sIF9vID0gVyh7XG4gIG5hbWU6IFwicGFyYWdyYXBoXCIsXG4gIGNvbnRlbnQ6IFwiaW5saW5lKlwiLFxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdGFnOiBcInBcIixcbiAgICAgICAgcHJpb3JpdHk6IDIwMCxcbiAgICAgICAgbm9kZTogXCJwYXJhZ3JhcGhcIlxuICAgICAgfVxuICAgIF07XG4gIH0sXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlczogbiB9KSB7XG4gICAgdmFyIG8sIHI7XG4gICAgY29uc3QgdCA9ICgobyA9IHRoaXMub3B0aW9ucy5kb21BdHRyaWJ1dGVzKSA9PSBudWxsID8gdm9pZCAwIDogby5ibG9ja0NvbnRlbnQpIHx8IHt9LCBlID0gKChyID0gdGhpcy5vcHRpb25zLmRvbUF0dHJpYnV0ZXMpID09IG51bGwgPyB2b2lkIDAgOiByLmlubGluZUNvbnRlbnQpIHx8IHt9O1xuICAgIHJldHVybiBbXG4gICAgICBcImRpdlwiLFxuICAgICAgRChcbiAgICAgICAge1xuICAgICAgICAgIC4uLnQsXG4gICAgICAgICAgY2xhc3M6IEIoXG4gICAgICAgICAgICBrLmJsb2NrQ29udGVudCxcbiAgICAgICAgICAgIHQuY2xhc3NcbiAgICAgICAgICApLFxuICAgICAgICAgIFwiZGF0YS1jb250ZW50LXR5cGVcIjogdGhpcy5uYW1lXG4gICAgICAgIH0sXG4gICAgICAgIG5cbiAgICAgICksXG4gICAgICBbXG4gICAgICAgIFwicFwiLFxuICAgICAgICB7XG4gICAgICAgICAgLi4uZSxcbiAgICAgICAgICBjbGFzczogQihcbiAgICAgICAgICAgIGsuaW5saW5lQ29udGVudCxcbiAgICAgICAgICAgIGUuY2xhc3NcbiAgICAgICAgICApXG4gICAgICAgIH0sXG4gICAgICAgIDBcbiAgICAgIF1cbiAgICBdO1xuICB9XG59KSwgQW8gPSB7XG4gIG5vZGU6IF9vLFxuICBwcm9wU2NoZW1hOiBJb1xufTtcbmNsYXNzIEhvIHtcbiAgY29uc3RydWN0b3IodCwgZSwgbykge1xuICAgIHUodGhpcywgXCJpbWFnZVRvb2xiYXJTdGF0ZVwiKTtcbiAgICB1KHRoaXMsIFwidXBkYXRlSW1hZ2VUb29sYmFyXCIpO1xuICAgIHUodGhpcywgXCJwcmV2V2FzRWRpdGFibGVcIiwgbnVsbCk7XG4gICAgdSh0aGlzLCBcInNob3VsZFNob3dcIiwgKHQpID0+IFwibm9kZVwiIGluIHQuc2VsZWN0aW9uICYmIHQuc2VsZWN0aW9uLm5vZGUudHlwZS5uYW1lID09PSBcImltYWdlXCIgJiYgdC5zZWxlY3Rpb24ubm9kZS5hdHRycy5zcmMgPT09IFwiXCIpO1xuICAgIHUodGhpcywgXCJtb3VzZURvd25IYW5kbGVyXCIsICgpID0+IHtcbiAgICAgIHZhciB0O1xuICAgICAgKHQgPSB0aGlzLmltYWdlVG9vbGJhclN0YXRlKSAhPSBudWxsICYmIHQuc2hvdyAmJiAodGhpcy5pbWFnZVRvb2xiYXJTdGF0ZS5zaG93ID0gITEsIHRoaXMudXBkYXRlSW1hZ2VUb29sYmFyKCkpO1xuICAgIH0pO1xuICAgIC8vIEZvciBkcmFnZ2luZyB0aGUgd2hvbGUgZWRpdG9yLlxuICAgIHUodGhpcywgXCJkcmFnc3RhcnRIYW5kbGVyXCIsICgpID0+IHtcbiAgICAgIHZhciB0O1xuICAgICAgKHQgPSB0aGlzLmltYWdlVG9vbGJhclN0YXRlKSAhPSBudWxsICYmIHQuc2hvdyAmJiAodGhpcy5pbWFnZVRvb2xiYXJTdGF0ZS5zaG93ID0gITEsIHRoaXMudXBkYXRlSW1hZ2VUb29sYmFyKCkpO1xuICAgIH0pO1xuICAgIHUodGhpcywgXCJibHVySGFuZGxlclwiLCAodCkgPT4ge1xuICAgICAgdmFyIG87XG4gICAgICBjb25zdCBlID0gdGhpcy5wbVZpZXcuZG9tLnBhcmVudEVsZW1lbnQ7XG4gICAgICAvLyBBbiBlbGVtZW50IGlzIGNsaWNrZWQuXG4gICAgICB0ICYmIHQucmVsYXRlZFRhcmdldCAmJiAvLyBFbGVtZW50IGlzIGluc2lkZSB0aGUgZWRpdG9yLlxuICAgICAgKGUgPT09IHQucmVsYXRlZFRhcmdldCB8fCBlLmNvbnRhaW5zKHQucmVsYXRlZFRhcmdldCkpIHx8IChvID0gdGhpcy5pbWFnZVRvb2xiYXJTdGF0ZSkgIT0gbnVsbCAmJiBvLnNob3cgJiYgKHRoaXMuaW1hZ2VUb29sYmFyU3RhdGUuc2hvdyA9ICExLCB0aGlzLnVwZGF0ZUltYWdlVG9vbGJhcigpKTtcbiAgICB9KTtcbiAgICB1KHRoaXMsIFwic2Nyb2xsSGFuZGxlclwiLCAoKSA9PiB7XG4gICAgICB2YXIgdDtcbiAgICAgIGlmICgodCA9IHRoaXMuaW1hZ2VUb29sYmFyU3RhdGUpICE9IG51bGwgJiYgdC5zaG93KSB7XG4gICAgICAgIGNvbnN0IGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgIGBbZGF0YS1ub2RlLXR5cGU9XCJibG9ja0NvbnRhaW5lclwiXVtkYXRhLWlkPVwiJHt0aGlzLmltYWdlVG9vbGJhclN0YXRlLmJsb2NrLmlkfVwiXWBcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5pbWFnZVRvb2xiYXJTdGF0ZS5yZWZlcmVuY2VQb3MgPSBlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB0aGlzLnVwZGF0ZUltYWdlVG9vbGJhcigpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMucGx1Z2luS2V5ID0gdCwgdGhpcy5wbVZpZXcgPSBlLCB0aGlzLnVwZGF0ZUltYWdlVG9vbGJhciA9ICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5pbWFnZVRvb2xiYXJTdGF0ZSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXR0ZW1wdGluZyB0byB1cGRhdGUgdW5pbml0aWFsaXplZCBpbWFnZSB0b29sYmFyXCIpO1xuICAgICAgbyh0aGlzLmltYWdlVG9vbGJhclN0YXRlKTtcbiAgICB9LCBlLmRvbS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMubW91c2VEb3duSGFuZGxlciksIGUuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnc3RhcnRcIiwgdGhpcy5kcmFnc3RhcnRIYW5kbGVyKSwgZS5kb20uYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgdGhpcy5ibHVySGFuZGxlciksIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5zY3JvbGxIYW5kbGVyKTtcbiAgfVxuICB1cGRhdGUodCwgZSkge1xuICAgIHZhciByLCBpO1xuICAgIGNvbnN0IG8gPSB0aGlzLnBsdWdpbktleS5nZXRTdGF0ZSh0LnN0YXRlKTtcbiAgICBpZiAoISgociA9IHRoaXMuaW1hZ2VUb29sYmFyU3RhdGUpICE9IG51bGwgJiYgci5zaG93KSAmJiBvLmJsb2NrKSB7XG4gICAgICBjb25zdCBzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICAgICAgYFtkYXRhLW5vZGUtdHlwZT1cImJsb2NrQ29udGFpbmVyXCJdW2RhdGEtaWQ9XCIke28uYmxvY2suaWR9XCJdYFxuICAgICAgKTtcbiAgICAgIHRoaXMuaW1hZ2VUb29sYmFyU3RhdGUgPSB7XG4gICAgICAgIHNob3c6ICEwLFxuICAgICAgICByZWZlcmVuY2VQb3M6IHMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgIGJsb2NrOiBvLmJsb2NrXG4gICAgICB9LCB0aGlzLnVwZGF0ZUltYWdlVG9vbGJhcigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAoIXQuc3RhdGUuc2VsZWN0aW9uLmVxKGUuc2VsZWN0aW9uKSB8fCAhdC5zdGF0ZS5kb2MuZXEoZS5kb2MpKSAmJiAoaSA9IHRoaXMuaW1hZ2VUb29sYmFyU3RhdGUpICE9IG51bGwgJiYgaS5zaG93ICYmICh0aGlzLmltYWdlVG9vbGJhclN0YXRlLnNob3cgPSAhMSwgdGhpcy51cGRhdGVJbWFnZVRvb2xiYXIoKSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnBtVmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLm1vdXNlRG93bkhhbmRsZXIpLCB0aGlzLnBtVmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImRyYWdzdGFydFwiLCB0aGlzLmRyYWdzdGFydEhhbmRsZXIpLCB0aGlzLnBtVmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgdGhpcy5ibHVySGFuZGxlciksIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5zY3JvbGxIYW5kbGVyKTtcbiAgfVxufVxuY29uc3QgVSA9IG5ldyBfKFwiSW1hZ2VUb29sYmFyUGx1Z2luXCIpO1xuY2xhc3MgTG8gZXh0ZW5kcyAkIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdSh0aGlzLCBcInZpZXdcIik7XG4gICAgdSh0aGlzLCBcInBsdWdpblwiKTtcbiAgICB0aGlzLnBsdWdpbiA9IG5ldyBJKHtcbiAgICAgIGtleTogVSxcbiAgICAgIHZpZXc6IChvKSA9PiAodGhpcy52aWV3ID0gbmV3IEhvKFxuICAgICAgICAvLyBlZGl0b3IsXG4gICAgICAgIFUsXG4gICAgICAgIG8sXG4gICAgICAgIChyKSA9PiB7XG4gICAgICAgICAgdGhpcy5lbWl0KFwidXBkYXRlXCIsIHIpO1xuICAgICAgICB9XG4gICAgICApLCB0aGlzLnZpZXcpLFxuICAgICAgc3RhdGU6IHtcbiAgICAgICAgaW5pdDogKCkgPT4gKHtcbiAgICAgICAgICBibG9jazogdm9pZCAwXG4gICAgICAgIH0pLFxuICAgICAgICBhcHBseTogKG8pID0+IHtcbiAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYmxvY2s6IChpID0gby5nZXRNZXRhKFUpKSA9PSBudWxsID8gdm9pZCAwIDogaS5ibG9ja1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBvblVwZGF0ZShlKSB7XG4gICAgcmV0dXJuIHRoaXMub24oXCJ1cGRhdGVcIiwgZSk7XG4gIH1cbn1cbmNvbnN0IE5vID0ge1xuICB0ZXh0QWxpZ25tZW50OiBULnRleHRBbGlnbm1lbnQsXG4gIGJhY2tncm91bmRDb2xvcjogVC5iYWNrZ3JvdW5kQ29sb3IsXG4gIC8vIEltYWdlIHVybC5cbiAgdXJsOiB7XG4gICAgZGVmYXVsdDogXCJcIlxuICB9LFxuICAvLyBJbWFnZSBjYXB0aW9uLlxuICBjYXB0aW9uOiB7XG4gICAgZGVmYXVsdDogXCJcIlxuICB9LFxuICAvLyBJbWFnZSB3aWR0aCBpbiBweC5cbiAgd2lkdGg6IHtcbiAgICBkZWZhdWx0OiA1MTJcbiAgfVxufSwgdXQgPSAobikgPT4ge1xuICBzd2l0Y2ggKG4pIHtcbiAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgcmV0dXJuIFwiZmxleC1zdGFydFwiO1xuICAgIGNhc2UgXCJjZW50ZXJcIjpcbiAgICAgIHJldHVybiBcImNlbnRlclwiO1xuICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgcmV0dXJuIFwiZmxleC1lbmRcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFwiZmxleC1zdGFydFwiO1xuICB9XG59LCBwdCA9IDY0LCBQbyA9IChuLCB0KSA9PiB7XG4gIGNvbnN0IGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBlLmNsYXNzTmFtZSA9IGsud3JhcHBlciwgZS5zdHlsZS5hbGlnbkl0ZW1zID0gdXQoXG4gICAgbi5wcm9wcy50ZXh0QWxpZ25tZW50XG4gICk7XG4gIGNvbnN0IG8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBvLmNsYXNzTmFtZSA9IGsuYWRkSW1hZ2VCdXR0b24sIG8uc3R5bGUuZGlzcGxheSA9IG4ucHJvcHMudXJsID09PSBcIlwiID8gXCJcIiA6IFwibm9uZVwiO1xuICBjb25zdCByID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgci5jbGFzc05hbWUgPSBrLmFkZEltYWdlQnV0dG9uSWNvbjtcbiAgY29uc3QgaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwXCIpO1xuICBpLmNsYXNzTmFtZSA9IGsuYWRkSW1hZ2VCdXR0b25UZXh0LCBpLmlubmVyVGV4dCA9IFwiQWRkIEltYWdlXCI7XG4gIGNvbnN0IHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBzLmNsYXNzTmFtZSA9IGsuaW1hZ2VBbmRDYXB0aW9uV3JhcHBlciwgcy5zdHlsZS5kaXNwbGF5ID0gbi5wcm9wcy51cmwgIT09IFwiXCIgPyBcIlwiIDogXCJub25lXCI7XG4gIGNvbnN0IGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBsLmNsYXNzTmFtZSA9IGsuaW1hZ2VXcmFwcGVyLCBsLnN0eWxlLmRpc3BsYXkgPSBuLnByb3BzLnVybCAhPT0gXCJcIiA/IFwiXCIgOiBcIm5vbmVcIjtcbiAgY29uc3QgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gIGEuY2xhc3NOYW1lID0gay5pbWFnZSwgYS5zcmMgPSBuLnByb3BzLnVybCwgYS5hbHQgPSBcInBsYWNlaG9sZGVyXCIsIGEuY29udGVudEVkaXRhYmxlID0gXCJmYWxzZVwiLCBhLmRyYWdnYWJsZSA9ICExLCBhLnN0eWxlLndpZHRoID0gYCR7TWF0aC5taW4oXG4gICAgbi5wcm9wcy53aWR0aCxcbiAgICB0LmRvbUVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQuY2xpZW50V2lkdGhcbiAgKX1weGA7XG4gIGNvbnN0IGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBkLmNsYXNzTmFtZSA9IGsucmVzaXplSGFuZGxlLCBkLnN0eWxlLmxlZnQgPSBcIjRweFwiO1xuICBjb25zdCBjID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgYy5jbGFzc05hbWUgPSBrLnJlc2l6ZUhhbmRsZSwgYy5zdHlsZS5yaWdodCA9IFwiNHB4XCI7XG4gIGNvbnN0IGggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicFwiKTtcbiAgaC5jbGFzc05hbWUgPSBrLmNhcHRpb24sIGguaW5uZXJUZXh0ID0gbi5wcm9wcy5jYXB0aW9uLCBoLnN0eWxlLnBhZGRpbmcgPSBuLnByb3BzLmNhcHRpb24gPyBcIjRweFwiIDogXCJcIjtcbiAgY29uc3QgbSA9ICgpID0+IHtcbiAgICB2YXIgbnQ7XG4gICAgY29uc3QgZyA9ICgobnQgPSB0LmdldFNlbGVjdGlvbigpKSA9PSBudWxsID8gdm9pZCAwIDogbnQuYmxvY2tzKSB8fCBbXTtcbiAgICBbdC5nZXRUZXh0Q3Vyc29yUG9zaXRpb24oKS5ibG9jaywgLi4uZ10uZmluZChcbiAgICAgIChZdCkgPT4gWXQuaWQgPT09IG4uaWRcbiAgICApICE9PSB2b2lkIDAgPyAoby5zdHlsZS5vdXRsaW5lID0gXCI0cHggc29saWQgcmdiKDEwMCwgMTYwLCAyNTUpXCIsIHMuc3R5bGUub3V0bGluZSA9IFwiNHB4IHNvbGlkIHJnYigxMDAsIDE2MCwgMjU1KVwiKSA6IChvLnN0eWxlLm91dGxpbmUgPSBcIlwiLCBzLnN0eWxlLm91dGxpbmUgPSBcIlwiKTtcbiAgfTtcbiAgdC5vbkVkaXRvckNvbnRlbnRDaGFuZ2UobSksIHQub25FZGl0b3JTZWxlY3Rpb25DaGFuZ2UobSk7XG4gIGxldCBwO1xuICBjb25zdCBmID0gKGcpID0+IHtcbiAgICBpZiAoIXApXG4gICAgICByZXR1cm47XG4gICAgbGV0IHg7XG4gICAgdXQobi5wcm9wcy50ZXh0QWxpZ25tZW50KSA9PT0gXCJjZW50ZXJcIiA/IHAuaGFuZGxlVXNlZCA9PT0gXCJsZWZ0XCIgPyB4ID0gcC5pbml0aWFsV2lkdGggKyAocC5pbml0aWFsQ2xpZW50WCAtIGcuY2xpZW50WCkgKiAyIDogeCA9IHAuaW5pdGlhbFdpZHRoICsgKGcuY2xpZW50WCAtIHAuaW5pdGlhbENsaWVudFgpICogMiA6IHAuaGFuZGxlVXNlZCA9PT0gXCJsZWZ0XCIgPyB4ID0gcC5pbml0aWFsV2lkdGggKyBwLmluaXRpYWxDbGllbnRYIC0gZy5jbGllbnRYIDogeCA9IHAuaW5pdGlhbFdpZHRoICsgZy5jbGllbnRYIC0gcC5pbml0aWFsQ2xpZW50WCwgeCA8IHB0ID8gYS5zdHlsZS53aWR0aCA9IGAke3B0fXB4YCA6IHggPiB0LmRvbUVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQuY2xpZW50V2lkdGggPyBhLnN0eWxlLndpZHRoID0gYCR7dC5kb21FbGVtZW50LmZpcnN0RWxlbWVudENoaWxkLmNsaWVudFdpZHRofXB4YCA6IGEuc3R5bGUud2lkdGggPSBgJHt4fXB4YDtcbiAgfSwgYiA9IChnKSA9PiB7XG4gICAgcCAmJiAoKCFnLnRhcmdldCB8fCAhbC5jb250YWlucyhnLnRhcmdldCkpICYmIGwuY29udGFpbnMoZCkgJiYgbC5jb250YWlucyhjKSAmJiAoZC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCIsIGMuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiKSwgcCA9IHZvaWQgMCwgdC51cGRhdGVCbG9jayhuLCB7XG4gICAgICB0eXBlOiBcImltYWdlXCIsXG4gICAgICBwcm9wczoge1xuICAgICAgICAvLyBSZW1vdmVzIFwicHhcIiBmcm9tIHRoZSBlbmQgb2YgdGhlIHdpZHRoIHN0cmluZyBhbmQgY29udmVydHMgdG8gZmxvYXQuXG4gICAgICAgIHdpZHRoOiBwYXJzZUZsb2F0KGEuc3R5bGUud2lkdGguc2xpY2UoMCwgLTIpKVxuICAgICAgfVxuICAgIH0pKTtcbiAgfSwgdyA9IChnKSA9PiB7XG4gICAgZy5wcmV2ZW50RGVmYXVsdCgpO1xuICB9LCBDID0gKCkgPT4ge1xuICAgIHQuX3RpcHRhcEVkaXRvci52aWV3LmRpc3BhdGNoKFxuICAgICAgdC5fdGlwdGFwRWRpdG9yLnN0YXRlLnRyLnNldE1ldGEoVSwge1xuICAgICAgICBibG9jazogblxuICAgICAgfSlcbiAgICApO1xuICB9LCBNID0gKCkgPT4ge1xuICAgIHQuaXNFZGl0YWJsZSA/IChkLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCIsIGMuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIikgOiAoZC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCIsIGMuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiKTtcbiAgfSwgRSA9IChnKSA9PiB7XG4gICAgZy5yZWxhdGVkVGFyZ2V0ID09PSBkIHx8IGcucmVsYXRlZFRhcmdldCA9PT0gYyB8fCBwIHx8IChkLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIiwgYy5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCIpO1xuICB9LCB5ID0gKGcpID0+IHtcbiAgICBnLnByZXZlbnREZWZhdWx0KCksIGQuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIiwgYy5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiLCBwID0ge1xuICAgICAgaGFuZGxlVXNlZDogXCJsZWZ0XCIsXG4gICAgICBpbml0aWFsV2lkdGg6IG4ucHJvcHMud2lkdGgsXG4gICAgICBpbml0aWFsQ2xpZW50WDogZy5jbGllbnRYXG4gICAgfTtcbiAgfSwgUyA9IChnKSA9PiB7XG4gICAgZy5wcmV2ZW50RGVmYXVsdCgpLCBkLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCIsIGMuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIiwgcCA9IHtcbiAgICAgIGhhbmRsZVVzZWQ6IFwicmlnaHRcIixcbiAgICAgIGluaXRpYWxXaWR0aDogbi5wcm9wcy53aWR0aCxcbiAgICAgIGluaXRpYWxDbGllbnRYOiBnLmNsaWVudFhcbiAgICB9O1xuICB9O1xuICByZXR1cm4gZS5hcHBlbmRDaGlsZChvKSwgby5hcHBlbmRDaGlsZChyKSwgby5hcHBlbmRDaGlsZChpKSwgZS5hcHBlbmRDaGlsZChzKSwgcy5hcHBlbmRDaGlsZChsKSwgbC5hcHBlbmRDaGlsZChhKSwgbC5hcHBlbmRDaGlsZChkKSwgbC5hcHBlbmRDaGlsZChjKSwgcy5hcHBlbmRDaGlsZChoKSwgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgZiksIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBiKSwgby5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHcpLCBvLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBDKSwgYS5hZGRFdmVudExpc3RlbmVyKFwibW91c2VlbnRlclwiLCBNKSwgYS5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCBFKSwgZC5hZGRFdmVudExpc3RlbmVyKFxuICAgIFwibW91c2Vkb3duXCIsXG4gICAgeVxuICApLCBjLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgXCJtb3VzZWRvd25cIixcbiAgICBTXG4gICksIHtcbiAgICBkb206IGUsXG4gICAgZGVzdHJveTogKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgZiksIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBiKSwgby5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICBcIm1vdXNlZG93blwiLFxuICAgICAgICB3XG4gICAgICApLCBvLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBDKSwgZC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICBcIm1vdXNlZG93blwiLFxuICAgICAgICB5XG4gICAgICApLCBjLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwibW91c2Vkb3duXCIsXG4gICAgICAgIFNcbiAgICAgICk7XG4gICAgfVxuICB9O1xufSwgRG8gPSBrbyh7XG4gIHR5cGU6IFwiaW1hZ2VcIixcbiAgcHJvcFNjaGVtYTogTm8sXG4gIGNvbnRhaW5zSW5saW5lQ29udGVudDogITEsXG4gIHJlbmRlcjogUG9cbn0pLCBxdCA9IHtcbiAgcGFyYWdyYXBoOiBBbyxcbiAgaGVhZGluZzogdm8sXG4gIGJ1bGxldExpc3RJdGVtOiBFbyxcbiAgbnVtYmVyZWRMaXN0SXRlbTogeG8sXG4gIGltYWdlOiBEb1xufTtcbmNsYXNzIE9vIHtcbiAgY29uc3RydWN0b3IodCwgZSwgbykge1xuICAgIHUodGhpcywgXCJmb3JtYXR0aW5nVG9vbGJhclN0YXRlXCIpO1xuICAgIHUodGhpcywgXCJ1cGRhdGVGb3JtYXR0aW5nVG9vbGJhclwiKTtcbiAgICB1KHRoaXMsIFwicHJldmVudEhpZGVcIiwgITEpO1xuICAgIHUodGhpcywgXCJwcmV2ZW50U2hvd1wiLCAhMSk7XG4gICAgdSh0aGlzLCBcInByZXZXYXNFZGl0YWJsZVwiLCBudWxsKTtcbiAgICB1KHRoaXMsIFwic2hvdWxkU2hvd1wiLCAoeyB2aWV3OiB0LCBzdGF0ZTogZSwgZnJvbTogbywgdG86IHIgfSkgPT4ge1xuICAgICAgY29uc3QgeyBkb2M6IGksIHNlbGVjdGlvbjogcyB9ID0gZSwgeyBlbXB0eTogbCB9ID0gcywgYSA9ICFpLnRleHRCZXR3ZWVuKG8sIHIpLmxlbmd0aCAmJiBuZShlLnNlbGVjdGlvbik7XG4gICAgICByZXR1cm4gISghdC5oYXNGb2N1cygpIHx8IGwgfHwgYSk7XG4gICAgfSk7XG4gICAgdSh0aGlzLCBcInZpZXdNb3VzZWRvd25IYW5kbGVyXCIsICgpID0+IHtcbiAgICAgIHRoaXMucHJldmVudFNob3cgPSAhMDtcbiAgICB9KTtcbiAgICB1KHRoaXMsIFwidmlld01vdXNldXBIYW5kbGVyXCIsICgpID0+IHtcbiAgICAgIHRoaXMucHJldmVudFNob3cgPSAhMSwgc2V0VGltZW91dCgoKSA9PiB0aGlzLnVwZGF0ZSh0aGlzLnBtVmlldykpO1xuICAgIH0pO1xuICAgIC8vIEZvciBkcmFnZ2luZyB0aGUgd2hvbGUgZWRpdG9yLlxuICAgIHUodGhpcywgXCJkcmFnc3RhcnRIYW5kbGVyXCIsICgpID0+IHtcbiAgICAgIHZhciB0O1xuICAgICAgKHQgPSB0aGlzLmZvcm1hdHRpbmdUb29sYmFyU3RhdGUpICE9IG51bGwgJiYgdC5zaG93ICYmICh0aGlzLmZvcm1hdHRpbmdUb29sYmFyU3RhdGUuc2hvdyA9ICExLCB0aGlzLnVwZGF0ZUZvcm1hdHRpbmdUb29sYmFyKCkpO1xuICAgIH0pO1xuICAgIHUodGhpcywgXCJmb2N1c0hhbmRsZXJcIiwgKCkgPT4ge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnVwZGF0ZSh0aGlzLnBtVmlldykpO1xuICAgIH0pO1xuICAgIHUodGhpcywgXCJibHVySGFuZGxlclwiLCAodCkgPT4ge1xuICAgICAgdmFyIG87XG4gICAgICBpZiAodGhpcy5wcmV2ZW50SGlkZSkge1xuICAgICAgICB0aGlzLnByZXZlbnRIaWRlID0gITE7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGUgPSB0aGlzLnBtVmlldy5kb20ucGFyZW50RWxlbWVudDtcbiAgICAgIC8vIEFuIGVsZW1lbnQgaXMgY2xpY2tlZC5cbiAgICAgIHQgJiYgdC5yZWxhdGVkVGFyZ2V0ICYmIC8vIEVsZW1lbnQgaXMgaW5zaWRlIHRoZSBlZGl0b3IuXG4gICAgICAoZSA9PT0gdC5yZWxhdGVkVGFyZ2V0IHx8IGUuY29udGFpbnModC5yZWxhdGVkVGFyZ2V0KSkgfHwgKG8gPSB0aGlzLmZvcm1hdHRpbmdUb29sYmFyU3RhdGUpICE9IG51bGwgJiYgby5zaG93ICYmICh0aGlzLmZvcm1hdHRpbmdUb29sYmFyU3RhdGUuc2hvdyA9ICExLCB0aGlzLnVwZGF0ZUZvcm1hdHRpbmdUb29sYmFyKCkpO1xuICAgIH0pO1xuICAgIHUodGhpcywgXCJzY3JvbGxIYW5kbGVyXCIsICgpID0+IHtcbiAgICAgIHZhciB0O1xuICAgICAgKHQgPSB0aGlzLmZvcm1hdHRpbmdUb29sYmFyU3RhdGUpICE9IG51bGwgJiYgdC5zaG93ICYmICh0aGlzLmZvcm1hdHRpbmdUb29sYmFyU3RhdGUucmVmZXJlbmNlUG9zID0gdGhpcy5nZXRTZWxlY3Rpb25Cb3VuZGluZ0JveCgpLCB0aGlzLnVwZGF0ZUZvcm1hdHRpbmdUb29sYmFyKCkpO1xuICAgIH0pO1xuICAgIHRoaXMuZWRpdG9yID0gdCwgdGhpcy5wbVZpZXcgPSBlLCB0aGlzLnVwZGF0ZUZvcm1hdHRpbmdUb29sYmFyID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmZvcm1hdHRpbmdUb29sYmFyU3RhdGUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIkF0dGVtcHRpbmcgdG8gdXBkYXRlIHVuaW5pdGlhbGl6ZWQgZm9ybWF0dGluZyB0b29sYmFyXCJcbiAgICAgICAgKTtcbiAgICAgIG8odGhpcy5mb3JtYXR0aW5nVG9vbGJhclN0YXRlKTtcbiAgICB9LCBlLmRvbS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMudmlld01vdXNlZG93bkhhbmRsZXIpLCBlLmRvbS5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLnZpZXdNb3VzZXVwSGFuZGxlciksIGUuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnc3RhcnRcIiwgdGhpcy5kcmFnc3RhcnRIYW5kbGVyKSwgZS5kb20uYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuZm9jdXNIYW5kbGVyKSwgZS5kb20uYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgdGhpcy5ibHVySGFuZGxlciksIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5zY3JvbGxIYW5kbGVyKTtcbiAgfVxuICB1cGRhdGUodCwgZSkge1xuICAgIHZhciBtLCBwO1xuICAgIGNvbnN0IHsgc3RhdGU6IG8sIGNvbXBvc2luZzogciB9ID0gdCwgeyBkb2M6IGksIHNlbGVjdGlvbjogcyB9ID0gbywgbCA9IGUgJiYgZS5kb2MuZXEoaSkgJiYgZS5zZWxlY3Rpb24uZXEocyk7XG4gICAgaWYgKCh0aGlzLnByZXZXYXNFZGl0YWJsZSA9PT0gbnVsbCB8fCB0aGlzLnByZXZXYXNFZGl0YWJsZSA9PT0gdGhpcy5lZGl0b3IuaXNFZGl0YWJsZSkgJiYgKHIgfHwgbCkpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5wcmV2V2FzRWRpdGFibGUgPSB0aGlzLmVkaXRvci5pc0VkaXRhYmxlO1xuICAgIGNvbnN0IHsgcmFuZ2VzOiBhIH0gPSBzLCBkID0gTWF0aC5taW4oLi4uYS5tYXAoKGYpID0+IGYuJGZyb20ucG9zKSksIGMgPSBNYXRoLm1heCguLi5hLm1hcCgoZikgPT4gZi4kdG8ucG9zKSksIGggPSAobSA9IHRoaXMuc2hvdWxkU2hvdykgPT0gbnVsbCA/IHZvaWQgMCA6IG0uY2FsbCh0aGlzLCB7XG4gICAgICB2aWV3OiB0LFxuICAgICAgc3RhdGU6IG8sXG4gICAgICBmcm9tOiBkLFxuICAgICAgdG86IGNcbiAgICB9KTtcbiAgICBpZiAodGhpcy5lZGl0b3IuaXNFZGl0YWJsZSAmJiAhdGhpcy5wcmV2ZW50U2hvdyAmJiAoaCB8fCB0aGlzLnByZXZlbnRIaWRlKSkge1xuICAgICAgdGhpcy5mb3JtYXR0aW5nVG9vbGJhclN0YXRlID0ge1xuICAgICAgICBzaG93OiAhMCxcbiAgICAgICAgcmVmZXJlbmNlUG9zOiB0aGlzLmdldFNlbGVjdGlvbkJvdW5kaW5nQm94KClcbiAgICAgIH0sIHRoaXMudXBkYXRlRm9ybWF0dGluZ1Rvb2xiYXIoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKChwID0gdGhpcy5mb3JtYXR0aW5nVG9vbGJhclN0YXRlKSAhPSBudWxsICYmIHAuc2hvdyAmJiAhdGhpcy5wcmV2ZW50SGlkZSAmJiAoIWggfHwgdGhpcy5wcmV2ZW50U2hvdyB8fCAhdGhpcy5lZGl0b3IuaXNFZGl0YWJsZSkpIHtcbiAgICAgIHRoaXMuZm9ybWF0dGluZ1Rvb2xiYXJTdGF0ZS5zaG93ID0gITEsIHRoaXMudXBkYXRlRm9ybWF0dGluZ1Rvb2xiYXIoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnBtVmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLnZpZXdNb3VzZWRvd25IYW5kbGVyKSwgdGhpcy5wbVZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMudmlld01vdXNldXBIYW5kbGVyKSwgdGhpcy5wbVZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkcmFnc3RhcnRcIiwgdGhpcy5kcmFnc3RhcnRIYW5kbGVyKSwgdGhpcy5wbVZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLmZvY3VzSGFuZGxlciksIHRoaXMucG1WaWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLmJsdXJIYW5kbGVyKSwgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLnNjcm9sbEhhbmRsZXIpO1xuICB9XG4gIGdldFNlbGVjdGlvbkJvdW5kaW5nQm94KCkge1xuICAgIGNvbnN0IHsgc3RhdGU6IHQgfSA9IHRoaXMucG1WaWV3LCB7IHNlbGVjdGlvbjogZSB9ID0gdCwgeyByYW5nZXM6IG8gfSA9IGUsIHIgPSBNYXRoLm1pbiguLi5vLm1hcCgocykgPT4gcy4kZnJvbS5wb3MpKSwgaSA9IE1hdGgubWF4KC4uLm8ubWFwKChzKSA9PiBzLiR0by5wb3MpKTtcbiAgICBpZiAocmUoZSkpIHtcbiAgICAgIGNvbnN0IHMgPSB0aGlzLnBtVmlldy5ub2RlRE9NKHIpO1xuICAgICAgaWYgKHMpXG4gICAgICAgIHJldHVybiBzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIH1cbiAgICByZXR1cm4gWSh0aGlzLnBtVmlldywgciwgaSk7XG4gIH1cbn1cbmNvbnN0IFJvID0gbmV3IF8oXG4gIFwiRm9ybWF0dGluZ1Rvb2xiYXJQbHVnaW5cIlxuKTtcbmNsYXNzIHpvIGV4dGVuZHMgJCB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBzdXBlcigpO1xuICAgIHUodGhpcywgXCJ2aWV3XCIpO1xuICAgIHUodGhpcywgXCJwbHVnaW5cIik7XG4gICAgdGhpcy5wbHVnaW4gPSBuZXcgSSh7XG4gICAgICBrZXk6IFJvLFxuICAgICAgdmlldzogKG8pID0+ICh0aGlzLnZpZXcgPSBuZXcgT28oZSwgbywgKHIpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KFwidXBkYXRlXCIsIHIpO1xuICAgICAgfSksIHRoaXMudmlldylcbiAgICB9KTtcbiAgfVxuICBvblVwZGF0ZShlKSB7XG4gICAgcmV0dXJuIHRoaXMub24oXCJ1cGRhdGVcIiwgZSk7XG4gIH1cbn1cbmNsYXNzIFZvIHtcbiAgY29uc3RydWN0b3IodCwgZSwgbykge1xuICAgIHUodGhpcywgXCJoeXBlcmxpbmtUb29sYmFyU3RhdGVcIik7XG4gICAgdSh0aGlzLCBcInVwZGF0ZUh5cGVybGlua1Rvb2xiYXJcIik7XG4gICAgdSh0aGlzLCBcIm1lbnVVcGRhdGVUaW1lclwiKTtcbiAgICB1KHRoaXMsIFwic3RhcnRNZW51VXBkYXRlVGltZXJcIik7XG4gICAgdSh0aGlzLCBcInN0b3BNZW51VXBkYXRlVGltZXJcIik7XG4gICAgdSh0aGlzLCBcIm1vdXNlSG92ZXJlZEh5cGVybGlua01hcmtcIik7XG4gICAgdSh0aGlzLCBcIm1vdXNlSG92ZXJlZEh5cGVybGlua01hcmtSYW5nZVwiKTtcbiAgICB1KHRoaXMsIFwia2V5Ym9hcmRIb3ZlcmVkSHlwZXJsaW5rTWFya1wiKTtcbiAgICB1KHRoaXMsIFwia2V5Ym9hcmRIb3ZlcmVkSHlwZXJsaW5rTWFya1JhbmdlXCIpO1xuICAgIHUodGhpcywgXCJoeXBlcmxpbmtNYXJrXCIpO1xuICAgIHUodGhpcywgXCJoeXBlcmxpbmtNYXJrUmFuZ2VcIik7XG4gICAgdSh0aGlzLCBcIm1vdXNlT3ZlckhhbmRsZXJcIiwgKHQpID0+IHtcbiAgICAgIGlmICh0aGlzLm1vdXNlSG92ZXJlZEh5cGVybGlua01hcmsgPSB2b2lkIDAsIHRoaXMubW91c2VIb3ZlcmVkSHlwZXJsaW5rTWFya1JhbmdlID0gdm9pZCAwLCB0aGlzLnN0b3BNZW51VXBkYXRlVGltZXIoKSwgdC50YXJnZXQgaW5zdGFuY2VvZiBIVE1MQW5jaG9yRWxlbWVudCAmJiB0LnRhcmdldC5ub2RlTmFtZSA9PT0gXCJBXCIpIHtcbiAgICAgICAgY29uc3QgZSA9IHQudGFyZ2V0LCBvID0gdGhpcy5wbVZpZXcucG9zQXRET00oZSwgMCkgKyAxLCByID0gdGhpcy5wbVZpZXcuc3RhdGUuZG9jLnJlc29sdmUoXG4gICAgICAgICAgb1xuICAgICAgICApLCBpID0gci5tYXJrcygpO1xuICAgICAgICBmb3IgKGNvbnN0IHMgb2YgaSlcbiAgICAgICAgICBpZiAocy50eXBlLm5hbWUgPT09IHRoaXMucG1WaWV3LnN0YXRlLnNjaGVtYS5tYXJrKFwibGlua1wiKS50eXBlLm5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMubW91c2VIb3ZlcmVkSHlwZXJsaW5rTWFyayA9IHMsIHRoaXMubW91c2VIb3ZlcmVkSHlwZXJsaW5rTWFya1JhbmdlID0gaXQoXG4gICAgICAgICAgICAgIHIsXG4gICAgICAgICAgICAgIHMudHlwZSxcbiAgICAgICAgICAgICAgcy5hdHRyc1xuICAgICAgICAgICAgKSB8fCB2b2lkIDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5zdGFydE1lbnVVcGRhdGVUaW1lcigpLCAhMTtcbiAgICB9KTtcbiAgICB1KHRoaXMsIFwiY2xpY2tIYW5kbGVyXCIsICh0KSA9PiB7XG4gICAgICB2YXIgbztcbiAgICAgIGNvbnN0IGUgPSB0aGlzLnBtVmlldy5kb20ucGFyZW50RWxlbWVudDtcbiAgICAgIC8vIFRvb2xiYXIgaXMgb3Blbi5cbiAgICAgIHRoaXMuaHlwZXJsaW5rTWFyayAmJiAvLyBBbiBlbGVtZW50IGlzIGNsaWNrZWQuXG4gICAgICB0ICYmIHQudGFyZ2V0ICYmIC8vIFRoZSBjbGlja2VkIGVsZW1lbnQgaXMgbm90IHRoZSBlZGl0b3IuXG4gICAgICAhKGUgPT09IHQudGFyZ2V0IHx8IGUuY29udGFpbnModC50YXJnZXQpKSAmJiAobyA9IHRoaXMuaHlwZXJsaW5rVG9vbGJhclN0YXRlKSAhPSBudWxsICYmIG8uc2hvdyAmJiAodGhpcy5oeXBlcmxpbmtUb29sYmFyU3RhdGUuc2hvdyA9ICExLCB0aGlzLnVwZGF0ZUh5cGVybGlua1Rvb2xiYXIoKSk7XG4gICAgfSk7XG4gICAgdSh0aGlzLCBcInNjcm9sbEhhbmRsZXJcIiwgKCkgPT4ge1xuICAgICAgdmFyIHQ7XG4gICAgICB0aGlzLmh5cGVybGlua01hcmsgIT09IHZvaWQgMCAmJiAodCA9IHRoaXMuaHlwZXJsaW5rVG9vbGJhclN0YXRlKSAhPSBudWxsICYmIHQuc2hvdyAmJiAodGhpcy5oeXBlcmxpbmtUb29sYmFyU3RhdGUucmVmZXJlbmNlUG9zID0gWShcbiAgICAgICAgdGhpcy5wbVZpZXcsXG4gICAgICAgIHRoaXMuaHlwZXJsaW5rTWFya1JhbmdlLmZyb20sXG4gICAgICAgIHRoaXMuaHlwZXJsaW5rTWFya1JhbmdlLnRvXG4gICAgICApLCB0aGlzLnVwZGF0ZUh5cGVybGlua1Rvb2xiYXIoKSk7XG4gICAgfSk7XG4gICAgdGhpcy5lZGl0b3IgPSB0LCB0aGlzLnBtVmlldyA9IGUsIHRoaXMudXBkYXRlSHlwZXJsaW5rVG9vbGJhciA9ICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5oeXBlcmxpbmtUb29sYmFyU3RhdGUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0dGVtcHRpbmcgdG8gdXBkYXRlIHVuaW5pdGlhbGl6ZWQgaHlwZXJsaW5rIHRvb2xiYXJcIik7XG4gICAgICBvKHRoaXMuaHlwZXJsaW5rVG9vbGJhclN0YXRlKTtcbiAgICB9LCB0aGlzLnN0YXJ0TWVudVVwZGF0ZVRpbWVyID0gKCkgPT4ge1xuICAgICAgdGhpcy5tZW51VXBkYXRlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgIH0sIDI1MCk7XG4gICAgfSwgdGhpcy5zdG9wTWVudVVwZGF0ZVRpbWVyID0gKCkgPT4gKHRoaXMubWVudVVwZGF0ZVRpbWVyICYmIChjbGVhclRpbWVvdXQodGhpcy5tZW51VXBkYXRlVGltZXIpLCB0aGlzLm1lbnVVcGRhdGVUaW1lciA9IHZvaWQgMCksICExKSwgdGhpcy5wbVZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW92ZXJcIiwgdGhpcy5tb3VzZU92ZXJIYW5kbGVyKSwgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuY2xpY2tIYW5kbGVyLCAhMCksIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5zY3JvbGxIYW5kbGVyKTtcbiAgfVxuICBlZGl0SHlwZXJsaW5rKHQsIGUpIHtcbiAgICB2YXIgcjtcbiAgICBjb25zdCBvID0gdGhpcy5wbVZpZXcuc3RhdGUudHIuaW5zZXJ0VGV4dChcbiAgICAgIGUsXG4gICAgICB0aGlzLmh5cGVybGlua01hcmtSYW5nZS5mcm9tLFxuICAgICAgdGhpcy5oeXBlcmxpbmtNYXJrUmFuZ2UudG9cbiAgICApO1xuICAgIG8uYWRkTWFyayhcbiAgICAgIHRoaXMuaHlwZXJsaW5rTWFya1JhbmdlLmZyb20sXG4gICAgICB0aGlzLmh5cGVybGlua01hcmtSYW5nZS5mcm9tICsgZS5sZW5ndGgsXG4gICAgICB0aGlzLnBtVmlldy5zdGF0ZS5zY2hlbWEubWFyayhcImxpbmtcIiwgeyBocmVmOiB0IH0pXG4gICAgKSwgdGhpcy5wbVZpZXcuZGlzcGF0Y2gobyksIHRoaXMucG1WaWV3LmZvY3VzKCksIChyID0gdGhpcy5oeXBlcmxpbmtUb29sYmFyU3RhdGUpICE9IG51bGwgJiYgci5zaG93ICYmICh0aGlzLmh5cGVybGlua1Rvb2xiYXJTdGF0ZS5zaG93ID0gITEsIHRoaXMudXBkYXRlSHlwZXJsaW5rVG9vbGJhcigpKTtcbiAgfVxuICBkZWxldGVIeXBlcmxpbmsoKSB7XG4gICAgdmFyIHQ7XG4gICAgdGhpcy5wbVZpZXcuZGlzcGF0Y2goXG4gICAgICB0aGlzLnBtVmlldy5zdGF0ZS50ci5yZW1vdmVNYXJrKFxuICAgICAgICB0aGlzLmh5cGVybGlua01hcmtSYW5nZS5mcm9tLFxuICAgICAgICB0aGlzLmh5cGVybGlua01hcmtSYW5nZS50byxcbiAgICAgICAgdGhpcy5oeXBlcmxpbmtNYXJrLnR5cGVcbiAgICAgICkuc2V0TWV0YShcInByZXZlbnRBdXRvbGlua1wiLCAhMClcbiAgICApLCB0aGlzLnBtVmlldy5mb2N1cygpLCAodCA9IHRoaXMuaHlwZXJsaW5rVG9vbGJhclN0YXRlKSAhPSBudWxsICYmIHQuc2hvdyAmJiAodGhpcy5oeXBlcmxpbmtUb29sYmFyU3RhdGUuc2hvdyA9ICExLCB0aGlzLnVwZGF0ZUh5cGVybGlua1Rvb2xiYXIoKSk7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIHZhciBlO1xuICAgIGlmICghdGhpcy5wbVZpZXcuaGFzRm9jdXMoKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gdGhpcy5oeXBlcmxpbmtNYXJrO1xuICAgIGlmICh0aGlzLmh5cGVybGlua01hcmsgPSB2b2lkIDAsIHRoaXMuaHlwZXJsaW5rTWFya1JhbmdlID0gdm9pZCAwLCB0aGlzLmtleWJvYXJkSG92ZXJlZEh5cGVybGlua01hcmsgPSB2b2lkIDAsIHRoaXMua2V5Ym9hcmRIb3ZlcmVkSHlwZXJsaW5rTWFya1JhbmdlID0gdm9pZCAwLCB0aGlzLnBtVmlldy5zdGF0ZS5zZWxlY3Rpb24uZW1wdHkpIHtcbiAgICAgIGNvbnN0IG8gPSB0aGlzLnBtVmlldy5zdGF0ZS5zZWxlY3Rpb24uJGZyb20ubWFya3MoKTtcbiAgICAgIGZvciAoY29uc3QgciBvZiBvKVxuICAgICAgICBpZiAoci50eXBlLm5hbWUgPT09IHRoaXMucG1WaWV3LnN0YXRlLnNjaGVtYS5tYXJrKFwibGlua1wiKS50eXBlLm5hbWUpIHtcbiAgICAgICAgICB0aGlzLmtleWJvYXJkSG92ZXJlZEh5cGVybGlua01hcmsgPSByLCB0aGlzLmtleWJvYXJkSG92ZXJlZEh5cGVybGlua01hcmtSYW5nZSA9IGl0KFxuICAgICAgICAgICAgdGhpcy5wbVZpZXcuc3RhdGUuc2VsZWN0aW9uLiRmcm9tLFxuICAgICAgICAgICAgci50eXBlLFxuICAgICAgICAgICAgci5hdHRyc1xuICAgICAgICAgICkgfHwgdm9pZCAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLm1vdXNlSG92ZXJlZEh5cGVybGlua01hcmsgJiYgKHRoaXMuaHlwZXJsaW5rTWFyayA9IHRoaXMubW91c2VIb3ZlcmVkSHlwZXJsaW5rTWFyaywgdGhpcy5oeXBlcmxpbmtNYXJrUmFuZ2UgPSB0aGlzLm1vdXNlSG92ZXJlZEh5cGVybGlua01hcmtSYW5nZSksIHRoaXMua2V5Ym9hcmRIb3ZlcmVkSHlwZXJsaW5rTWFyayAmJiAodGhpcy5oeXBlcmxpbmtNYXJrID0gdGhpcy5rZXlib2FyZEhvdmVyZWRIeXBlcmxpbmtNYXJrLCB0aGlzLmh5cGVybGlua01hcmtSYW5nZSA9IHRoaXMua2V5Ym9hcmRIb3ZlcmVkSHlwZXJsaW5rTWFya1JhbmdlKSwgdGhpcy5oeXBlcmxpbmtNYXJrICYmIHRoaXMuZWRpdG9yLmlzRWRpdGFibGUpIHtcbiAgICAgIHRoaXMuaHlwZXJsaW5rVG9vbGJhclN0YXRlID0ge1xuICAgICAgICBzaG93OiAhMCxcbiAgICAgICAgcmVmZXJlbmNlUG9zOiBZKFxuICAgICAgICAgIHRoaXMucG1WaWV3LFxuICAgICAgICAgIHRoaXMuaHlwZXJsaW5rTWFya1JhbmdlLmZyb20sXG4gICAgICAgICAgdGhpcy5oeXBlcmxpbmtNYXJrUmFuZ2UudG9cbiAgICAgICAgKSxcbiAgICAgICAgdXJsOiB0aGlzLmh5cGVybGlua01hcmsuYXR0cnMuaHJlZixcbiAgICAgICAgdGV4dDogdGhpcy5wbVZpZXcuc3RhdGUuZG9jLnRleHRCZXR3ZWVuKFxuICAgICAgICAgIHRoaXMuaHlwZXJsaW5rTWFya1JhbmdlLmZyb20sXG4gICAgICAgICAgdGhpcy5oeXBlcmxpbmtNYXJrUmFuZ2UudG9cbiAgICAgICAgKVxuICAgICAgfSwgdGhpcy51cGRhdGVIeXBlcmxpbmtUb29sYmFyKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICgoZSA9IHRoaXMuaHlwZXJsaW5rVG9vbGJhclN0YXRlKSAhPSBudWxsICYmIGUuc2hvdyAmJiB0ICYmICghdGhpcy5oeXBlcmxpbmtNYXJrIHx8ICF0aGlzLmVkaXRvci5pc0VkaXRhYmxlKSkge1xuICAgICAgdGhpcy5oeXBlcmxpbmtUb29sYmFyU3RhdGUuc2hvdyA9ICExLCB0aGlzLnVwZGF0ZUh5cGVybGlua1Rvb2xiYXIoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnBtVmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3ZlclwiLCB0aGlzLm1vdXNlT3ZlckhhbmRsZXIpLCBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMuc2Nyb2xsSGFuZGxlciksIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLmNsaWNrSGFuZGxlciwgITApO1xuICB9XG59XG5jb25zdCBVbyA9IG5ldyBfKFxuICBcIkh5cGVybGlua1Rvb2xiYXJQbHVnaW5cIlxuKTtcbmNsYXNzIEZvIGV4dGVuZHMgJCB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBzdXBlcigpO1xuICAgIHUodGhpcywgXCJ2aWV3XCIpO1xuICAgIHUodGhpcywgXCJwbHVnaW5cIik7XG4gICAgLyoqXG4gICAgICogRWRpdCB0aGUgY3VycmVudGx5IGhvdmVyZWQgaHlwZXJsaW5rLlxuICAgICAqL1xuICAgIHUodGhpcywgXCJlZGl0SHlwZXJsaW5rXCIsIChlLCBvKSA9PiB7XG4gICAgICB0aGlzLnZpZXcuZWRpdEh5cGVybGluayhlLCBvKTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBEZWxldGUgdGhlIGN1cnJlbnRseSBob3ZlcmVkIGh5cGVybGluay5cbiAgICAgKi9cbiAgICB1KHRoaXMsIFwiZGVsZXRlSHlwZXJsaW5rXCIsICgpID0+IHtcbiAgICAgIHRoaXMudmlldy5kZWxldGVIeXBlcmxpbmsoKTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBXaGVuIGhvdmVyaW5nIG9uL29mZiBoeXBlcmxpbmtzIHVzaW5nIHRoZSBtb3VzZSBjdXJzb3IsIHRoZSBoeXBlcmxpbmtcbiAgICAgKiB0b29sYmFyIHdpbGwgb3BlbiAmIGNsb3NlIHdpdGggYSBkZWxheS5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc3RhcnRzIHRoZSBkZWxheSB0aW1lciwgYW5kIHNob3VsZCBiZSB1c2VkIGZvciB3aGVuIHRoZSBtb3VzZSBjdXJzb3IgZW50ZXJzIHRoZSBoeXBlcmxpbmsgdG9vbGJhci5cbiAgICAgKi9cbiAgICB1KHRoaXMsIFwic3RhcnRIaWRlVGltZXJcIiwgKCkgPT4ge1xuICAgICAgdGhpcy52aWV3LnN0YXJ0TWVudVVwZGF0ZVRpbWVyKCk7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogV2hlbiBob3ZlcmluZyBvbi9vZmYgaHlwZXJsaW5rcyB1c2luZyB0aGUgbW91c2UgY3Vyc29yLCB0aGUgaHlwZXJsaW5rXG4gICAgICogdG9vbGJhciB3aWxsIG9wZW4gJiBjbG9zZSB3aXRoIGEgZGVsYXkuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHN0b3BzIHRoZSBkZWxheSB0aW1lciwgYW5kIHNob3VsZCBiZSB1c2VkIGZvciB3aGVuIHRoZSBtb3VzZSBjdXJzb3IgZXhpdHMgdGhlIGh5cGVybGluayB0b29sYmFyLlxuICAgICAqL1xuICAgIHUodGhpcywgXCJzdG9wSGlkZVRpbWVyXCIsICgpID0+IHtcbiAgICAgIHRoaXMudmlldy5zdG9wTWVudVVwZGF0ZVRpbWVyKCk7XG4gICAgfSk7XG4gICAgdGhpcy5wbHVnaW4gPSBuZXcgSSh7XG4gICAgICBrZXk6IFVvLFxuICAgICAgdmlldzogKG8pID0+ICh0aGlzLnZpZXcgPSBuZXcgVm8oZSwgbywgKHIpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KFwidXBkYXRlXCIsIHIpO1xuICAgICAgfSksIHRoaXMudmlldylcbiAgICB9KTtcbiAgfVxuICBvblVwZGF0ZShlKSB7XG4gICAgcmV0dXJuIHRoaXMub24oXCJ1cGRhdGVcIiwgZSk7XG4gIH1cbn1cbmNsYXNzIHogZXh0ZW5kcyBLIHtcbiAgY29uc3RydWN0b3IoZSwgbykge1xuICAgIHN1cGVyKGUsIG8pO1xuICAgIHUodGhpcywgXCJub2Rlc1wiKTtcbiAgICBjb25zdCByID0gZS5ub2RlKCk7XG4gICAgdGhpcy5ub2RlcyA9IFtdLCBlLmRvYy5ub2Rlc0JldHdlZW4oZS5wb3MsIG8ucG9zLCAoaSwgcywgbCkgPT4ge1xuICAgICAgaWYgKGwgIT09IG51bGwgJiYgbC5lcShyKSlcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXMucHVzaChpKSwgITE7XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZShlLCBvLCByID0gbykge1xuICAgIHJldHVybiBuZXcgeihlLnJlc29sdmUobyksIGUucmVzb2x2ZShyKSk7XG4gIH1cbiAgY29udGVudCgpIHtcbiAgICByZXR1cm4gbmV3IFAoTy5mcm9tKHRoaXMubm9kZXMpLCAwLCAwKTtcbiAgfVxuICBlcShlKSB7XG4gICAgaWYgKCEoZSBpbnN0YW5jZW9mIHopIHx8IHRoaXMubm9kZXMubGVuZ3RoICE9PSBlLm5vZGVzLmxlbmd0aCB8fCB0aGlzLmZyb20gIT09IGUuZnJvbSB8fCB0aGlzLnRvICE9PSBlLnRvKVxuICAgICAgcmV0dXJuICExO1xuICAgIGZvciAobGV0IG8gPSAwOyBvIDwgdGhpcy5ub2Rlcy5sZW5ndGg7IG8rKylcbiAgICAgIGlmICghdGhpcy5ub2Rlc1tvXS5lcShlLm5vZGVzW29dKSlcbiAgICAgICAgcmV0dXJuICExO1xuICAgIHJldHVybiAhMDtcbiAgfVxuICBtYXAoZSwgbykge1xuICAgIGNvbnN0IHIgPSBvLm1hcFJlc3VsdCh0aGlzLmZyb20pLCBpID0gby5tYXBSZXN1bHQodGhpcy50byk7XG4gICAgcmV0dXJuIGkuZGVsZXRlZCA/IEsubmVhcihlLnJlc29sdmUoci5wb3MpKSA6IHIuZGVsZXRlZCA/IEsubmVhcihlLnJlc29sdmUoaS5wb3MpKSA6IG5ldyB6KFxuICAgICAgZS5yZXNvbHZlKHIucG9zKSxcbiAgICAgIGUucmVzb2x2ZShpLnBvcylcbiAgICApO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4geyB0eXBlOiBcIm5vZGVcIiwgYW5jaG9yOiB0aGlzLmFuY2hvciwgaGVhZDogdGhpcy5oZWFkIH07XG4gIH1cbn1cbmNvbnN0ICRvID0gd2UuX19zZXJpYWxpemVGb3JDbGlwYm9hcmQ7XG5sZXQgSDtcbmZ1bmN0aW9uIFh0KG4sIHQpIHtcbiAgdmFyIHI7XG4gIGlmICghdC5kb20uaXNDb25uZWN0ZWQpXG4gICAgcmV0dXJuO1xuICBjb25zdCBlID0gdC5wb3NBdENvb3JkcyhuKTtcbiAgaWYgKCFlKVxuICAgIHJldHVybjtcbiAgbGV0IG8gPSB0LmRvbUF0UG9zKGUucG9zKS5ub2RlO1xuICBpZiAobyAhPT0gdC5kb20pIHtcbiAgICBmb3IgKDsgbyAmJiBvLnBhcmVudE5vZGUgJiYgby5wYXJlbnROb2RlICE9PSB0LmRvbSAmJiAhKChyID0gby5oYXNBdHRyaWJ1dGUpICE9IG51bGwgJiYgci5jYWxsKG8sIFwiZGF0YS1pZFwiKSk7IClcbiAgICAgIG8gPSBvLnBhcmVudE5vZGU7XG4gICAgaWYgKG8pXG4gICAgICByZXR1cm4geyBub2RlOiBvLCBpZDogby5nZXRBdHRyaWJ1dGUoXCJkYXRhLWlkXCIpIH07XG4gIH1cbn1cbmZ1bmN0aW9uIFdvKG4sIHQpIHtcbiAgY29uc3QgZSA9IFh0KG4sIHQpO1xuICBpZiAoZSAmJiBlLm5vZGUubm9kZVR5cGUgPT09IDEpIHtcbiAgICBjb25zdCBvID0gdC5kb2NWaWV3LCByID0gby5uZWFyZXN0RGVzYyhlLm5vZGUsICEwKTtcbiAgICByZXR1cm4gIXIgfHwgciA9PT0gbyA/IG51bGwgOiByLnBvc0JlZm9yZTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIEdvKG4sIHQpIHtcbiAgbGV0IGUsIG87XG4gIGNvbnN0IHIgPSB0LnJlc29sdmUobi5mcm9tKS5ub2RlKCkudHlwZS5zcGVjLmdyb3VwID09PSBcImJsb2NrQ29udGVudFwiLCBpID0gdC5yZXNvbHZlKG4udG8pLm5vZGUoKS50eXBlLnNwZWMuZ3JvdXAgPT09IFwiYmxvY2tDb250ZW50XCIsIHMgPSBNYXRoLm1pbihuLiRhbmNob3IuZGVwdGgsIG4uJGhlYWQuZGVwdGgpO1xuICBpZiAociAmJiBpKSB7XG4gICAgY29uc3QgbCA9IG4uJGZyb20uc3RhcnQocyAtIDEpLCBhID0gbi4kdG8uZW5kKHMgLSAxKTtcbiAgICBlID0gdC5yZXNvbHZlKGwgLSAxKS5wb3MsIG8gPSB0LnJlc29sdmUoYSArIDEpLnBvcztcbiAgfSBlbHNlXG4gICAgZSA9IG4uZnJvbSwgbyA9IG4udG87XG4gIHJldHVybiB7IGZyb206IGUsIHRvOiBvIH07XG59XG5mdW5jdGlvbiBodChuLCB0LCBlID0gdCkge1xuICB0ID09PSBlICYmIChlICs9IG4uc3RhdGUuZG9jLnJlc29sdmUodCArIDEpLm5vZGUoKS5ub2RlU2l6ZSk7XG4gIGNvbnN0IG8gPSBuLmRvbUF0UG9zKHQpLm5vZGUuY2xvbmVOb2RlKCEwKSwgciA9IG4uZG9tQXRQb3ModCkubm9kZSwgaSA9IChjLCBoKSA9PiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGMuY2hpbGRyZW4sIGgpLCBzID0gaShcbiAgICByLFxuICAgIC8vIEV4cGVjdHMgZnJvbSBwb3NpdGlvbiB0byBiZSBqdXN0IGJlZm9yZSB0aGUgZmlyc3Qgc2VsZWN0ZWQgYmxvY2suXG4gICAgbi5kb21BdFBvcyh0ICsgMSkubm9kZS5wYXJlbnRFbGVtZW50XG4gICksIGwgPSBpKFxuICAgIHIsXG4gICAgLy8gRXhwZWN0cyB0byBwb3NpdGlvbiB0byBiZSBqdXN0IGFmdGVyIHRoZSBsYXN0IHNlbGVjdGVkIGJsb2NrLlxuICAgIG4uZG9tQXRQb3MoZSAtIDEpLm5vZGUucGFyZW50RWxlbWVudFxuICApO1xuICBmb3IgKGxldCBjID0gci5jaGlsZEVsZW1lbnRDb3VudCAtIDE7IGMgPj0gMDsgYy0tKVxuICAgIChjID4gbCB8fCBjIDwgcykgJiYgby5yZW1vdmVDaGlsZChvLmNoaWxkcmVuW2NdKTtcbiAgS3QoKSwgSCA9IG87XG4gIGNvbnN0IGQgPSBuLmRvbS5jbGFzc05hbWUuc3BsaXQoXCIgXCIpLmZpbHRlcihcbiAgICAoYykgPT4gIWMuaW5jbHVkZXMoXCJiblwiKSAmJiAhYy5pbmNsdWRlcyhcIlByb3NlTWlycm9yXCIpICYmICFjLmluY2x1ZGVzKFwiZWRpdG9yXCIpXG4gICkuam9pbihcIiBcIik7XG4gIEguY2xhc3NOYW1lID0gSC5jbGFzc05hbWUgKyBcIiBcIiArIFIuZHJhZ1ByZXZpZXcgKyBcIiBcIiArIGQsIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoSCk7XG59XG5mdW5jdGlvbiBLdCgpIHtcbiAgSCAhPT0gdm9pZCAwICYmIChkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKEgpLCBIID0gdm9pZCAwKTtcbn1cbmZ1bmN0aW9uIGpvKG4sIHQpIHtcbiAgaWYgKCFuLmRhdGFUcmFuc2ZlcilcbiAgICByZXR1cm47XG4gIGNvbnN0IGUgPSB0LmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgbyA9IHtcbiAgICBsZWZ0OiBlLmxlZnQgKyBlLndpZHRoIC8gMixcbiAgICAvLyB0YWtlIG1pZGRsZSBvZiBlZGl0b3JcbiAgICB0b3A6IG4uY2xpZW50WVxuICB9LCByID0gV28obywgdCk7XG4gIGlmIChyICE9IG51bGwpIHtcbiAgICBjb25zdCBpID0gdC5zdGF0ZS5zZWxlY3Rpb24sIHMgPSB0LnN0YXRlLmRvYywgeyBmcm9tOiBsLCB0bzogYSB9ID0gR28oaSwgcyksIGQgPSBsIDw9IHIgJiYgciA8IGEsIGMgPSBpLiRhbmNob3Iubm9kZSgpICE9PSBpLiRoZWFkLm5vZGUoKSB8fCBpIGluc3RhbmNlb2YgejtcbiAgICBkICYmIGMgPyAodC5kaXNwYXRjaChcbiAgICAgIHQuc3RhdGUudHIuc2V0U2VsZWN0aW9uKHouY3JlYXRlKHMsIGwsIGEpKVxuICAgICksIGh0KHQsIGwsIGEpKSA6ICh0LmRpc3BhdGNoKFxuICAgICAgdC5zdGF0ZS50ci5zZXRTZWxlY3Rpb24oZnQuY3JlYXRlKHQuc3RhdGUuZG9jLCByKSlcbiAgICApLCBodCh0LCByKSk7XG4gICAgY29uc3QgaCA9IHQuc3RhdGUuc2VsZWN0aW9uLmNvbnRlbnQoKSwgeyBkb206IG0sIHRleHQ6IHAgfSA9ICRvKHQsIGgpO1xuICAgIG4uZGF0YVRyYW5zZmVyLmNsZWFyRGF0YSgpLCBuLmRhdGFUcmFuc2Zlci5zZXREYXRhKFwidGV4dC9odG1sXCIsIG0uaW5uZXJIVE1MKSwgbi5kYXRhVHJhbnNmZXIuc2V0RGF0YShcInRleHQvcGxhaW5cIiwgcCksIG4uZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQgPSBcIm1vdmVcIiwgbi5kYXRhVHJhbnNmZXIuc2V0RHJhZ0ltYWdlKEgsIDAsIDApLCB0LmRyYWdnaW5nID0geyBzbGljZTogaCwgbW92ZTogITAgfTtcbiAgfVxufVxuY2xhc3MgcW8ge1xuICBjb25zdHJ1Y3Rvcih0LCBlLCBvKSB7XG4gICAgdSh0aGlzLCBcInNpZGVNZW51U3RhdGVcIik7XG4gICAgLy8gV2hlbiB0cnVlLCB0aGUgZHJhZyBoYW5kbGUgd2l0aCBiZSBhbmNob3JlZCBhdCB0aGUgc2FtZSBsZXZlbCBhcyByb290IGVsZW1lbnRzXG4gICAgLy8gV2hlbiBmYWxzZSwgdGhlIGRyYWcgaGFuZGxlIHdpdGggYmUganVzdCB0byB0aGUgbGVmdCBvZiB0aGUgZWxlbWVudFxuICAgIC8vIFRPRE86IElzIHRoZXJlIGFueSBjYXNlIHdoZXJlIHdlIHdhbnQgdGhpcyB0byBiZSBmYWxzZT9cbiAgICB1KHRoaXMsIFwiaG9yaXpvbnRhbFBvc0FuY2hvcmVkQXRSb290XCIpO1xuICAgIHUodGhpcywgXCJob3Jpem9udGFsUG9zQW5jaG9yXCIpO1xuICAgIHUodGhpcywgXCJob3ZlcmVkQmxvY2tcIik7XG4gICAgLy8gVXNlZCB0byBjaGVjayBpZiBjdXJyZW50bHkgZHJhZ2dlZCBjb250ZW50IGNvbWVzIGZyb20gdGhpcyBlZGl0b3IgaW5zdGFuY2UuXG4gICAgdSh0aGlzLCBcImlzRHJhZ2dpbmdcIiwgITEpO1xuICAgIHUodGhpcywgXCJtZW51RnJvemVuXCIsICExKTtcbiAgICAvKipcbiAgICAgKiBTZXRzIGlzRHJhZ2dpbmcgd2hlbiBkcmFnZ2luZyB0ZXh0LlxuICAgICAqL1xuICAgIHUodGhpcywgXCJvbkRyYWdTdGFydFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLmlzRHJhZ2dpbmcgPSAhMDtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgZXZlbnQgaXMgb3V0c2lkZSB0aGUgZWRpdG9yIGNvbnRlbnRzLFxuICAgICAqIHdlIGRpc3BhdGNoIGEgZmFrZSBldmVudCwgc28gdGhhdCB3ZSBjYW4gc3RpbGwgZHJvcCB0aGUgY29udGVudFxuICAgICAqIHdoZW4gZHJhZ2dpbmcgLyBkcm9wcGluZyB0byB0aGUgc2lkZSBvZiB0aGUgZWRpdG9yXG4gICAgICovXG4gICAgdSh0aGlzLCBcIm9uRHJvcFwiLCAodCkgPT4ge1xuICAgICAgaWYgKHRoaXMuZWRpdG9yLl90aXB0YXBFZGl0b3IuY29tbWFuZHMuYmx1cigpLCB0LnN5bnRoZXRpYyB8fCAhdGhpcy5pc0RyYWdnaW5nKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBlID0gdGhpcy5wbVZpZXcucG9zQXRDb29yZHMoe1xuICAgICAgICBsZWZ0OiB0LmNsaWVudFgsXG4gICAgICAgIHRvcDogdC5jbGllbnRZXG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcgPSAhMSwgIWUgfHwgZS5pbnNpZGUgPT09IC0xKSB7XG4gICAgICAgIGNvbnN0IG8gPSBuZXcgRXZlbnQoXCJkcm9wXCIsIHQpLCByID0gdGhpcy5wbVZpZXcuZG9tLmZpcnN0Q2hpbGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIG8uY2xpZW50WCA9IHIubGVmdCArIHIud2lkdGggLyAyLCBvLmNsaWVudFkgPSB0LmNsaWVudFksIG8uZGF0YVRyYW5zZmVyID0gdC5kYXRhVHJhbnNmZXIsIG8ucHJldmVudERlZmF1bHQgPSAoKSA9PiB0LnByZXZlbnREZWZhdWx0KCksIG8uc3ludGhldGljID0gITAsIHRoaXMucG1WaWV3LmRvbS5kaXNwYXRjaEV2ZW50KG8pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIElmIHRoZSBldmVudCBpcyBvdXRzaWRlIHRoZSBlZGl0b3IgY29udGVudHMsXG4gICAgICogd2UgZGlzcGF0Y2ggYSBmYWtlIGV2ZW50LCBzbyB0aGF0IHdlIGNhbiBzdGlsbCBkcm9wIHRoZSBjb250ZW50XG4gICAgICogd2hlbiBkcmFnZ2luZyAvIGRyb3BwaW5nIHRvIHRoZSBzaWRlIG9mIHRoZSBlZGl0b3JcbiAgICAgKi9cbiAgICB1KHRoaXMsIFwib25EcmFnT3ZlclwiLCAodCkgPT4ge1xuICAgICAgaWYgKHQuc3ludGhldGljIHx8ICF0aGlzLmlzRHJhZ2dpbmcpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IGUgPSB0aGlzLnBtVmlldy5wb3NBdENvb3Jkcyh7XG4gICAgICAgIGxlZnQ6IHQuY2xpZW50WCxcbiAgICAgICAgdG9wOiB0LmNsaWVudFlcbiAgICAgIH0pO1xuICAgICAgaWYgKCFlIHx8IGUuaW5zaWRlID09PSAtMSkge1xuICAgICAgICBjb25zdCBvID0gbmV3IEV2ZW50KFwiZHJhZ292ZXJcIiwgdCksIHIgPSB0aGlzLnBtVmlldy5kb20uZmlyc3RDaGlsZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgby5jbGllbnRYID0gci5sZWZ0ICsgci53aWR0aCAvIDIsIG8uY2xpZW50WSA9IHQuY2xpZW50WSwgby5kYXRhVHJhbnNmZXIgPSB0LmRhdGFUcmFuc2Zlciwgby5wcmV2ZW50RGVmYXVsdCA9ICgpID0+IHQucHJldmVudERlZmF1bHQoKSwgby5zeW50aGV0aWMgPSAhMCwgdGhpcy5wbVZpZXcuZG9tLmRpc3BhdGNoRXZlbnQobyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdSh0aGlzLCBcIm9uS2V5RG93blwiLCAodCkgPT4ge1xuICAgICAgdmFyIGU7XG4gICAgICAoZSA9IHRoaXMuc2lkZU1lbnVTdGF0ZSkgIT0gbnVsbCAmJiBlLnNob3cgJiYgKHRoaXMuc2lkZU1lbnVTdGF0ZS5zaG93ID0gITEsIHRoaXMudXBkYXRlU2lkZU1lbnUodGhpcy5zaWRlTWVudVN0YXRlKSksIHRoaXMubWVudUZyb3plbiA9ICExO1xuICAgIH0pO1xuICAgIHUodGhpcywgXCJvbk1vdXNlRG93blwiLCAodCkgPT4ge1xuICAgICAgdGhpcy5zaWRlTWVudVN0YXRlICYmICF0aGlzLnNpZGVNZW51U3RhdGUuc2hvdyAmJiAodGhpcy5zaWRlTWVudVN0YXRlLnNob3cgPSAhMCwgdGhpcy51cGRhdGVTaWRlTWVudSh0aGlzLnNpZGVNZW51U3RhdGUpKSwgdGhpcy5tZW51RnJvemVuID0gITE7XG4gICAgfSk7XG4gICAgdSh0aGlzLCBcIm9uTW91c2VNb3ZlXCIsICh0KSA9PiB7XG4gICAgICB2YXIgZCwgYywgaCwgbSwgcDtcbiAgICAgIGlmICh0aGlzLm1lbnVGcm96ZW4pXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IGUgPSB0aGlzLnBtVmlldy5kb20uZmlyc3RDaGlsZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgbyA9IHRoaXMucG1WaWV3LmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgciA9IHQuY2xpZW50WCA+PSBvLmxlZnQgJiYgdC5jbGllbnRYIDw9IG8ucmlnaHQgJiYgdC5jbGllbnRZID49IG8udG9wICYmIHQuY2xpZW50WSA8PSBvLmJvdHRvbSwgaSA9IHRoaXMucG1WaWV3LmRvbS5wYXJlbnRFbGVtZW50O1xuICAgICAgaWYgKFxuICAgICAgICAvLyBDdXJzb3IgaXMgd2l0aGluIHRoZSBlZGl0b3IgYXJlYVxuICAgICAgICByICYmIC8vIEFuIGVsZW1lbnQgaXMgaG92ZXJlZFxuICAgICAgICB0ICYmIHQudGFyZ2V0ICYmIC8vIEVsZW1lbnQgaXMgb3V0c2lkZSB0aGUgZWRpdG9yXG4gICAgICAgICEoaSA9PT0gdC50YXJnZXQgfHwgaS5jb250YWlucyh0LnRhcmdldCkpXG4gICAgICApIHtcbiAgICAgICAgKGQgPSB0aGlzLnNpZGVNZW51U3RhdGUpICE9IG51bGwgJiYgZC5zaG93ICYmICh0aGlzLnNpZGVNZW51U3RhdGUuc2hvdyA9ICExLCB0aGlzLnVwZGF0ZVNpZGVNZW51KHRoaXMuc2lkZU1lbnVTdGF0ZSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmhvcml6b250YWxQb3NBbmNob3IgPSBlLng7XG4gICAgICBjb25zdCBzID0ge1xuICAgICAgICBsZWZ0OiBlLmxlZnQgKyBlLndpZHRoIC8gMixcbiAgICAgICAgLy8gdGFrZSBtaWRkbGUgb2YgZWRpdG9yXG4gICAgICAgIHRvcDogdC5jbGllbnRZXG4gICAgICB9LCBsID0gWHQocywgdGhpcy5wbVZpZXcpO1xuICAgICAgaWYgKCFsIHx8ICF0aGlzLmVkaXRvci5pc0VkaXRhYmxlKSB7XG4gICAgICAgIChjID0gdGhpcy5zaWRlTWVudVN0YXRlKSAhPSBudWxsICYmIGMuc2hvdyAmJiAodGhpcy5zaWRlTWVudVN0YXRlLnNob3cgPSAhMSwgdGhpcy51cGRhdGVTaWRlTWVudSh0aGlzLnNpZGVNZW51U3RhdGUpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKChoID0gdGhpcy5zaWRlTWVudVN0YXRlKSAhPSBudWxsICYmIGguc2hvdyAmJiAoKG0gPSB0aGlzLmhvdmVyZWRCbG9jaykgIT0gbnVsbCAmJiBtLmhhc0F0dHJpYnV0ZShcImRhdGEtaWRcIikpICYmICgocCA9IHRoaXMuaG92ZXJlZEJsb2NrKSA9PSBudWxsID8gdm9pZCAwIDogcC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWlkXCIpKSA9PT0gbC5pZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5ob3ZlcmVkQmxvY2sgPSBsLm5vZGU7XG4gICAgICBjb25zdCBhID0gbC5ub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICBpZiAoYSAmJiB0aGlzLmVkaXRvci5pc0VkaXRhYmxlKSB7XG4gICAgICAgIGNvbnN0IGYgPSBhLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0aGlzLnNpZGVNZW51U3RhdGUgPSB7XG4gICAgICAgICAgc2hvdzogITAsXG4gICAgICAgICAgcmVmZXJlbmNlUG9zOiBuZXcgRE9NUmVjdChcbiAgICAgICAgICAgIHRoaXMuaG9yaXpvbnRhbFBvc0FuY2hvcmVkQXRSb290ID8gdGhpcy5ob3Jpem9udGFsUG9zQW5jaG9yIDogZi54LFxuICAgICAgICAgICAgZi55LFxuICAgICAgICAgICAgZi53aWR0aCxcbiAgICAgICAgICAgIGYuaGVpZ2h0XG4gICAgICAgICAgKSxcbiAgICAgICAgICBibG9jazogdGhpcy5lZGl0b3IuZ2V0QmxvY2soXG4gICAgICAgICAgICB0aGlzLmhvdmVyZWRCbG9jay5nZXRBdHRyaWJ1dGUoXCJkYXRhLWlkXCIpXG4gICAgICAgICAgKVxuICAgICAgICB9LCB0aGlzLnVwZGF0ZVNpZGVNZW51KHRoaXMuc2lkZU1lbnVTdGF0ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdSh0aGlzLCBcIm9uU2Nyb2xsXCIsICgpID0+IHtcbiAgICAgIHZhciB0O1xuICAgICAgaWYgKCh0ID0gdGhpcy5zaWRlTWVudVN0YXRlKSAhPSBudWxsICYmIHQuc2hvdykge1xuICAgICAgICBjb25zdCBvID0gdGhpcy5ob3ZlcmVkQmxvY2suZmlyc3RDaGlsZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdGhpcy5zaWRlTWVudVN0YXRlLnJlZmVyZW5jZVBvcyA9IG5ldyBET01SZWN0KFxuICAgICAgICAgIHRoaXMuaG9yaXpvbnRhbFBvc0FuY2hvcmVkQXRSb290ID8gdGhpcy5ob3Jpem9udGFsUG9zQW5jaG9yIDogby54LFxuICAgICAgICAgIG8ueSxcbiAgICAgICAgICBvLndpZHRoLFxuICAgICAgICAgIG8uaGVpZ2h0XG4gICAgICAgICksIHRoaXMudXBkYXRlU2lkZU1lbnUodGhpcy5zaWRlTWVudVN0YXRlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmVkaXRvciA9IHQsIHRoaXMucG1WaWV3ID0gZSwgdGhpcy51cGRhdGVTaWRlTWVudSA9IG8sIHRoaXMuaG9yaXpvbnRhbFBvc0FuY2hvcmVkQXRSb290ID0gITAsIHRoaXMuaG9yaXpvbnRhbFBvc0FuY2hvciA9IHRoaXMucG1WaWV3LmRvbS5maXJzdENoaWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLngsIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcImRyb3BcIiwgdGhpcy5vbkRyb3AsICEwKSwgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ292ZXJcIiwgdGhpcy5vbkRyYWdPdmVyKSwgdGhpcy5wbVZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnc3RhcnRcIiwgdGhpcy5vbkRyYWdTdGFydCksIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm9uTW91c2VNb3ZlLCAhMCksIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5vblNjcm9sbCksIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLm9uTW91c2VEb3duLCAhMCksIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5vbktleURvd24sICEwKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHZhciB0O1xuICAgICh0ID0gdGhpcy5zaWRlTWVudVN0YXRlKSAhPSBudWxsICYmIHQuc2hvdyAmJiAodGhpcy5zaWRlTWVudVN0YXRlLnNob3cgPSAhMSwgdGhpcy51cGRhdGVTaWRlTWVudSh0aGlzLnNpZGVNZW51U3RhdGUpKSwgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMub25Nb3VzZU1vdmUpLCBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkcmFnb3ZlclwiLCB0aGlzLm9uRHJhZ092ZXIpLCB0aGlzLnBtVmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImRyYWdzdGFydFwiLCB0aGlzLm9uRHJhZ1N0YXJ0KSwgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKFwiZHJvcFwiLCB0aGlzLm9uRHJvcCwgITApLCBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMub25TY3JvbGwpLCBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5vbk1vdXNlRG93biwgITApLCBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMub25LZXlEb3duLCAhMCk7XG4gIH1cbiAgYWRkQmxvY2soKSB7XG4gICAgdmFyIGw7XG4gICAgKGwgPSB0aGlzLnNpZGVNZW51U3RhdGUpICE9IG51bGwgJiYgbC5zaG93ICYmICh0aGlzLnNpZGVNZW51U3RhdGUuc2hvdyA9ICExLCB0aGlzLnVwZGF0ZVNpZGVNZW51KHRoaXMuc2lkZU1lbnVTdGF0ZSkpLCB0aGlzLm1lbnVGcm96ZW4gPSAhMDtcbiAgICBjb25zdCBlID0gdGhpcy5ob3ZlcmVkQmxvY2suZmlyc3RDaGlsZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgbyA9IHRoaXMucG1WaWV3LnBvc0F0Q29vcmRzKHtcbiAgICAgIGxlZnQ6IGUubGVmdCArIGUud2lkdGggLyAyLFxuICAgICAgdG9wOiBlLnRvcCArIGUuaGVpZ2h0IC8gMlxuICAgIH0pO1xuICAgIGlmICghbylcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCByID0gdihcbiAgICAgIHRoaXMuZWRpdG9yLl90aXB0YXBFZGl0b3Iuc3RhdGUuZG9jLFxuICAgICAgby5wb3NcbiAgICApO1xuICAgIGlmIChyID09PSB2b2lkIDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBjb250ZW50Tm9kZTogaSwgZW5kUG9zOiBzIH0gPSByO1xuICAgIGlmIChpLnRleHRDb250ZW50Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgY29uc3QgYSA9IHMgKyAxLCBkID0gYSArIDI7XG4gICAgICB0aGlzLmVkaXRvci5fdGlwdGFwRWRpdG9yLmNoYWluKCkuQk5DcmVhdGVCbG9jayhhKS5CTlVwZGF0ZUJsb2NrKGQsIHsgdHlwZTogXCJwYXJhZ3JhcGhcIiwgcHJvcHM6IHt9IH0pLnNldFRleHRTZWxlY3Rpb24oZCkucnVuKCk7XG4gICAgfSBlbHNlXG4gICAgICB0aGlzLmVkaXRvci5fdGlwdGFwRWRpdG9yLmNvbW1hbmRzLnNldFRleHRTZWxlY3Rpb24ocyk7XG4gICAgdGhpcy5wbVZpZXcuZm9jdXMoKSwgdGhpcy5wbVZpZXcuZGlzcGF0Y2goXG4gICAgICB0aGlzLnBtVmlldy5zdGF0ZS50ci5zY3JvbGxJbnRvVmlldygpLnNldE1ldGEoZXQsIHtcbiAgICAgICAgLy8gVE9ETyBpbXBvcnQgc3VnZ2VzdGlvbiBwbHVnaW4ga2V5XG4gICAgICAgIGFjdGl2YXRlOiAhMCxcbiAgICAgICAgdHlwZTogXCJkcmFnXCJcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuY29uc3QgWG8gPSBuZXcgXyhcIlNpZGVNZW51UGx1Z2luXCIpO1xuY2xhc3MgS28gZXh0ZW5kcyAkIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdSh0aGlzLCBcInNpZGVNZW51Vmlld1wiKTtcbiAgICB1KHRoaXMsIFwicGx1Z2luXCIpO1xuICAgIC8qKlxuICAgICAqIElmIHRoZSBibG9jayBpcyBlbXB0eSwgb3BlbnMgdGhlIHNsYXNoIG1lbnUuIElmIHRoZSBibG9jayBoYXMgY29udGVudCxcbiAgICAgKiBjcmVhdGVzIGEgbmV3IGJsb2NrIGJlbG93IGFuZCBvcGVucyB0aGUgc2xhc2ggbWVudSBpbiBpdC5cbiAgICAgKi9cbiAgICB1KHRoaXMsIFwiYWRkQmxvY2tcIiwgKCkgPT4gdGhpcy5zaWRlTWVudVZpZXcuYWRkQmxvY2soKSk7XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBkcmFnICYgZHJvcCBldmVudHMgZm9yIGJsb2Nrcy5cbiAgICAgKi9cbiAgICB1KHRoaXMsIFwiYmxvY2tEcmFnU3RhcnRcIiwgKGUpID0+IHtcbiAgICAgIHRoaXMuc2lkZU1lbnVWaWV3LmlzRHJhZ2dpbmcgPSAhMCwgam8oZSwgdGhpcy5lZGl0b3IucHJvc2VtaXJyb3JWaWV3KTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGRyYWcgJiBkcm9wIGV2ZW50cyBmb3IgYmxvY2tzLlxuICAgICAqL1xuICAgIHUodGhpcywgXCJibG9ja0RyYWdFbmRcIiwgKCkgPT4gS3QoKSk7XG4gICAgLyoqXG4gICAgICogRnJlZXplcyB0aGUgc2lkZSBtZW51LiBXaGVuIGZyb3plbiwgdGhlIHNpZGUgbWVudSB3aWxsIHN0YXlcbiAgICAgKiBhdHRhY2hlZCB0byB0aGUgc2FtZSBibG9jayByZWdhcmRsZXNzIG9mIHdoaWNoIGJsb2NrIGlzIGhvdmVyZWQgYnkgdGhlXG4gICAgICogbW91c2UgY3Vyc29yLlxuICAgICAqL1xuICAgIHUodGhpcywgXCJmcmVlemVNZW51XCIsICgpID0+IHRoaXMuc2lkZU1lbnVWaWV3Lm1lbnVGcm96ZW4gPSAhMCk7XG4gICAgLyoqXG4gICAgICogVW5mcmVlemVzIHRoZSBzaWRlIG1lbnUuIFdoZW4gZnJvemVuLCB0aGUgc2lkZSBtZW51IHdpbGwgc3RheVxuICAgICAqIGF0dGFjaGVkIHRvIHRoZSBzYW1lIGJsb2NrIHJlZ2FyZGxlc3Mgb2Ygd2hpY2ggYmxvY2sgaXMgaG92ZXJlZCBieSB0aGVcbiAgICAgKiBtb3VzZSBjdXJzb3IuXG4gICAgICovXG4gICAgdSh0aGlzLCBcInVuZnJlZXplTWVudVwiLCAoKSA9PiB0aGlzLnNpZGVNZW51Vmlldy5tZW51RnJvemVuID0gITEpO1xuICAgIHRoaXMuZWRpdG9yID0gZSwgdGhpcy5wbHVnaW4gPSBuZXcgSSh7XG4gICAgICBrZXk6IFhvLFxuICAgICAgdmlldzogKG8pID0+ICh0aGlzLnNpZGVNZW51VmlldyA9IG5ldyBxbyhcbiAgICAgICAgZSxcbiAgICAgICAgbyxcbiAgICAgICAgKHIpID0+IHtcbiAgICAgICAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIiwgcik7XG4gICAgICAgIH1cbiAgICAgICksIHRoaXMuc2lkZU1lbnVWaWV3KVxuICAgIH0pO1xuICB9XG4gIG9uVXBkYXRlKGUpIHtcbiAgICByZXR1cm4gdGhpcy5vbihcInVwZGF0ZVwiLCBlKTtcbiAgfVxufVxuZnVuY3Rpb24gTihuLCB0KSB7XG4gIGNvbnN0IGUgPSBuLmdldFRleHRDdXJzb3JQb3NpdGlvbigpLmJsb2NrO1xuICBpZiAoZS5jb250ZW50ID09PSB2b2lkIDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJTbGFzaCBNZW51IG9wZW4gaW4gYSBibG9jayB0aGF0IGRvZXNuJ3QgY29udGFpbiBpbmxpbmUgY29udGVudC5cIlxuICAgICk7XG4gIGUuY29udGVudC5sZW5ndGggPT09IDEgJiYgZS5jb250ZW50WzBdLnR5cGUgPT09IFwidGV4dFwiICYmIGUuY29udGVudFswXS50ZXh0ID09PSBcIi9cIiB8fCBlLmNvbnRlbnQubGVuZ3RoID09PSAwID8gbi51cGRhdGVCbG9jayhlLCB0KSA6IChuLmluc2VydEJsb2NrcyhbdF0sIGUsIFwiYWZ0ZXJcIiksIG4uc2V0VGV4dEN1cnNvclBvc2l0aW9uKG4uZ2V0VGV4dEN1cnNvclBvc2l0aW9uKCkubmV4dEJsb2NrKSk7XG59XG5jb25zdCBZbyA9IChuID0gcXQpID0+IHtcbiAgdmFyIGUsIG8sIHI7XG4gIGNvbnN0IHQgPSBbXTtcbiAgcmV0dXJuIFwiaGVhZGluZ1wiIGluIG4gJiYgXCJsZXZlbFwiIGluIG4uaGVhZGluZy5wcm9wU2NoZW1hICYmICgoZSA9IG4uaGVhZGluZy5wcm9wU2NoZW1hLmxldmVsLnZhbHVlcykgIT0gbnVsbCAmJiBlLmluY2x1ZGVzKDEpICYmIHQucHVzaCh7XG4gICAgbmFtZTogXCJIZWFkaW5nXCIsXG4gICAgYWxpYXNlczogW1wiaFwiLCBcImhlYWRpbmcxXCIsIFwiaDFcIl0sXG4gICAgZXhlY3V0ZTogKGkpID0+IE4oaSwge1xuICAgICAgdHlwZTogXCJoZWFkaW5nXCIsXG4gICAgICBwcm9wczogeyBsZXZlbDogMSB9XG4gICAgfSlcbiAgfSksIChvID0gbi5oZWFkaW5nLnByb3BTY2hlbWEubGV2ZWwudmFsdWVzKSAhPSBudWxsICYmIG8uaW5jbHVkZXMoMikgJiYgdC5wdXNoKHtcbiAgICBuYW1lOiBcIkhlYWRpbmcgMlwiLFxuICAgIGFsaWFzZXM6IFtcImgyXCIsIFwiaGVhZGluZzJcIiwgXCJzdWJoZWFkaW5nXCJdLFxuICAgIGV4ZWN1dGU6IChpKSA9PiBOKGksIHtcbiAgICAgIHR5cGU6IFwiaGVhZGluZ1wiLFxuICAgICAgcHJvcHM6IHsgbGV2ZWw6IDIgfVxuICAgIH0pXG4gIH0pLCAociA9IG4uaGVhZGluZy5wcm9wU2NoZW1hLmxldmVsLnZhbHVlcykgIT0gbnVsbCAmJiByLmluY2x1ZGVzKDMpICYmIHQucHVzaCh7XG4gICAgbmFtZTogXCJIZWFkaW5nIDNcIixcbiAgICBhbGlhc2VzOiBbXCJoM1wiLCBcImhlYWRpbmczXCIsIFwic3ViaGVhZGluZ1wiXSxcbiAgICBleGVjdXRlOiAoaSkgPT4gTihpLCB7XG4gICAgICB0eXBlOiBcImhlYWRpbmdcIixcbiAgICAgIHByb3BzOiB7IGxldmVsOiAzIH1cbiAgICB9KVxuICB9KSksIFwiYnVsbGV0TGlzdEl0ZW1cIiBpbiBuICYmIHQucHVzaCh7XG4gICAgbmFtZTogXCJCdWxsZXQgTGlzdFwiLFxuICAgIGFsaWFzZXM6IFtcInVsXCIsIFwibGlzdFwiLCBcImJ1bGxldGxpc3RcIiwgXCJidWxsZXQgbGlzdFwiXSxcbiAgICBleGVjdXRlOiAoaSkgPT4gTihpLCB7XG4gICAgICB0eXBlOiBcImJ1bGxldExpc3RJdGVtXCJcbiAgICB9KVxuICB9KSwgXCJudW1iZXJlZExpc3RJdGVtXCIgaW4gbiAmJiB0LnB1c2goe1xuICAgIG5hbWU6IFwiTnVtYmVyZWQgTGlzdFwiLFxuICAgIGFsaWFzZXM6IFtcImxpXCIsIFwibGlzdFwiLCBcIm51bWJlcmVkbGlzdFwiLCBcIm51bWJlcmVkIGxpc3RcIl0sXG4gICAgZXhlY3V0ZTogKGkpID0+IE4oaSwge1xuICAgICAgdHlwZTogXCJudW1iZXJlZExpc3RJdGVtXCJcbiAgICB9KVxuICB9KSwgXCJwYXJhZ3JhcGhcIiBpbiBuICYmIHQucHVzaCh7XG4gICAgbmFtZTogXCJQYXJhZ3JhcGhcIixcbiAgICBhbGlhc2VzOiBbXCJwXCJdLFxuICAgIGV4ZWN1dGU6IChpKSA9PiBOKGksIHtcbiAgICAgIHR5cGU6IFwicGFyYWdyYXBoXCJcbiAgICB9KVxuICB9KSwgXCJpbWFnZVwiIGluIG4gJiYgdC5wdXNoKHtcbiAgICBuYW1lOiBcIkltYWdlXCIsXG4gICAgYWxpYXNlczogW1xuICAgICAgXCJpbWFnZVwiLFxuICAgICAgXCJpbWFnZVVwbG9hZFwiLFxuICAgICAgXCJ1cGxvYWRcIixcbiAgICAgIFwiaW1nXCIsXG4gICAgICBcInBpY3R1cmVcIixcbiAgICAgIFwibWVkaWFcIixcbiAgICAgIFwidXJsXCIsXG4gICAgICBcImRyaXZlXCIsXG4gICAgICBcImRyb3Bib3hcIlxuICAgIF0sXG4gICAgZXhlY3V0ZTogKGkpID0+IHtcbiAgICAgIE4oaSwge1xuICAgICAgICB0eXBlOiBcImltYWdlXCJcbiAgICAgIH0pLCBpLnNldFRleHRDdXJzb3JQb3NpdGlvbihcbiAgICAgICAgaS5nZXRUZXh0Q3Vyc29yUG9zaXRpb24oKS5uZXh0QmxvY2ssXG4gICAgICAgIFwic3RhcnRcIlxuICAgICAgKSwgaS5fdGlwdGFwRWRpdG9yLnZpZXcuZGlzcGF0Y2goXG4gICAgICAgIGkuX3RpcHRhcEVkaXRvci5zdGF0ZS50ci5zZXRNZXRhKFUsIHtcbiAgICAgICAgICBibG9jazogaS5nZXRUZXh0Q3Vyc29yUG9zaXRpb24oKS5wcmV2QmxvY2tcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICB9KSwgdDtcbn0sIEpvID0ge1xuICBlbmFibGVJbnB1dFJ1bGVzOiAhMCxcbiAgZW5hYmxlUGFzdGVSdWxlczogITAsXG4gIGVuYWJsZUNvcmVFeHRlbnNpb25zOiAhMVxufTtcbmNsYXNzIF9uIHtcbiAgY29uc3RydWN0b3IodCA9IHt9KSB7XG4gICAgdSh0aGlzLCBcIl90aXB0YXBFZGl0b3JcIik7XG4gICAgdSh0aGlzLCBcImJsb2NrQ2FjaGVcIiwgLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCkpO1xuICAgIHUodGhpcywgXCJzY2hlbWFcIik7XG4gICAgdSh0aGlzLCBcInJlYWR5XCIsICExKTtcbiAgICB1KHRoaXMsIFwic2lkZU1lbnVcIik7XG4gICAgdSh0aGlzLCBcImZvcm1hdHRpbmdUb29sYmFyXCIpO1xuICAgIHUodGhpcywgXCJzbGFzaE1lbnVcIik7XG4gICAgdSh0aGlzLCBcImh5cGVybGlua1Rvb2xiYXJcIik7XG4gICAgdSh0aGlzLCBcImltYWdlVG9vbGJhclwiKTtcbiAgICB1KHRoaXMsIFwidXBsb2FkRmlsZVwiKTtcbiAgICB2YXIgbCwgYSwgZCwgYywgaCwgbSwgcCwgZiwgYiwgdywgQywgTTtcbiAgICB0aGlzLm9wdGlvbnMgPSB0O1xuICAgIGNvbnN0IGUgPSB7XG4gICAgICBkZWZhdWx0U3R5bGVzOiAhMCxcbiAgICAgIC8vIFRPRE86IFRoZXJlJ3MgYSBsb3Qgb2YgYW5ub3lpbmcgdHlwaW5nIHN0dWZmIHRvIGRlYWwgd2l0aCBoZXJlLiBJZlxuICAgICAgLy8gIEJTY2hlbWEgaXMgc3BlY2lmaWVkLCB0aGVuIG9wdGlvbnMuYmxvY2tTY2hlbWEgc2hvdWxkIGFsc28gYmUgcmVxdWlyZWQuXG4gICAgICAvLyAgSWYgQlNjaGVtYSBpcyBub3Qgc3BlY2lmaWVkLCB0aGVuIG9wdGlvbnMuYmxvY2tTY2hlbWEgc2hvdWxkIGFsc28gbm90XG4gICAgICAvLyAgYmUgZGVmaW5lZC4gVW5mb3J0dW5hdGVseSwgdHJ5aW5nIHRvIGltcGxlbWVudCB0aGVzZSBjb25zdHJhaW50cyBzZWVtc1xuICAgICAgLy8gIHRvIGJlIGEgaHVnZSBwYWluLCBoZW5jZSB0aGUgYGFzIGFueWAgY2FzdHMuXG4gICAgICBibG9ja1NjaGVtYTogdC5ibG9ja1NjaGVtYSB8fCBxdCxcbiAgICAgIC4uLnRcbiAgICB9O1xuICAgIHRoaXMuc2lkZU1lbnUgPSBuZXcgS28odGhpcyksIHRoaXMuZm9ybWF0dGluZ1Rvb2xiYXIgPSBuZXcgem8odGhpcyksIHRoaXMuc2xhc2hNZW51ID0gbmV3IFplKFxuICAgICAgdGhpcyxcbiAgICAgIGUuc2xhc2hNZW51SXRlbXMgfHwgWW8oZS5ibG9ja1NjaGVtYSlcbiAgICApLCB0aGlzLmh5cGVybGlua1Rvb2xiYXIgPSBuZXcgRm8odGhpcyksIHRoaXMuaW1hZ2VUb29sYmFyID0gbmV3IExvKHRoaXMpO1xuICAgIGNvbnN0IG8gPSBpbyh7XG4gICAgICBlZGl0b3I6IHRoaXMsXG4gICAgICBkb21BdHRyaWJ1dGVzOiBlLmRvbUF0dHJpYnV0ZXMgfHwge30sXG4gICAgICBibG9ja1NjaGVtYTogZS5ibG9ja1NjaGVtYSxcbiAgICAgIGNvbGxhYm9yYXRpb246IGUuY29sbGFib3JhdGlvblxuICAgIH0pLCByID0gTC5jcmVhdGUoe1xuICAgICAgbmFtZTogXCJCbG9ja05vdGVVSUV4dGVuc2lvblwiLFxuICAgICAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zOiAoKSA9PiBbXG4gICAgICAgIHRoaXMuc2lkZU1lbnUucGx1Z2luLFxuICAgICAgICB0aGlzLmZvcm1hdHRpbmdUb29sYmFyLnBsdWdpbixcbiAgICAgICAgdGhpcy5zbGFzaE1lbnUucGx1Z2luLFxuICAgICAgICB0aGlzLmh5cGVybGlua1Rvb2xiYXIucGx1Z2luLFxuICAgICAgICB0aGlzLmltYWdlVG9vbGJhci5wbHVnaW5cbiAgICAgIF1cbiAgICB9KTtcbiAgICBvLnB1c2gociksIHRoaXMuc2NoZW1hID0gZS5ibG9ja1NjaGVtYSwgdGhpcy51cGxvYWRGaWxlID0gZS51cGxvYWRGaWxlO1xuICAgIGNvbnN0IGkgPSBlLmluaXRpYWxDb250ZW50IHx8ICh0LmNvbGxhYm9yYXRpb24gPyB2b2lkIDAgOiBbXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwicGFyYWdyYXBoXCIsXG4gICAgICAgIGlkOiBYLm9wdGlvbnMuZ2VuZXJhdGVJRCgpXG4gICAgICB9XG4gICAgXSksIHMgPSB7XG4gICAgICAuLi5KbyxcbiAgICAgIC4uLmUuX3RpcHRhcE9wdGlvbnMsXG4gICAgICBvbkJlZm9yZUNyZWF0ZShFKSB7XG4gICAgICAgIHZhciBnLCB4O1xuICAgICAgICBpZiAoKHggPSAoZyA9IGUuX3RpcHRhcE9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBnLm9uQmVmb3JlQ3JlYXRlKSA9PSBudWxsIHx8IHguY2FsbChnLCBFKSwgIWkpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB5ID0gRS5lZGl0b3Iuc2NoZW1hLCBTID0geS5ub2RlKFxuICAgICAgICAgIFwiZG9jXCIsXG4gICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgIHkubm9kZShcImJsb2NrR3JvdXBcIiwgdm9pZCAwLCBbXG4gICAgICAgICAgICBGKHsgaWQ6IFwiaW5pdGlhbEJsb2NrXCIsIHR5cGU6IFwicGFyYWdyYXBoXCIgfSwgeSlcbiAgICAgICAgICBdKVxuICAgICAgICApO1xuICAgICAgICBFLmVkaXRvci5vcHRpb25zLmNvbnRlbnQgPSBTLnRvSlNPTigpO1xuICAgICAgfSxcbiAgICAgIG9uQ3JlYXRlOiAoRSkgPT4ge1xuICAgICAgICB2YXIgeSwgUywgZztcbiAgICAgICAgKFMgPSAoeSA9IGUuX3RpcHRhcE9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiB5Lm9uQ3JlYXRlKSA9PSBudWxsIHx8IFMuY2FsbCh5LCBFKSwgaSAhPT0gdm9pZCAwICYmIHRoaXMucmVwbGFjZUJsb2Nrcyh0aGlzLnRvcExldmVsQmxvY2tzLCBpKSwgKGcgPSBlLm9uRWRpdG9yUmVhZHkpID09IG51bGwgfHwgZy5jYWxsKGUsIHRoaXMpLCB0aGlzLnJlYWR5ID0gITA7XG4gICAgICB9LFxuICAgICAgb25VcGRhdGU6IChFKSA9PiB7XG4gICAgICAgIHZhciB5LCBTLCBnO1xuICAgICAgICAoUyA9ICh5ID0gZS5fdGlwdGFwT3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IHkub25VcGRhdGUpID09IG51bGwgfHwgUy5jYWxsKHksIEUpLCB0aGlzLnJlYWR5ICYmICgoZyA9IGUub25FZGl0b3JDb250ZW50Q2hhbmdlKSA9PSBudWxsIHx8IGcuY2FsbChlLCB0aGlzKSk7XG4gICAgICB9LFxuICAgICAgb25TZWxlY3Rpb25VcGRhdGU6IChFKSA9PiB7XG4gICAgICAgIHZhciB5LCBTLCBnO1xuICAgICAgICAoUyA9ICh5ID0gZS5fdGlwdGFwT3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IHkub25TZWxlY3Rpb25VcGRhdGUpID09IG51bGwgfHwgUy5jYWxsKHksIEUpLCB0aGlzLnJlYWR5ICYmICgoZyA9IGUub25UZXh0Q3Vyc29yUG9zaXRpb25DaGFuZ2UpID09IG51bGwgfHwgZy5jYWxsKGUsIHRoaXMpKTtcbiAgICAgIH0sXG4gICAgICBlZGl0YWJsZTogdC5lZGl0YWJsZSAhPT0gdm9pZCAwID8gdC5lZGl0YWJsZSA6ICgobCA9IGUuX3RpcHRhcE9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBsLmVkaXRhYmxlKSAhPT0gdm9pZCAwID8gKGEgPSBlLl90aXB0YXBPcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogYS5lZGl0YWJsZSA6ICEwLFxuICAgICAgZXh0ZW5zaW9uczogZS5lbmFibGVCbG9ja05vdGVFeHRlbnNpb25zID09PSAhMSA/ICgoZCA9IGUuX3RpcHRhcE9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBkLmV4dGVuc2lvbnMpIHx8IFtdIDogWy4uLigoYyA9IGUuX3RpcHRhcE9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBjLmV4dGVuc2lvbnMpIHx8IFtdLCAuLi5vXSxcbiAgICAgIGVkaXRvclByb3BzOiB7XG4gICAgICAgIC4uLihoID0gZS5fdGlwdGFwT3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IGguZWRpdG9yUHJvcHMsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAuLi4ocCA9IChtID0gZS5fdGlwdGFwT3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IG0uZWRpdG9yUHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiBwLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgLi4uKGYgPSBlLmRvbUF0dHJpYnV0ZXMpID09IG51bGwgPyB2b2lkIDAgOiBmLmVkaXRvcixcbiAgICAgICAgICBjbGFzczogQihcbiAgICAgICAgICAgIFIuYm5FZGl0b3IsXG4gICAgICAgICAgICBSLmJuUm9vdCxcbiAgICAgICAgICAgICgodyA9IChiID0gZS5kb21BdHRyaWJ1dGVzKSA9PSBudWxsID8gdm9pZCAwIDogYi5lZGl0b3IpID09IG51bGwgPyB2b2lkIDAgOiB3LmNsYXNzKSB8fCBcIlwiLFxuICAgICAgICAgICAgZS5kZWZhdWx0U3R5bGVzID8gUi5kZWZhdWx0U3R5bGVzIDogXCJcIixcbiAgICAgICAgICAgICgoTSA9IChDID0gZS5kb21BdHRyaWJ1dGVzKSA9PSBudWxsID8gdm9pZCAwIDogQy5lZGl0b3IpID09IG51bGwgPyB2b2lkIDAgOiBNLmNsYXNzKSB8fCBcIlwiXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBlLnBhcmVudEVsZW1lbnQgJiYgKHMuZWxlbWVudCA9IGUucGFyZW50RWxlbWVudCksIHRoaXMuX3RpcHRhcEVkaXRvciA9IG5ldyBpZShzKTtcbiAgfVxuICBnZXQgcHJvc2VtaXJyb3JWaWV3KCkge1xuICAgIHJldHVybiB0aGlzLl90aXB0YXBFZGl0b3IudmlldztcbiAgfVxuICBnZXQgZG9tRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGlwdGFwRWRpdG9yLnZpZXcuZG9tO1xuICB9XG4gIGlzRm9jdXNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGlwdGFwRWRpdG9yLnZpZXcuaGFzRm9jdXMoKTtcbiAgfVxuICBmb2N1cygpIHtcbiAgICB0aGlzLl90aXB0YXBFZGl0b3Iudmlldy5mb2N1cygpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIGEgc25hcHNob3Qgb2YgYWxsIHRvcC1sZXZlbCAobm9uLW5lc3RlZCkgYmxvY2tzIGluIHRoZSBlZGl0b3IuXG4gICAqIEByZXR1cm5zIEEgc25hcHNob3Qgb2YgYWxsIHRvcC1sZXZlbCAobm9uLW5lc3RlZCkgYmxvY2tzIGluIHRoZSBlZGl0b3IuXG4gICAqL1xuICBnZXQgdG9wTGV2ZWxCbG9ja3MoKSB7XG4gICAgY29uc3QgdCA9IFtdO1xuICAgIHJldHVybiB0aGlzLl90aXB0YXBFZGl0b3Iuc3RhdGUuZG9jLmZpcnN0Q2hpbGQuZGVzY2VuZGFudHMoKGUpID0+ICh0LnB1c2goQShlLCB0aGlzLnNjaGVtYSwgdGhpcy5ibG9ja0NhY2hlKSksICExKSksIHQ7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgYSBzbmFwc2hvdCBvZiBhbiBleGlzdGluZyBibG9jayBmcm9tIHRoZSBlZGl0b3IuXG4gICAqIEBwYXJhbSBibG9ja0lkZW50aWZpZXIgVGhlIGlkZW50aWZpZXIgb2YgYW4gZXhpc3RpbmcgYmxvY2sgdGhhdCBzaG91bGQgYmUgcmV0cmlldmVkLlxuICAgKiBAcmV0dXJucyBUaGUgYmxvY2sgdGhhdCBtYXRjaGVzIHRoZSBpZGVudGlmaWVyLCBvciBgdW5kZWZpbmVkYCBpZiBubyBtYXRjaGluZyBibG9jayB3YXMgZm91bmQuXG4gICAqL1xuICBnZXRCbG9jayh0KSB7XG4gICAgY29uc3QgZSA9IHR5cGVvZiB0ID09IFwic3RyaW5nXCIgPyB0IDogdC5pZDtcbiAgICBsZXQgbztcbiAgICByZXR1cm4gdGhpcy5fdGlwdGFwRWRpdG9yLnN0YXRlLmRvYy5maXJzdENoaWxkLmRlc2NlbmRhbnRzKChyKSA9PiB0eXBlb2YgbyA8IFwidVwiID8gITEgOiByLnR5cGUubmFtZSAhPT0gXCJibG9ja0NvbnRhaW5lclwiIHx8IHIuYXR0cnMuaWQgIT09IGUgPyAhMCA6IChvID0gQShyLCB0aGlzLnNjaGVtYSwgdGhpcy5ibG9ja0NhY2hlKSwgITEpKSwgbztcbiAgfVxuICAvKipcbiAgICogVHJhdmVyc2VzIGFsbCBibG9ja3MgaW4gdGhlIGVkaXRvciBkZXB0aC1maXJzdCwgYW5kIGV4ZWN1dGVzIGEgY2FsbGJhY2sgZm9yIGVhY2guXG4gICAqIEBwYXJhbSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gZXhlY3V0ZSBmb3IgZWFjaCBibG9jay4gUmV0dXJuaW5nIGBmYWxzZWAgc3RvcHMgdGhlIHRyYXZlcnNhbC5cbiAgICogQHBhcmFtIHJldmVyc2UgV2hldGhlciB0aGUgYmxvY2tzIHNob3VsZCBiZSB0cmF2ZXJzZWQgaW4gcmV2ZXJzZSBvcmRlci5cbiAgICovXG4gIGZvckVhY2hCbG9jayh0LCBlID0gITEpIHtcbiAgICBjb25zdCBvID0gdGhpcy50b3BMZXZlbEJsb2Nrcy5zbGljZSgpO1xuICAgIGUgJiYgby5yZXZlcnNlKCk7XG4gICAgZnVuY3Rpb24gcihpKSB7XG4gICAgICBmb3IgKGNvbnN0IHMgb2YgaSkge1xuICAgICAgICBpZiAoIXQocykpXG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICBjb25zdCBsID0gZSA/IHMuY2hpbGRyZW4uc2xpY2UoKS5yZXZlcnNlKCkgOiBzLmNoaWxkcmVuO1xuICAgICAgICBpZiAoIXIobCkpXG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgfVxuICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgICByKG8pO1xuICB9XG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhIGNhbGxiYWNrIHdoZW5ldmVyIHRoZSBlZGl0b3IncyBjb250ZW50cyBjaGFuZ2UuXG4gICAqIEBwYXJhbSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gZXhlY3V0ZS5cbiAgICovXG4gIG9uRWRpdG9yQ29udGVudENoYW5nZSh0KSB7XG4gICAgdGhpcy5fdGlwdGFwRWRpdG9yLm9uKFwidXBkYXRlXCIsIHQpO1xuICB9XG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhIGNhbGxiYWNrIHdoZW5ldmVyIHRoZSBlZGl0b3IncyBzZWxlY3Rpb24gY2hhbmdlcy5cbiAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBleGVjdXRlLlxuICAgKi9cbiAgb25FZGl0b3JTZWxlY3Rpb25DaGFuZ2UodCkge1xuICAgIHRoaXMuX3RpcHRhcEVkaXRvci5vbihcInNlbGVjdGlvblVwZGF0ZVwiLCB0KTtcbiAgfVxuICAvKipcbiAgICogR2V0cyBhIHNuYXBzaG90IG9mIHRoZSBjdXJyZW50IHRleHQgY3Vyc29yIHBvc2l0aW9uLlxuICAgKiBAcmV0dXJucyBBIHNuYXBzaG90IG9mIHRoZSBjdXJyZW50IHRleHQgY3Vyc29yIHBvc2l0aW9uLlxuICAgKi9cbiAgZ2V0VGV4dEN1cnNvclBvc2l0aW9uKCkge1xuICAgIGNvbnN0IHsgbm9kZTogdCwgZGVwdGg6IGUsIHN0YXJ0UG9zOiBvLCBlbmRQb3M6IHIgfSA9IHYoXG4gICAgICB0aGlzLl90aXB0YXBFZGl0b3Iuc3RhdGUuZG9jLFxuICAgICAgdGhpcy5fdGlwdGFwRWRpdG9yLnN0YXRlLnNlbGVjdGlvbi5mcm9tXG4gICAgKSwgaSA9IHRoaXMuX3RpcHRhcEVkaXRvci5zdGF0ZS5kb2MucmVzb2x2ZShyKS5pbmRleChlIC0gMSksIHMgPSB0aGlzLl90aXB0YXBFZGl0b3Iuc3RhdGUuZG9jLnJlc29sdmUociArIDEpLm5vZGUoKS5jaGlsZENvdW50O1xuICAgIGxldCBsO1xuICAgIGkgPiAwICYmIChsID0gdGhpcy5fdGlwdGFwRWRpdG9yLnN0YXRlLmRvYy5yZXNvbHZlKG8gLSAyKS5ub2RlKCkpO1xuICAgIGxldCBhO1xuICAgIHJldHVybiBpIDwgcyAtIDEgJiYgKGEgPSB0aGlzLl90aXB0YXBFZGl0b3Iuc3RhdGUuZG9jLnJlc29sdmUociArIDIpLm5vZGUoKSksIHtcbiAgICAgIGJsb2NrOiBBKHQsIHRoaXMuc2NoZW1hLCB0aGlzLmJsb2NrQ2FjaGUpLFxuICAgICAgcHJldkJsb2NrOiBsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBBKGwsIHRoaXMuc2NoZW1hLCB0aGlzLmJsb2NrQ2FjaGUpLFxuICAgICAgbmV4dEJsb2NrOiBhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBBKGEsIHRoaXMuc2NoZW1hLCB0aGlzLmJsb2NrQ2FjaGUpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgdGV4dCBjdXJzb3IgcG9zaXRpb24gdG8gdGhlIHN0YXJ0IG9yIGVuZCBvZiBhbiBleGlzdGluZyBibG9jay4gVGhyb3dzIGFuIGVycm9yIGlmIHRoZSB0YXJnZXQgYmxvY2sgY291bGRcbiAgICogbm90IGJlIGZvdW5kLlxuICAgKiBAcGFyYW0gdGFyZ2V0QmxvY2sgVGhlIGlkZW50aWZpZXIgb2YgYW4gZXhpc3RpbmcgYmxvY2sgdGhhdCB0aGUgdGV4dCBjdXJzb3Igc2hvdWxkIGJlIG1vdmVkIHRvLlxuICAgKiBAcGFyYW0gcGxhY2VtZW50IFdoZXRoZXIgdGhlIHRleHQgY3Vyc29yIHNob3VsZCBiZSBwbGFjZWQgYXQgdGhlIHN0YXJ0IG9yIGVuZCBvZiB0aGUgYmxvY2suXG4gICAqL1xuICBzZXRUZXh0Q3Vyc29yUG9zaXRpb24odCwgZSA9IFwic3RhcnRcIikge1xuICAgIGNvbnN0IG8gPSB0eXBlb2YgdCA9PSBcInN0cmluZ1wiID8gdCA6IHQuaWQsIHsgcG9zQmVmb3JlTm9kZTogciB9ID0gb3QobywgdGhpcy5fdGlwdGFwRWRpdG9yLnN0YXRlLmRvYyksIHsgc3RhcnRQb3M6IGksIGNvbnRlbnROb2RlOiBzIH0gPSB2KFxuICAgICAgdGhpcy5fdGlwdGFwRWRpdG9yLnN0YXRlLmRvYyxcbiAgICAgIHIgKyAyXG4gICAgKTtcbiAgICBpZiAocy50eXBlLnNwZWMuY29udGVudCA9PT0gXCJcIikge1xuICAgICAgdGhpcy5fdGlwdGFwRWRpdG9yLmNvbW1hbmRzLnNldE5vZGVTZWxlY3Rpb24oaSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGUgPT09IFwic3RhcnRcIiA/IHRoaXMuX3RpcHRhcEVkaXRvci5jb21tYW5kcy5zZXRUZXh0U2VsZWN0aW9uKGkgKyAxKSA6IHRoaXMuX3RpcHRhcEVkaXRvci5jb21tYW5kcy5zZXRUZXh0U2VsZWN0aW9uKFxuICAgICAgaSArIHMubm9kZVNpemUgLSAxXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyBhIHNuYXBzaG90IG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAgICovXG4gIGdldFNlbGVjdGlvbigpIHtcbiAgICBpZiAodGhpcy5fdGlwdGFwRWRpdG9yLnN0YXRlLnNlbGVjdGlvbi5mcm9tID09PSB0aGlzLl90aXB0YXBFZGl0b3Iuc3RhdGUuc2VsZWN0aW9uLnRvIHx8IFwibm9kZVwiIGluIHRoaXMuX3RpcHRhcEVkaXRvci5zdGF0ZS5zZWxlY3Rpb24pXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IFtdO1xuICAgIHJldHVybiB0aGlzLl90aXB0YXBFZGl0b3Iuc3RhdGUuZG9jLmRlc2NlbmRhbnRzKChlLCBvKSA9PiBlLnR5cGUuc3BlYy5ncm91cCAhPT0gXCJibG9ja0NvbnRlbnRcIiB8fCBvICsgZS5ub2RlU2l6ZSA8IHRoaXMuX3RpcHRhcEVkaXRvci5zdGF0ZS5zZWxlY3Rpb24uZnJvbSB8fCBvID4gdGhpcy5fdGlwdGFwRWRpdG9yLnN0YXRlLnNlbGVjdGlvbi50byA/ICEwIDogKHQucHVzaChcbiAgICAgIEEoXG4gICAgICAgIHRoaXMuX3RpcHRhcEVkaXRvci5zdGF0ZS5kb2MucmVzb2x2ZShvKS5ub2RlKCksXG4gICAgICAgIHRoaXMuc2NoZW1hLFxuICAgICAgICB0aGlzLmJsb2NrQ2FjaGVcbiAgICAgIClcbiAgICApLCAhMSkpLCB7IGJsb2NrczogdCB9O1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGVkaXRvciBpcyBjdXJyZW50bHkgZWRpdGFibGUsIG9yIGlmIGl0J3MgbG9ja2VkLlxuICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBlZGl0b3IgaXMgZWRpdGFibGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGdldCBpc0VkaXRhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl90aXB0YXBFZGl0b3IuaXNFZGl0YWJsZTtcbiAgfVxuICAvKipcbiAgICogTWFrZXMgdGhlIGVkaXRvciBlZGl0YWJsZSBvciBsb2NrcyBpdCwgZGVwZW5kaW5nIG9uIHRoZSBhcmd1bWVudCBwYXNzZWQuXG4gICAqIEBwYXJhbSBlZGl0YWJsZSBUcnVlIHRvIG1ha2UgdGhlIGVkaXRvciBlZGl0YWJsZSwgb3IgZmFsc2UgdG8gbG9jayBpdC5cbiAgICovXG4gIHNldCBpc0VkaXRhYmxlKHQpIHtcbiAgICB0aGlzLl90aXB0YXBFZGl0b3Iuc2V0RWRpdGFibGUodCk7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydHMgbmV3IGJsb2NrcyBpbnRvIHRoZSBlZGl0b3IuIElmIGEgYmxvY2sncyBgaWRgIGlzIHVuZGVmaW5lZCwgQmxvY2tOb3RlIGdlbmVyYXRlcyBvbmUgYXV0b21hdGljYWxseS4gVGhyb3dzIGFuXG4gICAqIGVycm9yIGlmIHRoZSByZWZlcmVuY2UgYmxvY2sgY291bGQgbm90IGJlIGZvdW5kLlxuICAgKiBAcGFyYW0gYmxvY2tzVG9JbnNlcnQgQW4gYXJyYXkgb2YgcGFydGlhbCBibG9ja3MgdGhhdCBzaG91bGQgYmUgaW5zZXJ0ZWQuXG4gICAqIEBwYXJhbSByZWZlcmVuY2VCbG9jayBBbiBpZGVudGlmaWVyIGZvciBhbiBleGlzdGluZyBibG9jaywgYXQgd2hpY2ggdGhlIG5ldyBibG9ja3Mgc2hvdWxkIGJlIGluc2VydGVkLlxuICAgKiBAcGFyYW0gcGxhY2VtZW50IFdoZXRoZXIgdGhlIGJsb2NrcyBzaG91bGQgYmUgaW5zZXJ0ZWQganVzdCBiZWZvcmUsIGp1c3QgYWZ0ZXIsIG9yIG5lc3RlZCBpbnNpZGUgdGhlXG4gICAqIGByZWZlcmVuY2VCbG9ja2AuIEluc2VydHMgdGhlIGJsb2NrcyBhdCB0aGUgc3RhcnQgb2YgdGhlIGV4aXN0aW5nIGJsb2NrJ3MgY2hpbGRyZW4gaWYgXCJuZXN0ZWRcIiBpcyB1c2VkLlxuICAgKi9cbiAgaW5zZXJ0QmxvY2tzKHQsIGUsIG8gPSBcImJlZm9yZVwiKSB7XG4gICAgRnQodCwgZSwgbywgdGhpcy5fdGlwdGFwRWRpdG9yKTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyBhbiBleGlzdGluZyBibG9jayBpbiB0aGUgZWRpdG9yLiBTaW5jZSB1cGRhdGVkQmxvY2sgaXMgYSBQYXJ0aWFsQmxvY2sgb2JqZWN0LCBzb21lIGZpZWxkcyBtaWdodCBub3QgYmVcbiAgICogZGVmaW5lZC4gVGhlc2UgdW5kZWZpbmVkIGZpZWxkcyBhcmUga2VwdCBhcy1pcyBmcm9tIHRoZSBleGlzdGluZyBibG9jay4gVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBibG9jayB0byB1cGRhdGUgY291bGRcbiAgICogbm90IGJlIGZvdW5kLlxuICAgKiBAcGFyYW0gYmxvY2tUb1VwZGF0ZSBUaGUgYmxvY2sgdGhhdCBzaG91bGQgYmUgdXBkYXRlZC5cbiAgICogQHBhcmFtIHVwZGF0ZSBBIHBhcnRpYWwgYmxvY2sgd2hpY2ggZGVmaW5lcyBob3cgdGhlIGV4aXN0aW5nIGJsb2NrIHNob3VsZCBiZSBjaGFuZ2VkLlxuICAgKi9cbiAgdXBkYXRlQmxvY2sodCwgZSkge1xuICAgIHNvKHQsIGUsIHRoaXMuX3RpcHRhcEVkaXRvcik7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgZXhpc3RpbmcgYmxvY2tzIGZyb20gdGhlIGVkaXRvci4gVGhyb3dzIGFuIGVycm9yIGlmIGFueSBvZiB0aGUgYmxvY2tzIGNvdWxkIG5vdCBiZSBmb3VuZC5cbiAgICogQHBhcmFtIGJsb2Nrc1RvUmVtb3ZlIEFuIGFycmF5IG9mIGlkZW50aWZpZXJzIGZvciBleGlzdGluZyBibG9ja3MgdGhhdCBzaG91bGQgYmUgcmVtb3ZlZC5cbiAgICovXG4gIHJlbW92ZUJsb2Nrcyh0KSB7XG4gICAgJHQodCwgdGhpcy5fdGlwdGFwRWRpdG9yKTtcbiAgfVxuICAvKipcbiAgICogUmVwbGFjZXMgZXhpc3RpbmcgYmxvY2tzIGluIHRoZSBlZGl0b3Igd2l0aCBuZXcgYmxvY2tzLiBJZiB0aGUgYmxvY2tzIHRoYXQgc2hvdWxkIGJlIHJlbW92ZWQgYXJlIG5vdCBhZGphY2VudCBvclxuICAgKiBhcmUgYXQgZGlmZmVyZW50IG5lc3RpbmcgbGV2ZWxzLCBgYmxvY2tzVG9JbnNlcnRgIHdpbGwgYmUgaW5zZXJ0ZWQgYXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBibG9jayBpblxuICAgKiBgYmxvY2tzVG9SZW1vdmVgLiBUaHJvd3MgYW4gZXJyb3IgaWYgYW55IG9mIHRoZSBibG9ja3MgdG8gcmVtb3ZlIGNvdWxkIG5vdCBiZSBmb3VuZC5cbiAgICogQHBhcmFtIGJsb2Nrc1RvUmVtb3ZlIEFuIGFycmF5IG9mIGJsb2NrcyB0aGF0IHNob3VsZCBiZSByZXBsYWNlZC5cbiAgICogQHBhcmFtIGJsb2Nrc1RvSW5zZXJ0IEFuIGFycmF5IG9mIHBhcnRpYWwgYmxvY2tzIHRvIHJlcGxhY2UgdGhlIG9sZCBvbmVzIHdpdGguXG4gICAqL1xuICByZXBsYWNlQmxvY2tzKHQsIGUpIHtcbiAgICBhbyh0LCBlLCB0aGlzLl90aXB0YXBFZGl0b3IpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBhY3RpdmUgdGV4dCBzdHlsZXMgYXQgdGhlIHRleHQgY3Vyc29yIHBvc2l0aW9uIG9yIGF0IHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGlmIGl0J3MgYWN0aXZlLlxuICAgKi9cbiAgZ2V0QWN0aXZlU3R5bGVzKCkge1xuICAgIGNvbnN0IHQgPSB7fSwgZSA9IHRoaXMuX3RpcHRhcEVkaXRvci5zdGF0ZS5zZWxlY3Rpb24uJHRvLm1hcmtzKCksIG8gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gICAgICBcImJvbGRcIixcbiAgICAgIFwiaXRhbGljXCIsXG4gICAgICBcInVuZGVybGluZVwiLFxuICAgICAgXCJzdHJpa2VcIixcbiAgICAgIFwiY29kZVwiXG4gICAgXSksIHIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJ0ZXh0Q29sb3JcIiwgXCJiYWNrZ3JvdW5kQ29sb3JcIl0pO1xuICAgIGZvciAoY29uc3QgaSBvZiBlKVxuICAgICAgby5oYXMoaS50eXBlLm5hbWUpID8gdFtpLnR5cGUubmFtZV0gPSAhMCA6IHIuaGFzKGkudHlwZS5uYW1lKSAmJiAodFtpLnR5cGUubmFtZV0gPSBpLmF0dHJzLmNvbG9yKTtcbiAgICByZXR1cm4gdDtcbiAgfVxuICAvKipcbiAgICogQWRkcyBzdHlsZXMgdG8gdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBjb250ZW50LlxuICAgKiBAcGFyYW0gc3R5bGVzIFRoZSBzdHlsZXMgdG8gYWRkLlxuICAgKi9cbiAgYWRkU3R5bGVzKHQpIHtcbiAgICBjb25zdCBlID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICAgICAgXCJib2xkXCIsXG4gICAgICBcIml0YWxpY1wiLFxuICAgICAgXCJ1bmRlcmxpbmVcIixcbiAgICAgIFwic3RyaWtlXCIsXG4gICAgICBcImNvZGVcIlxuICAgIF0pLCBvID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1widGV4dENvbG9yXCIsIFwiYmFja2dyb3VuZENvbG9yXCJdKTtcbiAgICB0aGlzLl90aXB0YXBFZGl0b3Iudmlldy5mb2N1cygpO1xuICAgIGZvciAoY29uc3QgW3IsIGldIG9mIE9iamVjdC5lbnRyaWVzKHQpKVxuICAgICAgZS5oYXMocikgPyB0aGlzLl90aXB0YXBFZGl0b3IuY29tbWFuZHMuc2V0TWFyayhyKSA6IG8uaGFzKHIpICYmIHRoaXMuX3RpcHRhcEVkaXRvci5jb21tYW5kcy5zZXRNYXJrKHIsIHsgY29sb3I6IGkgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgc3R5bGVzIGZyb20gdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBjb250ZW50LlxuICAgKiBAcGFyYW0gc3R5bGVzIFRoZSBzdHlsZXMgdG8gcmVtb3ZlLlxuICAgKi9cbiAgcmVtb3ZlU3R5bGVzKHQpIHtcbiAgICB0aGlzLl90aXB0YXBFZGl0b3Iudmlldy5mb2N1cygpO1xuICAgIGZvciAoY29uc3QgZSBvZiBPYmplY3Qua2V5cyh0KSlcbiAgICAgIHRoaXMuX3RpcHRhcEVkaXRvci5jb21tYW5kcy51bnNldE1hcmsoZSk7XG4gIH1cbiAgLyoqXG4gICAqIFRvZ2dsZXMgc3R5bGVzIG9uIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgY29udGVudC5cbiAgICogQHBhcmFtIHN0eWxlcyBUaGUgc3R5bGVzIHRvIHRvZ2dsZS5cbiAgICovXG4gIHRvZ2dsZVN0eWxlcyh0KSB7XG4gICAgY29uc3QgZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgICAgIFwiYm9sZFwiLFxuICAgICAgXCJpdGFsaWNcIixcbiAgICAgIFwidW5kZXJsaW5lXCIsXG4gICAgICBcInN0cmlrZVwiLFxuICAgICAgXCJjb2RlXCJcbiAgICBdKSwgbyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcInRleHRDb2xvclwiLCBcImJhY2tncm91bmRDb2xvclwiXSk7XG4gICAgdGhpcy5fdGlwdGFwRWRpdG9yLnZpZXcuZm9jdXMoKTtcbiAgICBmb3IgKGNvbnN0IFtyLCBpXSBvZiBPYmplY3QuZW50cmllcyh0KSlcbiAgICAgIGUuaGFzKHIpID8gdGhpcy5fdGlwdGFwRWRpdG9yLmNvbW1hbmRzLnRvZ2dsZU1hcmsocikgOiBvLmhhcyhyKSAmJiB0aGlzLl90aXB0YXBFZGl0b3IuY29tbWFuZHMudG9nZ2xlTWFyayhyLCB7IGNvbG9yOiBpIH0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgdGV4dC5cbiAgICovXG4gIGdldFNlbGVjdGVkVGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGlwdGFwRWRpdG9yLnN0YXRlLmRvYy50ZXh0QmV0d2VlbihcbiAgICAgIHRoaXMuX3RpcHRhcEVkaXRvci5zdGF0ZS5zZWxlY3Rpb24uZnJvbSxcbiAgICAgIHRoaXMuX3RpcHRhcEVkaXRvci5zdGF0ZS5zZWxlY3Rpb24udG9cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBVUkwgb2YgdGhlIGxhc3QgbGluayBpbiB0aGUgY3VycmVudCBzZWxlY3Rpb24sIG9yIGB1bmRlZmluZWRgIGlmIHRoZXJlIGFyZSBubyBsaW5rcyBpbiB0aGUgc2VsZWN0aW9uLlxuICAgKi9cbiAgZ2V0U2VsZWN0ZWRMaW5rVXJsKCkge1xuICAgIHJldHVybiB0aGlzLl90aXB0YXBFZGl0b3IuZ2V0QXR0cmlidXRlcyhcImxpbmtcIikuaHJlZjtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBsaW5rIHRvIHJlcGxhY2UgdGhlIHNlbGVjdGVkIGNvbnRlbnQuXG4gICAqIEBwYXJhbSB1cmwgVGhlIGxpbmsgVVJMLlxuICAgKiBAcGFyYW0gdGV4dCBUaGUgdGV4dCB0byBkaXNwbGF5IHRoZSBsaW5rIHdpdGguXG4gICAqL1xuICBjcmVhdGVMaW5rKHQsIGUpIHtcbiAgICBpZiAodCA9PT0gXCJcIilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IGZyb206IG8sIHRvOiByIH0gPSB0aGlzLl90aXB0YXBFZGl0b3Iuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGUgfHwgKGUgPSB0aGlzLl90aXB0YXBFZGl0b3Iuc3RhdGUuZG9jLnRleHRCZXR3ZWVuKG8sIHIpKTtcbiAgICBjb25zdCBpID0gdGhpcy5fdGlwdGFwRWRpdG9yLnNjaGVtYS5tYXJrKFwibGlua1wiLCB7IGhyZWY6IHQgfSk7XG4gICAgdGhpcy5fdGlwdGFwRWRpdG9yLnZpZXcuZGlzcGF0Y2goXG4gICAgICB0aGlzLl90aXB0YXBFZGl0b3Iudmlldy5zdGF0ZS50ci5pbnNlcnRUZXh0KGUsIG8sIHIpLmFkZE1hcmsobywgbyArIGUubGVuZ3RoLCBpKVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgYmxvY2sgY29udGFpbmluZyB0aGUgdGV4dCBjdXJzb3IgY2FuIGJlIG5lc3RlZC5cbiAgICovXG4gIGNhbk5lc3RCbG9jaygpIHtcbiAgICBjb25zdCB7IHN0YXJ0UG9zOiB0LCBkZXB0aDogZSB9ID0gdihcbiAgICAgIHRoaXMuX3RpcHRhcEVkaXRvci5zdGF0ZS5kb2MsXG4gICAgICB0aGlzLl90aXB0YXBFZGl0b3Iuc3RhdGUuc2VsZWN0aW9uLmZyb21cbiAgICApO1xuICAgIHJldHVybiB0aGlzLl90aXB0YXBFZGl0b3Iuc3RhdGUuZG9jLnJlc29sdmUodCkuaW5kZXgoZSAtIDEpID4gMDtcbiAgfVxuICAvKipcbiAgICogTmVzdHMgdGhlIGJsb2NrIGNvbnRhaW5pbmcgdGhlIHRleHQgY3Vyc29yIGludG8gdGhlIGJsb2NrIGFib3ZlIGl0LlxuICAgKi9cbiAgbmVzdEJsb2NrKCkge1xuICAgIHRoaXMuX3RpcHRhcEVkaXRvci5jb21tYW5kcy5zaW5rTGlzdEl0ZW0oXCJibG9ja0NvbnRhaW5lclwiKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBibG9jayBjb250YWluaW5nIHRoZSB0ZXh0IGN1cnNvciBpcyBuZXN0ZWQuXG4gICAqL1xuICBjYW5Vbm5lc3RCbG9jaygpIHtcbiAgICBjb25zdCB7IGRlcHRoOiB0IH0gPSB2KFxuICAgICAgdGhpcy5fdGlwdGFwRWRpdG9yLnN0YXRlLmRvYyxcbiAgICAgIHRoaXMuX3RpcHRhcEVkaXRvci5zdGF0ZS5zZWxlY3Rpb24uZnJvbVxuICAgICk7XG4gICAgcmV0dXJuIHQgPiAyO1xuICB9XG4gIC8qKlxuICAgKiBMaWZ0cyB0aGUgYmxvY2sgY29udGFpbmluZyB0aGUgdGV4dCBjdXJzb3Igb3V0IG9mIGl0cyBwYXJlbnQuXG4gICAqL1xuICB1bm5lc3RCbG9jaygpIHtcbiAgICB0aGlzLl90aXB0YXBFZGl0b3IuY29tbWFuZHMubGlmdExpc3RJdGVtKFwiYmxvY2tDb250YWluZXJcIik7XG4gIH1cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZXMgYmxvY2tzIGludG8gYW4gSFRNTCBzdHJpbmcuIFRvIGJldHRlciBjb25mb3JtIHRvIEhUTUwgc3RhbmRhcmRzLCBjaGlsZHJlbiBvZiBibG9ja3Mgd2hpY2ggYXJlbid0IGxpc3RcbiAgICogaXRlbXMgYXJlIHVuLW5lc3RlZCBpbiB0aGUgb3V0cHV0IEhUTUwuXG4gICAqIEBwYXJhbSBibG9ja3MgQW4gYXJyYXkgb2YgYmxvY2tzIHRoYXQgc2hvdWxkIGJlIHNlcmlhbGl6ZWQgaW50byBIVE1MLlxuICAgKiBAcmV0dXJucyBUaGUgYmxvY2tzLCBzZXJpYWxpemVkIGFzIGFuIEhUTUwgc3RyaW5nLlxuICAgKi9cbiAgYXN5bmMgYmxvY2tzVG9IVE1MKHQpIHtcbiAgICByZXR1cm4gV3QodCwgdGhpcy5fdGlwdGFwRWRpdG9yLnNjaGVtYSk7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlcyBibG9ja3MgZnJvbSBhbiBIVE1MIHN0cmluZy4gVHJpZXMgdG8gY3JlYXRlIGBCbG9ja2Agb2JqZWN0cyBvdXQgb2YgYW55IEhUTUwgYmxvY2stbGV2ZWwgZWxlbWVudHMsIGFuZFxuICAgKiBgSW5saW5lTm9kZWAgb2JqZWN0cyBmcm9tIGFueSBIVE1MIGlubGluZSBlbGVtZW50cywgdGhvdWdoIG5vdCBhbGwgZWxlbWVudCB0eXBlcyBhcmUgcmVjb2duaXplZC4gSWYgQmxvY2tOb3RlXG4gICAqIGRvZXNuJ3QgcmVjb2duaXplIGFuIEhUTUwgZWxlbWVudCdzIHRhZywgaXQgd2lsbCBwYXJzZSBpdCBhcyBhIHBhcmFncmFwaCBvciBwbGFpbiB0ZXh0LlxuICAgKiBAcGFyYW0gaHRtbCBUaGUgSFRNTCBzdHJpbmcgdG8gcGFyc2UgYmxvY2tzIGZyb20uXG4gICAqIEByZXR1cm5zIFRoZSBibG9ja3MgcGFyc2VkIGZyb20gdGhlIEhUTUwgc3RyaW5nLlxuICAgKi9cbiAgYXN5bmMgSFRNTFRvQmxvY2tzKHQpIHtcbiAgICByZXR1cm4gR3QodCwgdGhpcy5zY2hlbWEsIHRoaXMuX3RpcHRhcEVkaXRvci5zY2hlbWEpO1xuICB9XG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIGJsb2NrcyBpbnRvIGEgTWFya2Rvd24gc3RyaW5nLiBUaGUgb3V0cHV0IGlzIHNpbXBsaWZpZWQgYXMgTWFya2Rvd24gZG9lcyBub3Qgc3VwcG9ydCBhbGwgZmVhdHVyZXMgb2ZcbiAgICogQmxvY2tOb3RlIC0gY2hpbGRyZW4gb2YgYmxvY2tzIHdoaWNoIGFyZW4ndCBsaXN0IGl0ZW1zIGFyZSB1bi1uZXN0ZWQgYW5kIGNlcnRhaW4gc3R5bGVzIGFyZSByZW1vdmVkLlxuICAgKiBAcGFyYW0gYmxvY2tzIEFuIGFycmF5IG9mIGJsb2NrcyB0aGF0IHNob3VsZCBiZSBzZXJpYWxpemVkIGludG8gTWFya2Rvd24uXG4gICAqIEByZXR1cm5zIFRoZSBibG9ja3MsIHNlcmlhbGl6ZWQgYXMgYSBNYXJrZG93biBzdHJpbmcuXG4gICAqL1xuICBhc3luYyBibG9ja3NUb01hcmtkb3duKHQpIHtcbiAgICByZXR1cm4gdW8odCwgdGhpcy5fdGlwdGFwRWRpdG9yLnNjaGVtYSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBsaXN0IG9mIGJsb2NrcyBmcm9tIGEgTWFya2Rvd24gc3RyaW5nLiBUcmllcyB0byBjcmVhdGUgYEJsb2NrYCBhbmQgYElubGluZU5vZGVgIG9iamVjdHMgYmFzZWQgb25cbiAgICogTWFya2Rvd24gc3ludGF4LCB0aG91Z2ggbm90IGFsbCBzeW1ib2xzIGFyZSByZWNvZ25pemVkLiBJZiBCbG9ja05vdGUgZG9lc24ndCByZWNvZ25pemUgYSBzeW1ib2wsIGl0IHdpbGwgcGFyc2UgaXRcbiAgICogYXMgdGV4dC5cbiAgICogQHBhcmFtIG1hcmtkb3duIFRoZSBNYXJrZG93biBzdHJpbmcgdG8gcGFyc2UgYmxvY2tzIGZyb20uXG4gICAqIEByZXR1cm5zIFRoZSBibG9ja3MgcGFyc2VkIGZyb20gdGhlIE1hcmtkb3duIHN0cmluZy5cbiAgICovXG4gIGFzeW5jIG1hcmtkb3duVG9CbG9ja3ModCkge1xuICAgIHJldHVybiBobyh0LCB0aGlzLnNjaGVtYSwgdGhpcy5fdGlwdGFwRWRpdG9yLnNjaGVtYSk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHVzZXIgaW5mbyBmb3IgdGhlIGN1cnJlbnQgdXNlciB0aGF0J3Mgc2hvd24gdG8gb3RoZXIgY29sbGFib3JhdG9ycy5cbiAgICovXG4gIHVwZGF0ZUNvbGxhYm9yYXRpb25Vc2VySW5mbyh0KSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuY29sbGFib3JhdGlvbilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJDYW5ub3QgdXBkYXRlIGNvbGxhYm9yYXRpb24gdXNlciBpbmZvIHdoZW4gY29sbGFib3JhdGlvbiBpcyBkaXNhYmxlZC5cIlxuICAgICAgKTtcbiAgICB0aGlzLl90aXB0YXBFZGl0b3IuY29tbWFuZHMudXBkYXRlVXNlcih0KTtcbiAgfVxufVxuY29uc3QgQW4gPSBhc3luYyAobikgPT4ge1xuICBjb25zdCB0ID0gbmV3IEZvcm1EYXRhKCk7XG4gIHJldHVybiB0LmFwcGVuZChcImZpbGVcIiwgbiksIChhd2FpdCAoYXdhaXQgZmV0Y2goXCJodHRwczovL3RtcGZpbGVzLm9yZy9hcGkvdjEvdXBsb2FkXCIsIHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IHRcbiAgfSkpLmpzb24oKSkuZGF0YS51cmwucmVwbGFjZShcbiAgICBcInRtcGZpbGVzLm9yZy9cIixcbiAgICBcInRtcGZpbGVzLm9yZy9kbC9cIlxuICApO1xufTtcbmV4cG9ydCB7XG4gIF9uIGFzIEJsb2NrTm90ZUVkaXRvcixcbiAgWGUgYXMgQ3VzdG9tQmxvY2tTZXJpYWxpemVyRXh0ZW5zaW9uLFxuICB6byBhcyBGb3JtYXR0aW5nVG9vbGJhclByb3NlbWlycm9yUGx1Z2luLFxuICBPbyBhcyBGb3JtYXR0aW5nVG9vbGJhclZpZXcsXG4gIEZvIGFzIEh5cGVybGlua1Rvb2xiYXJQcm9zZW1pcnJvclBsdWdpbixcbiAgTG8gYXMgSW1hZ2VUb29sYmFyUHJvc2VtaXJyb3JQbHVnaW4sXG4gIEhvIGFzIEltYWdlVG9vbGJhclZpZXcsXG4gIEtvIGFzIFNpZGVNZW51UHJvc2VtaXJyb3JQbHVnaW4sXG4gIHFvIGFzIFNpZGVNZW51VmlldyxcbiAgWmUgYXMgU2xhc2hNZW51UHJvc2VtaXJyb3JQbHVnaW4sXG4gIERlIGFzIFVucmVhY2hhYmxlQ2FzZUVycm9yLFxuICBJbiBhcyBibG9ja1N0eWxlcyxcbiAgY3QgYXMgY2FtZWxUb0RhdGFLZWJhYixcbiAga28gYXMgY3JlYXRlQmxvY2tTcGVjLFxuICBXIGFzIGNyZWF0ZVRpcFRhcEJsb2NrLFxuICBxdCBhcyBkZWZhdWx0QmxvY2tTY2hlbWEsXG4gIFQgYXMgZGVmYXVsdFByb3BzLFxuICB4biBhcyBmb3JtYXRLZXlib2FyZFNob3J0Y3V0LFxuICBSbyBhcyBmb3JtYXR0aW5nVG9vbGJhclBsdWdpbktleSxcbiAgaW8gYXMgZ2V0QmxvY2tOb3RlRXh0ZW5zaW9ucyxcbiAgWW8gYXMgZ2V0RGVmYXVsdFNsYXNoTWVudUl0ZW1zLFxuICBVbyBhcyBoeXBlcmxpbmtUb29sYmFyUGx1Z2luS2V5LFxuICBVIGFzIGltYWdlVG9vbGJhclBsdWdpbktleSxcbiAgUGUgYXMgaXNBcHBsZU9TLFxuICBCIGFzIG1lcmdlQ1NTQ2xhc3NlcyxcbiAgZm8gYXMgcGFyc2UsXG4gIG1vIGFzIHByb3BzVG9BdHRyaWJ1dGVzLFxuICBnbyBhcyByZW5kZXIsXG4gIEplIGFzIHNldHVwU3VnZ2VzdGlvbnNNZW51LFxuICBYbyBhcyBzaWRlTWVudVBsdWdpbktleSxcbiAgZXQgYXMgc2xhc2hNZW51UGx1Z2luS2V5LFxuICBBbiBhcyB1cGxvYWRUb1RtcEZpbGVzRG90T3JnX0RFVl9PTkxZXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmxvY2tub3RlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@blocknote/core/dist/blocknote.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@blocknote/react/dist/blocknote-react.js":
/*!***************************************************************!*\
  !*** ./node_modules/@blocknote/react/dist/blocknote-react.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddBlockButton: () => (/* binding */ wn),\n/* harmony export */   BlockColorsButton: () => (/* binding */ En),\n/* harmony export */   BlockNoteView: () => (/* binding */ eo),\n/* harmony export */   BlockTypeDropdown: () => (/* binding */ on),\n/* harmony export */   ColorStyleButton: () => (/* binding */ un),\n/* harmony export */   CreateLinkButton: () => (/* binding */ vn),\n/* harmony export */   DefaultDragHandleMenu: () => (/* binding */ zn),\n/* harmony export */   DefaultFormattingToolbar: () => (/* binding */ mn),\n/* harmony export */   DefaultImageToolbar: () => (/* binding */ Et),\n/* harmony export */   DefaultSideMenu: () => (/* binding */ In),\n/* harmony export */   DefaultSlashMenu: () => (/* binding */ Fn),\n/* harmony export */   DragHandle: () => (/* binding */ Hn),\n/* harmony export */   DragHandleMenu: () => (/* binding */ Mn),\n/* harmony export */   DragHandleMenuItem: () => (/* binding */ Ht),\n/* harmony export */   FormattingToolbarPositioner: () => (/* binding */ kn),\n/* harmony export */   HyperlinkToolbarPositioner: () => (/* binding */ Cn),\n/* harmony export */   ImageToolbarPositioner: () => (/* binding */ Ln),\n/* harmony export */   InlineContent: () => (/* binding */ no),\n/* harmony export */   NestBlockButton: () => (/* binding */ gn),\n/* harmony export */   RemoveBlockButton: () => (/* binding */ Rn),\n/* harmony export */   SideMenu: () => (/* binding */ jn),\n/* harmony export */   SideMenuButton: () => (/* binding */ zt),\n/* harmony export */   SideMenuPositioner: () => (/* binding */ Bn),\n/* harmony export */   SlashMenuItem: () => (/* binding */ On),\n/* harmony export */   SlashMenuPositioner: () => (/* binding */ An),\n/* harmony export */   TextAlignButton: () => (/* binding */ Se),\n/* harmony export */   ToggledStyleButton: () => (/* binding */ he),\n/* harmony export */   Toolbar: () => (/* binding */ _e),\n/* harmony export */   ToolbarButton: () => (/* binding */ P),\n/* harmony export */   ToolbarDropdown: () => (/* binding */ en),\n/* harmony export */   UnnestBlockButton: () => (/* binding */ fn),\n/* harmony export */   blockNoteToMantineTheme: () => (/* binding */ fe),\n/* harmony export */   createReactBlockSpec: () => (/* binding */ oo),\n/* harmony export */   darkDefaultTheme: () => (/* binding */ dt),\n/* harmony export */   defaultBlockTypeDropdownItems: () => (/* binding */ nn),\n/* harmony export */   defaultColorScheme: () => (/* binding */ k),\n/* harmony export */   getDefaultReactSlashMenuItems: () => (/* binding */ Nn),\n/* harmony export */   lightDefaultTheme: () => (/* binding */ ve),\n/* harmony export */   useBlockNote: () => (/* binding */ to),\n/* harmony export */   useEditorChange: () => (/* binding */ q),\n/* harmony export */   useEditorContentChange: () => (/* binding */ tn),\n/* harmony export */   useEditorForceUpdate: () => (/* binding */ ro),\n/* harmony export */   useEditorSelectionChange: () => (/* binding */ rn),\n/* harmony export */   useSelectedBlocks: () => (/* binding */ G)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _blocknote_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @blocknote/core */ \"(ssr)/./node_modules/@blocknote/core/dist/blocknote.js\");\n/* harmony import */ var _mantine_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @mantine/core */ \"(ssr)/./node_modules/@mantine/core/cjs/index.js\");\n/* harmony import */ var _tiptap_react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @tiptap/react */ \"(ssr)/./node_modules/@tiptap/react/dist/index.js\");\n/* harmony import */ var use_prefers_color_scheme__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! use-prefers-color-scheme */ \"(ssr)/./node_modules/use-prefers-color-scheme/dist/index.cjs.js\");\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\n/* harmony import */ var _tippyjs_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tippyjs/react */ \"(ssr)/./node_modules/@tippyjs/react/dist/tippy-react.umd.js\");\n/* harmony import */ var tippy_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! tippy.js */ \"(ssr)/./node_modules/tippy.js/dist/tippy.cjs.js\");\n\n\n\n\n\n\n\n\n\nvar Me = { exports: {} }, re = {};\n/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar at;\nfunction Hr() {\n  if (at)\n    return re;\n  at = 1;\n  var e = react__WEBPACK_IMPORTED_MODULE_0__, n = Symbol.for(\"react.element\"), o = Symbol.for(\"react.fragment\"), i = Object.prototype.hasOwnProperty, s = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, c = { key: !0, ref: !0, __self: !0, __source: !0 };\n  function u(g, a, y) {\n    var h, p = {}, S = null, T = null;\n    y !== void 0 && (S = \"\" + y), a.key !== void 0 && (S = \"\" + a.key), a.ref !== void 0 && (T = a.ref);\n    for (h in a)\n      i.call(a, h) && !c.hasOwnProperty(h) && (p[h] = a[h]);\n    if (g && g.defaultProps)\n      for (h in a = g.defaultProps, a)\n        p[h] === void 0 && (p[h] = a[h]);\n    return { $$typeof: n, type: g, key: S, ref: T, props: p, _owner: s.current };\n  }\n  return re.Fragment = o, re.jsx = u, re.jsxs = u, re;\n}\nvar ne = {};\n/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar lt;\nfunction Ir() {\n  return lt || (lt = 1,  true && function() {\n    var e = react__WEBPACK_IMPORTED_MODULE_0__, n = Symbol.for(\"react.element\"), o = Symbol.for(\"react.portal\"), i = Symbol.for(\"react.fragment\"), s = Symbol.for(\"react.strict_mode\"), c = Symbol.for(\"react.profiler\"), u = Symbol.for(\"react.provider\"), g = Symbol.for(\"react.context\"), a = Symbol.for(\"react.forward_ref\"), y = Symbol.for(\"react.suspense\"), h = Symbol.for(\"react.suspense_list\"), p = Symbol.for(\"react.memo\"), S = Symbol.for(\"react.lazy\"), T = Symbol.for(\"react.offscreen\"), D = Symbol.iterator, le = \"@@iterator\";\n    function Bt(t) {\n      if (t === null || typeof t != \"object\")\n        return null;\n      var l = D && t[D] || t[le];\n      return typeof l == \"function\" ? l : null;\n    }\n    var J = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n    function H(t) {\n      {\n        for (var l = arguments.length, d = new Array(l > 1 ? l - 1 : 0), f = 1; f < l; f++)\n          d[f - 1] = arguments[f];\n        _t(\"error\", t, d);\n      }\n    }\n    function _t(t, l, d) {\n      {\n        var f = J.ReactDebugCurrentFrame, m = f.getStackAddendum();\n        m !== \"\" && (l += \"%s\", d = d.concat([m]));\n        var C = d.map(function(b) {\n          return String(b);\n        });\n        C.unshift(\"Warning: \" + l), Function.prototype.apply.call(console[t], console, C);\n      }\n    }\n    var Dt = !1, Pt = !1, Ot = !1, Ft = !1, At = !1, De;\n    De = Symbol.for(\"react.module.reference\");\n    function Lt(t) {\n      return !!(typeof t == \"string\" || typeof t == \"function\" || t === i || t === c || At || t === s || t === y || t === h || Ft || t === T || Dt || Pt || Ot || typeof t == \"object\" && t !== null && (t.$$typeof === S || t.$$typeof === p || t.$$typeof === u || t.$$typeof === g || t.$$typeof === a || // This needs to include all possible module reference object\n      // types supported by any Flight configuration anywhere since\n      // we don't know which Flight build this will end up being used\n      // with.\n      t.$$typeof === De || t.getModuleId !== void 0));\n    }\n    function Vt(t, l, d) {\n      var f = t.displayName;\n      if (f)\n        return f;\n      var m = l.displayName || l.name || \"\";\n      return m !== \"\" ? d + \"(\" + m + \")\" : d;\n    }\n    function Pe(t) {\n      return t.displayName || \"Context\";\n    }\n    function V(t) {\n      if (t == null)\n        return null;\n      if (typeof t.tag == \"number\" && H(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"), typeof t == \"function\")\n        return t.displayName || t.name || null;\n      if (typeof t == \"string\")\n        return t;\n      switch (t) {\n        case i:\n          return \"Fragment\";\n        case o:\n          return \"Portal\";\n        case c:\n          return \"Profiler\";\n        case s:\n          return \"StrictMode\";\n        case y:\n          return \"Suspense\";\n        case h:\n          return \"SuspenseList\";\n      }\n      if (typeof t == \"object\")\n        switch (t.$$typeof) {\n          case g:\n            var l = t;\n            return Pe(l) + \".Consumer\";\n          case u:\n            var d = t;\n            return Pe(d._context) + \".Provider\";\n          case a:\n            return Vt(t, t.render, \"ForwardRef\");\n          case p:\n            var f = t.displayName || null;\n            return f !== null ? f : V(t.type) || \"Memo\";\n          case S: {\n            var m = t, C = m._payload, b = m._init;\n            try {\n              return V(b(C));\n            } catch {\n              return null;\n            }\n          }\n        }\n      return null;\n    }\n    var K = Object.assign, ee = 0, Oe, Fe, Ae, Le, Ve, Ue, Ne;\n    function $e() {\n    }\n    $e.__reactDisabledLog = !0;\n    function Ut() {\n      {\n        if (ee === 0) {\n          Oe = console.log, Fe = console.info, Ae = console.warn, Le = console.error, Ve = console.group, Ue = console.groupCollapsed, Ne = console.groupEnd;\n          var t = {\n            configurable: !0,\n            enumerable: !0,\n            value: $e,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            info: t,\n            log: t,\n            warn: t,\n            error: t,\n            group: t,\n            groupCollapsed: t,\n            groupEnd: t\n          });\n        }\n        ee++;\n      }\n    }\n    function Nt() {\n      {\n        if (ee--, ee === 0) {\n          var t = {\n            configurable: !0,\n            enumerable: !0,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            log: K({}, t, {\n              value: Oe\n            }),\n            info: K({}, t, {\n              value: Fe\n            }),\n            warn: K({}, t, {\n              value: Ae\n            }),\n            error: K({}, t, {\n              value: Le\n            }),\n            group: K({}, t, {\n              value: Ve\n            }),\n            groupCollapsed: K({}, t, {\n              value: Ue\n            }),\n            groupEnd: K({}, t, {\n              value: Ne\n            })\n          });\n        }\n        ee < 0 && H(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\n      }\n    }\n    var me = J.ReactCurrentDispatcher, ke;\n    function ce(t, l, d) {\n      {\n        if (ke === void 0)\n          try {\n            throw Error();\n          } catch (m) {\n            var f = m.stack.trim().match(/\\n( *(at )?)/);\n            ke = f && f[1] || \"\";\n          }\n        return `\n` + ke + t;\n      }\n    }\n    var ye = !1, se;\n    {\n      var $t = typeof WeakMap == \"function\" ? WeakMap : Map;\n      se = new $t();\n    }\n    function We(t, l) {\n      if (!t || ye)\n        return \"\";\n      {\n        var d = se.get(t);\n        if (d !== void 0)\n          return d;\n      }\n      var f;\n      ye = !0;\n      var m = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var C;\n      C = me.current, me.current = null, Ut();\n      try {\n        if (l) {\n          var b = function() {\n            throw Error();\n          };\n          if (Object.defineProperty(b.prototype, \"props\", {\n            set: function() {\n              throw Error();\n            }\n          }), typeof Reflect == \"object\" && Reflect.construct) {\n            try {\n              Reflect.construct(b, []);\n            } catch (U) {\n              f = U;\n            }\n            Reflect.construct(t, [], b);\n          } else {\n            try {\n              b.call();\n            } catch (U) {\n              f = U;\n            }\n            t.call(b.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (U) {\n            f = U;\n          }\n          t();\n        }\n      } catch (U) {\n        if (U && f && typeof U.stack == \"string\") {\n          for (var v = U.stack.split(`\n`), I = f.stack.split(`\n`), M = v.length - 1, E = I.length - 1; M >= 1 && E >= 0 && v[M] !== I[E]; )\n            E--;\n          for (; M >= 1 && E >= 0; M--, E--)\n            if (v[M] !== I[E]) {\n              if (M !== 1 || E !== 1)\n                do\n                  if (M--, E--, E < 0 || v[M] !== I[E]) {\n                    var _ = `\n` + v[M].replace(\" at new \", \" at \");\n                    return t.displayName && _.includes(\"<anonymous>\") && (_ = _.replace(\"<anonymous>\", t.displayName)), typeof t == \"function\" && se.set(t, _), _;\n                  }\n                while (M >= 1 && E >= 0);\n              break;\n            }\n        }\n      } finally {\n        ye = !1, me.current = C, Nt(), Error.prepareStackTrace = m;\n      }\n      var Z = t ? t.displayName || t.name : \"\", ot = Z ? ce(Z) : \"\";\n      return typeof t == \"function\" && se.set(t, ot), ot;\n    }\n    function Wt(t, l, d) {\n      return We(t, !1);\n    }\n    function Yt(t) {\n      var l = t.prototype;\n      return !!(l && l.isReactComponent);\n    }\n    function de(t, l, d) {\n      if (t == null)\n        return \"\";\n      if (typeof t == \"function\")\n        return We(t, Yt(t));\n      if (typeof t == \"string\")\n        return ce(t);\n      switch (t) {\n        case y:\n          return ce(\"Suspense\");\n        case h:\n          return ce(\"SuspenseList\");\n      }\n      if (typeof t == \"object\")\n        switch (t.$$typeof) {\n          case a:\n            return Wt(t.render);\n          case p:\n            return de(t.type, l, d);\n          case S: {\n            var f = t, m = f._payload, C = f._init;\n            try {\n              return de(C(m), l, d);\n            } catch {\n            }\n          }\n        }\n      return \"\";\n    }\n    var ue = Object.prototype.hasOwnProperty, Ye = {}, qe = J.ReactDebugCurrentFrame;\n    function ge(t) {\n      if (t) {\n        var l = t._owner, d = de(t.type, t._source, l ? l.type : null);\n        qe.setExtraStackFrame(d);\n      } else\n        qe.setExtraStackFrame(null);\n    }\n    function qt(t, l, d, f, m) {\n      {\n        var C = Function.call.bind(ue);\n        for (var b in t)\n          if (C(t, b)) {\n            var v = void 0;\n            try {\n              if (typeof t[b] != \"function\") {\n                var I = Error((f || \"React class\") + \": \" + d + \" type `\" + b + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof t[b] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                throw I.name = \"Invariant Violation\", I;\n              }\n              v = t[b](l, b, f, d, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n            } catch (M) {\n              v = M;\n            }\n            v && !(v instanceof Error) && (ge(m), H(\"%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\", f || \"React class\", d, b, typeof v), ge(null)), v instanceof Error && !(v.message in Ye) && (Ye[v.message] = !0, ge(m), H(\"Failed %s type: %s\", d, v.message), ge(null));\n          }\n      }\n    }\n    var Kt = Array.isArray;\n    function pe(t) {\n      return Kt(t);\n    }\n    function Gt(t) {\n      {\n        var l = typeof Symbol == \"function\" && Symbol.toStringTag, d = l && t[Symbol.toStringTag] || t.constructor.name || \"Object\";\n        return d;\n      }\n    }\n    function Jt(t) {\n      try {\n        return Ke(t), !1;\n      } catch {\n        return !0;\n      }\n    }\n    function Ke(t) {\n      return \"\" + t;\n    }\n    function Ge(t) {\n      if (Jt(t))\n        return H(\"The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.\", Gt(t)), Ke(t);\n    }\n    var te = J.ReactCurrentOwner, Xt = {\n      key: !0,\n      ref: !0,\n      __self: !0,\n      __source: !0\n    }, Je, Xe, Ce;\n    Ce = {};\n    function Zt(t) {\n      if (ue.call(t, \"ref\")) {\n        var l = Object.getOwnPropertyDescriptor(t, \"ref\").get;\n        if (l && l.isReactWarning)\n          return !1;\n      }\n      return t.ref !== void 0;\n    }\n    function Qt(t) {\n      if (ue.call(t, \"key\")) {\n        var l = Object.getOwnPropertyDescriptor(t, \"key\").get;\n        if (l && l.isReactWarning)\n          return !1;\n      }\n      return t.key !== void 0;\n    }\n    function er(t, l) {\n      if (typeof t.ref == \"string\" && te.current && l && te.current.stateNode !== l) {\n        var d = V(te.current.type);\n        Ce[d] || (H('Component \"%s\" contains the string ref \"%s\". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', V(te.current.type), t.ref), Ce[d] = !0);\n      }\n    }\n    function tr(t, l) {\n      {\n        var d = function() {\n          Je || (Je = !0, H(\"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", l));\n        };\n        d.isReactWarning = !0, Object.defineProperty(t, \"key\", {\n          get: d,\n          configurable: !0\n        });\n      }\n    }\n    function rr(t, l) {\n      {\n        var d = function() {\n          Xe || (Xe = !0, H(\"%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", l));\n        };\n        d.isReactWarning = !0, Object.defineProperty(t, \"ref\", {\n          get: d,\n          configurable: !0\n        });\n      }\n    }\n    var nr = function(t, l, d, f, m, C, b) {\n      var v = {\n        // This tag allows us to uniquely identify this as a React Element\n        $$typeof: n,\n        // Built-in properties that belong on the element\n        type: t,\n        key: l,\n        ref: d,\n        props: b,\n        // Record the component responsible for creating this element.\n        _owner: C\n      };\n      return v._store = {}, Object.defineProperty(v._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: !1\n      }), Object.defineProperty(v, \"_self\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: f\n      }), Object.defineProperty(v, \"_source\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: m\n      }), Object.freeze && (Object.freeze(v.props), Object.freeze(v)), v;\n    };\n    function or(t, l, d, f, m) {\n      {\n        var C, b = {}, v = null, I = null;\n        d !== void 0 && (Ge(d), v = \"\" + d), Qt(l) && (Ge(l.key), v = \"\" + l.key), Zt(l) && (I = l.ref, er(l, m));\n        for (C in l)\n          ue.call(l, C) && !Xt.hasOwnProperty(C) && (b[C] = l[C]);\n        if (t && t.defaultProps) {\n          var M = t.defaultProps;\n          for (C in M)\n            b[C] === void 0 && (b[C] = M[C]);\n        }\n        if (v || I) {\n          var E = typeof t == \"function\" ? t.displayName || t.name || \"Unknown\" : t;\n          v && tr(b, E), I && rr(b, E);\n        }\n        return nr(t, v, I, m, f, te.current, b);\n      }\n    }\n    var je = J.ReactCurrentOwner, Ze = J.ReactDebugCurrentFrame;\n    function X(t) {\n      if (t) {\n        var l = t._owner, d = de(t.type, t._source, l ? l.type : null);\n        Ze.setExtraStackFrame(d);\n      } else\n        Ze.setExtraStackFrame(null);\n    }\n    var Te;\n    Te = !1;\n    function we(t) {\n      return typeof t == \"object\" && t !== null && t.$$typeof === n;\n    }\n    function Qe() {\n      {\n        if (je.current) {\n          var t = V(je.current.type);\n          if (t)\n            return `\n\nCheck the render method of \\`` + t + \"`.\";\n        }\n        return \"\";\n      }\n    }\n    function ir(t) {\n      {\n        if (t !== void 0) {\n          var l = t.fileName.replace(/^.*[\\\\\\/]/, \"\"), d = t.lineNumber;\n          return `\n\nCheck your code at ` + l + \":\" + d + \".\";\n        }\n        return \"\";\n      }\n    }\n    var et = {};\n    function ar(t) {\n      {\n        var l = Qe();\n        if (!l) {\n          var d = typeof t == \"string\" ? t : t.displayName || t.name;\n          d && (l = `\n\nCheck the top-level render call using <` + d + \">.\");\n        }\n        return l;\n      }\n    }\n    function tt(t, l) {\n      {\n        if (!t._store || t._store.validated || t.key != null)\n          return;\n        t._store.validated = !0;\n        var d = ar(l);\n        if (et[d])\n          return;\n        et[d] = !0;\n        var f = \"\";\n        t && t._owner && t._owner !== je.current && (f = \" It was passed a child from \" + V(t._owner.type) + \".\"), X(t), H('Each child in a list should have a unique \"key\" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', d, f), X(null);\n      }\n    }\n    function rt(t, l) {\n      {\n        if (typeof t != \"object\")\n          return;\n        if (pe(t))\n          for (var d = 0; d < t.length; d++) {\n            var f = t[d];\n            we(f) && tt(f, l);\n          }\n        else if (we(t))\n          t._store && (t._store.validated = !0);\n        else if (t) {\n          var m = Bt(t);\n          if (typeof m == \"function\" && m !== t.entries)\n            for (var C = m.call(t), b; !(b = C.next()).done; )\n              we(b.value) && tt(b.value, l);\n        }\n      }\n    }\n    function lr(t) {\n      {\n        var l = t.type;\n        if (l == null || typeof l == \"string\")\n          return;\n        var d;\n        if (typeof l == \"function\")\n          d = l.propTypes;\n        else if (typeof l == \"object\" && (l.$$typeof === a || // Note: Memo only checks outer props here.\n        // Inner props are checked in the reconciler.\n        l.$$typeof === p))\n          d = l.propTypes;\n        else\n          return;\n        if (d) {\n          var f = V(l);\n          qt(d, t.props, \"prop\", f, t);\n        } else if (l.PropTypes !== void 0 && !Te) {\n          Te = !0;\n          var m = V(l);\n          H(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", m || \"Unknown\");\n        }\n        typeof l.getDefaultProps == \"function\" && !l.getDefaultProps.isReactClassApproved && H(\"getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.\");\n      }\n    }\n    function cr(t) {\n      {\n        for (var l = Object.keys(t.props), d = 0; d < l.length; d++) {\n          var f = l[d];\n          if (f !== \"children\" && f !== \"key\") {\n            X(t), H(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\", f), X(null);\n            break;\n          }\n        }\n        t.ref !== null && (X(t), H(\"Invalid attribute `ref` supplied to `React.Fragment`.\"), X(null));\n      }\n    }\n    function nt(t, l, d, f, m, C) {\n      {\n        var b = Lt(t);\n        if (!b) {\n          var v = \"\";\n          (t === void 0 || typeof t == \"object\" && t !== null && Object.keys(t).length === 0) && (v += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\");\n          var I = ir(m);\n          I ? v += I : v += Qe();\n          var M;\n          t === null ? M = \"null\" : pe(t) ? M = \"array\" : t !== void 0 && t.$$typeof === n ? (M = \"<\" + (V(t.type) || \"Unknown\") + \" />\", v = \" Did you accidentally export a JSX literal instead of a component?\") : M = typeof t, H(\"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\", M, v);\n        }\n        var E = or(t, l, d, m, C);\n        if (E == null)\n          return E;\n        if (b) {\n          var _ = l.children;\n          if (_ !== void 0)\n            if (f)\n              if (pe(_)) {\n                for (var Z = 0; Z < _.length; Z++)\n                  rt(_[Z], t);\n                Object.freeze && Object.freeze(_);\n              } else\n                H(\"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\");\n            else\n              rt(_, t);\n        }\n        return t === i ? cr(E) : lr(E), E;\n      }\n    }\n    function sr(t, l, d) {\n      return nt(t, l, d, !0);\n    }\n    function dr(t, l, d) {\n      return nt(t, l, d, !1);\n    }\n    var ur = dr, gr = sr;\n    ne.Fragment = i, ne.jsx = ur, ne.jsxs = gr;\n  }()), ne;\n}\n false ? 0 : Me.exports = Ir();\nvar r = Me.exports;\nconst fe = (e) => {\n  const n = `0 4px 12px ${e.colors.shadow}`, o = `1px solid ${e.colors.border}`, i = {\n    default: e.colors.editor.text,\n    gray: e.colors.highlightColors.gray.text,\n    brown: e.colors.highlightColors.brown.text,\n    red: e.colors.highlightColors.red.text,\n    orange: e.colors.highlightColors.orange.text,\n    yellow: e.colors.highlightColors.yellow.text,\n    green: e.colors.highlightColors.green.text,\n    blue: e.colors.highlightColors.blue.text,\n    purple: e.colors.highlightColors.purple.text,\n    pink: e.colors.highlightColors.pink.text\n  }, s = {\n    default: e.colors.editor.background,\n    gray: e.colors.highlightColors.gray.background,\n    brown: e.colors.highlightColors.brown.background,\n    red: e.colors.highlightColors.red.background,\n    orange: e.colors.highlightColors.orange.background,\n    yellow: e.colors.highlightColors.yellow.background,\n    green: e.colors.highlightColors.green.background,\n    blue: e.colors.highlightColors.blue.background,\n    purple: e.colors.highlightColors.purple.background,\n    pink: e.colors.highlightColors.pink.background\n  }, c = `${Math.max(e.borderRadius + 2, 1)}px`, u = `${e.borderRadius}px`, g = `${Math.max(e.borderRadius - 2, 1)}px`;\n  return {\n    activeStyles: {\n      // Removes button press effect.\n      transform: \"none\"\n    },\n    components: {\n      // Slash Menu, Formatting Toolbar dropdown, color picker dropdown\n      Menu: {\n        styles: () => {\n          var a;\n          return {\n            dropdown: lodash__WEBPACK_IMPORTED_MODULE_3__.merge(\n              {\n                backgroundColor: e.colors.menu.background,\n                border: o,\n                borderRadius: u,\n                boxShadow: n,\n                color: e.colors.menu.text,\n                padding: \"2px\",\n                overflowY: \"scroll\",\n                \".mantine-Menu-label\": {\n                  backgroundColor: e.colors.menu.background,\n                  color: e.colors.menu.text\n                },\n                \".mantine-Menu-item\": {\n                  backgroundColor: e.colors.menu.background,\n                  border: \"none\",\n                  borderRadius: g,\n                  color: e.colors.menu.text\n                },\n                \".mantine-Menu-item[data-hovered]\": {\n                  backgroundColor: e.colors.hovered.background,\n                  border: \"none\",\n                  color: e.colors.hovered.text\n                }\n              },\n              ((a = e.componentStyles) == null ? void 0 : a.call(e, e).Menu) || {}\n            )\n          };\n        }\n      },\n      Tabs: {\n        styles: () => {\n          var a;\n          return {\n            root: lodash__WEBPACK_IMPORTED_MODULE_3__.merge(\n              {\n                width: \"100%\",\n                backgroundColor: e.colors.menu.background\n              },\n              ((a = e.componentStyles) == null ? void 0 : a.call(e, e).Tabs) || {}\n            ),\n            tabsList: {\n              borderColor: e.colors.hovered.background\n            },\n            tab: {\n              color: e.colors.menu.text,\n              borderColor: e.colors.hovered.background,\n              \"&:hover\": {\n                color: e.colors.hovered.text,\n                backgroundColor: e.colors.hovered.background,\n                borderColor: e.colors.hovered.background\n              },\n              \"&[data-active], &[data-active]&:hover\": {\n                color: e.colors.menu.text,\n                borderColor: e.colors.menu.text\n              }\n            },\n            panel: {\n              padding: \"8px\",\n              \".mantine-UnstyledButton-root\": {\n                width: \"60%\",\n                border: `solid ${e.colors.border} 1px`,\n                borderRadius: \"4px\",\n                height: \"32px\"\n              },\n              \".mantine-UnstyledButton-root:hover\": {\n                color: e.colors.hovered.text,\n                backgroundColor: e.colors.hovered.background\n              }\n            }\n          };\n        }\n      },\n      FileInput: {\n        styles: () => {\n          var a;\n          return {\n            root: ((a = e.componentStyles) == null ? void 0 : a.call(e, e).FileInput) || {},\n            input: {\n              color: e.colors.menu.text,\n              backgroundColor: e.colors.menu.background,\n              display: \"flex\",\n              flexDirection: \"row\",\n              alignItems: \"center\",\n              justifyContent: \"center\",\n              border: \"none\",\n              borderRadius: \"4px\",\n              \"&:hover\": {\n                backgroundColor: e.colors.hovered.background\n              }\n            },\n            wrapper: {\n              border: `solid ${e.colors.border} 1px`,\n              borderRadius: \"4px\"\n            },\n            placeholder: {\n              color: `${e.colors.menu.text} !important`,\n              fontWeight: 600\n            }\n          };\n        }\n      },\n      TextInput: {\n        styles: () => {\n          var a;\n          return {\n            root: ((a = e.componentStyles) == null ? void 0 : a.call(e, e).TextInput) || {},\n            input: {\n              color: e.colors.menu.text,\n              backgroundColor: e.colors.menu.background,\n              border: `solid ${e.colors.border} 1px`,\n              borderRadius: \"4px\",\n              height: \"32px\"\n            }\n          };\n        }\n      },\n      ColorIcon: {\n        styles: () => {\n          var a;\n          return {\n            root: lodash__WEBPACK_IMPORTED_MODULE_3__.merge(\n              {\n                border: o,\n                borderRadius: g\n              },\n              ((a = e.componentStyles) == null ? void 0 : a.call(e, e).ColorIcon) || {}\n            )\n          };\n        }\n      },\n      DragHandleMenu: {\n        styles: () => {\n          var a;\n          return {\n            root: lodash__WEBPACK_IMPORTED_MODULE_3__.merge(\n              {\n                \".mantine-Menu-item\": {\n                  fontSize: \"12px\",\n                  height: \"30px\"\n                }\n              },\n              ((a = e.componentStyles) == null ? void 0 : a.call(e, e).DragHandleMenu) || {}\n            )\n          };\n        }\n      },\n      Editor: {\n        styles: () => {\n          var a;\n          return {\n            root: lodash__WEBPACK_IMPORTED_MODULE_3__.merge(\n              {\n                \".ProseMirror\": {\n                  backgroundColor: e.colors.editor.background,\n                  borderRadius: c,\n                  color: e.colors.editor.text,\n                  fontFamily: e.fontFamily\n                },\n                // Placeholders\n                [`.${_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.blockStyles.isEmpty} .${_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.blockStyles.inlineContent}:before, .${_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.blockStyles.isFilter} .${_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.blockStyles.inlineContent}:before`]: {\n                  color: e.colors.sideMenu\n                },\n                // Indent lines\n                [`.${_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.blockStyles.blockGroup}`]: {\n                  [`.${_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.blockStyles.blockGroup}`]: {\n                    [`.${_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.blockStyles.blockOuter}:not([data-prev-depth-changed])::before`]: {\n                      borderLeft: `1px solid ${e.colors.sideMenu}`\n                    }\n                  }\n                },\n                // Highlight text colors\n                ...Object.fromEntries(\n                  Object.entries(i).map(([y, h]) => [\n                    `[data-text-color=\"${y}\"]`,\n                    { color: h }\n                  ])\n                ),\n                // Highlight background colors\n                ...Object.fromEntries(\n                  Object.entries(s).map(([y, h]) => [\n                    `[data-background-color=\"${y}\"]`,\n                    { backgroundColor: h }\n                  ])\n                )\n              },\n              ((a = e.componentStyles) == null ? void 0 : a.call(e, e).Editor) || {}\n            )\n          };\n        }\n      },\n      Toolbar: {\n        styles: () => {\n          var a;\n          return {\n            root: lodash__WEBPACK_IMPORTED_MODULE_3__.merge(\n              {\n                backgroundColor: e.colors.menu.background,\n                boxShadow: n,\n                border: o,\n                borderRadius: u,\n                flexWrap: \"nowrap\",\n                gap: \"2px\",\n                padding: \"2px\",\n                width: \"fit-content\",\n                // Button (including dropdown target)\n                \".mantine-Button-root, .mantine-ActionIcon-root\": {\n                  backgroundColor: e.colors.menu.background,\n                  border: \"none\",\n                  borderRadius: g,\n                  color: e.colors.menu.text\n                },\n                // Hovered button\n                \".mantine-Button-root:hover, .mantine-ActionIcon-root:hover\": {\n                  backgroundColor: e.colors.hovered.background,\n                  border: \"none\",\n                  color: e.colors.hovered.text\n                },\n                // Selected button\n                \".mantine-Button-root[data-selected], .mantine-ActionIcon-root[data-selected]\": {\n                  backgroundColor: e.colors.selected.background,\n                  border: \"none\",\n                  color: e.colors.selected.text\n                },\n                // Disabled button\n                \".mantine-Button-root[data-disabled], .mantine-ActionIcon-root[data-disabled]\": {\n                  backgroundColor: e.colors.disabled.background,\n                  border: \"none\",\n                  color: e.colors.disabled.text\n                },\n                // Dropdown\n                \".mantine-Menu-dropdown\": {\n                  // Dropdown item\n                  \".mantine-Menu-item\": {\n                    fontSize: \"12px\",\n                    height: \"30px\",\n                    \".mantine-Menu-itemRightSection\": {\n                      paddingLeft: \"5px\"\n                    }\n                  },\n                  \".mantine-Menu-item:hover\": {\n                    backgroundColor: e.colors.hovered.background\n                  }\n                }\n              },\n              ((a = e.componentStyles) == null ? void 0 : a.call(e, e).Toolbar) || {}\n            )\n          };\n        }\n      },\n      ToolbarInputDropdown: {\n        styles: () => {\n          var a;\n          return {\n            root: lodash__WEBPACK_IMPORTED_MODULE_3__.merge(\n              {\n                backgroundColor: e.colors.menu.background,\n                border: o,\n                borderRadius: u,\n                boxShadow: n,\n                color: e.colors.menu.text,\n                gap: \"4px\",\n                minWidth: \"145px\",\n                padding: \"2px\",\n                // Row\n                \".mantine-Group-root\": {\n                  flexWrap: \"nowrap\",\n                  // Row input field\n                  \".mantine-TextInput-root, .mantine-FileInput-root\": {\n                    width: \"300px\",\n                    \".mantine-TextInput-wrapper:hover\": {\n                      backgroundColor: e.colors.hovered.background\n                    },\n                    \".mantine-TextInput-wrapper, .mantine-FileInput-wrapper\": {\n                      padding: 0,\n                      borderRadius: \"4px\",\n                      \".mantine-FileInput-icon\": {\n                        color: e.colors.menu.text\n                      },\n                      \".mantine-TextInput-input, .mantine-FileInput-input\": {\n                        border: \"none\",\n                        fontSize: \"12px\",\n                        \".mantine-FileInput-placeholder\": {\n                          color: e.colors.menu.text\n                        }\n                      },\n                      \".mantine-FileInput-input:hover\": {\n                        backgroundColor: e.colors.hovered.background\n                      }\n                    }\n                  }\n                }\n              },\n              ((a = e.componentStyles) == null ? void 0 : a.call(e, e).EditHyperlinkMenu) || {}\n            )\n          };\n        }\n      },\n      Tooltip: {\n        styles: () => {\n          var a;\n          return {\n            root: lodash__WEBPACK_IMPORTED_MODULE_3__.merge(\n              {\n                backgroundColor: e.colors.tooltip.background,\n                border: o,\n                borderRadius: u,\n                boxShadow: n,\n                color: e.colors.tooltip.text,\n                padding: \"4px 10px\",\n                textAlign: \"center\",\n                \"div ~ div\": {\n                  color: e.colors.tooltip.text\n                }\n              },\n              ((a = e.componentStyles) == null ? void 0 : a.call(e, e).Tooltip) || {}\n            )\n          };\n        }\n      },\n      SlashMenu: {\n        styles: () => {\n          var a;\n          return {\n            root: lodash__WEBPACK_IMPORTED_MODULE_3__.merge(\n              {\n                position: \"relative\",\n                \".mantine-Menu-item\": {\n                  // Icon\n                  \".mantine-Menu-itemIcon\": {\n                    backgroundColor: e.colors.tooltip.background,\n                    borderRadius: g,\n                    color: e.colors.tooltip.text,\n                    padding: \"8px\"\n                  },\n                  // Text\n                  \".mantine-Menu-itemLabel\": {\n                    paddingRight: \"16px\",\n                    \".mantine-Stack-root\": {\n                      gap: \"0\"\n                    }\n                  },\n                  // Badge (keyboard shortcut)\n                  \".mantine-Menu-itemRightSection\": {\n                    \".mantine-Badge-root\": {\n                      backgroundColor: e.colors.tooltip.background,\n                      color: e.colors.tooltip.text\n                    }\n                  }\n                }\n              },\n              ((a = e.componentStyles) == null ? void 0 : a.call(e, e).SlashMenu) || {}\n            )\n          };\n        }\n      },\n      SideMenu: {\n        styles: () => {\n          var a;\n          return {\n            root: lodash__WEBPACK_IMPORTED_MODULE_3__.merge(\n              {\n                backgroundColor: \"transparent\",\n                \".mantine-UnstyledButton-root\": {\n                  backgroundColor: \"transparent\",\n                  color: e.colors.sideMenu\n                },\n                \".mantine-UnstyledButton-root:hover\": {\n                  backgroundColor: e.colors.hovered.background\n                }\n              },\n              ((a = e.componentStyles) == null ? void 0 : a.call(e, e).SideMenu) || {}\n            )\n          };\n        }\n      }\n    },\n    fontFamily: e.fontFamily,\n    other: {\n      textColors: i,\n      backgroundColors: s\n    }\n  };\n}, _e = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((e, n) => {\n  const { classes: o } = (0,_mantine_core__WEBPACK_IMPORTED_MODULE_4__.createStyles)({ root: {} })(void 0, {\n    name: \"Toolbar\"\n  });\n  return /* @__PURE__ */ r.jsx(\n    _mantine_core__WEBPACK_IMPORTED_MODULE_4__.Group,\n    {\n      className: e.className ? `${o.root} ${e.className}` : o.root,\n      ref: n,\n      ...e,\n      children: e.children\n    }\n  );\n});\nvar xt = {\n  color: void 0,\n  size: void 0,\n  className: void 0,\n  style: void 0,\n  attr: void 0\n}, ct = react__WEBPACK_IMPORTED_MODULE_0__.createContext && react__WEBPACK_IMPORTED_MODULE_0__.createContext(xt), W = globalThis && globalThis.__assign || function() {\n  return W = Object.assign || function(e) {\n    for (var n, o = 1, i = arguments.length; o < i; o++) {\n      n = arguments[o];\n      for (var s in n)\n        Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s]);\n    }\n    return e;\n  }, W.apply(this, arguments);\n}, Br = globalThis && globalThis.__rest || function(e, n) {\n  var o = {};\n  for (var i in e)\n    Object.prototype.hasOwnProperty.call(e, i) && n.indexOf(i) < 0 && (o[i] = e[i]);\n  if (e != null && typeof Object.getOwnPropertySymbols == \"function\")\n    for (var s = 0, i = Object.getOwnPropertySymbols(e); s < i.length; s++)\n      n.indexOf(i[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[s]) && (o[i[s]] = e[i[s]]);\n  return o;\n};\nfunction mt(e) {\n  return e && e.map(function(n, o) {\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(n.tag, W({\n      key: o\n    }, n.attr), mt(n.child));\n  });\n}\nfunction j(e) {\n  return function(n) {\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_r, W({\n      attr: W({}, e.attr)\n    }, n), mt(e.child));\n  };\n}\nfunction _r(e) {\n  var n = function(o) {\n    var i = e.attr, s = e.size, c = e.title, u = Br(e, [\"attr\", \"size\", \"title\"]), g = s || o.size || \"1em\", a;\n    return o.className && (a = o.className), e.className && (a = (a ? a + \" \" : \"\") + e.className), react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", W({\n      stroke: \"currentColor\",\n      fill: \"currentColor\",\n      strokeWidth: \"0\"\n    }, o.attr, i, u, {\n      className: a,\n      style: W(W({\n        color: e.color || o.color\n      }, o.style), e.style),\n      height: g,\n      width: g,\n      xmlns: \"http://www.w3.org/2000/svg\"\n    }), c && react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"title\", null, c), e.children);\n  };\n  return ct !== void 0 ? react__WEBPACK_IMPORTED_MODULE_0__.createElement(ct.Consumer, null, function(o) {\n    return n(o);\n  }) : n(xt);\n}\nfunction Dr(e) {\n  return j({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"g\", attr: {}, child: [{ tag: \"path\", attr: { fill: \"none\", d: \"M0 0h24v24H0z\" } }, { tag: \"path\", attr: { d: \"M23 12l-7.071 7.071-1.414-1.414L20.172 12l-5.657-5.657 1.414-1.414L23 12zM3.828 12l5.657 5.657-1.414 1.414L1 12l7.071-7.071 1.414 1.414L3.828 12z\" } }] }] })(e);\n}\nfunction Pr(e) {\n  return j({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"g\", attr: {}, child: [{ tag: \"path\", attr: { fill: \"none\", d: \"M0 0h24v24H0z\" } }, { tag: \"path\", attr: { d: \"M3 4h18v2H3V4zm2 15h14v2H5v-2zm-2-5h18v2H3v-2zm2-5h14v2H5V9z\" } }] }] })(e);\n}\nfunction Or(e) {\n  return j({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"g\", attr: {}, child: [{ tag: \"path\", attr: { fill: \"none\", d: \"M0 0h24v24H0z\" } }, { tag: \"path\", attr: { d: \"M3 4h18v2H3V4zm0 15h18v2H3v-2zm0-5h18v2H3v-2zm0-5h18v2H3V9z\" } }] }] })(e);\n}\nfunction Fr(e) {\n  return j({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"g\", attr: {}, child: [{ tag: \"path\", attr: { fill: \"none\", d: \"M0 0h24v24H0z\" } }, { tag: \"path\", attr: { d: \"M3 4h18v2H3V4zm0 15h14v2H3v-2zm0-5h18v2H3v-2zm0-5h14v2H3V9z\" } }] }] })(e);\n}\nfunction Ar(e) {\n  return j({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"g\", attr: {}, child: [{ tag: \"path\", attr: { fill: \"none\", d: \"M0 0h24v24H0z\" } }, { tag: \"path\", attr: { d: \"M3 4h18v2H3V4zm4 15h14v2H7v-2zm-4-5h18v2H3v-2zm4-5h14v2H7V9z\" } }] }] })(e);\n}\nfunction Lr(e) {\n  return j({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"g\", attr: {}, child: [{ tag: \"path\", attr: { fill: \"none\", d: \"M0 0h24v24H0z\" } }, { tag: \"path\", attr: { d: \"M8 11h4.5a2.5 2.5 0 1 0 0-5H8v5zm10 4.5a4.5 4.5 0 0 1-4.5 4.5H6V4h6.5a4.5 4.5 0 0 1 3.256 7.606A4.498 4.498 0 0 1 18 15.5zM8 13v5h5.5a2.5 2.5 0 1 0 0-5H8z\" } }] }] })(e);\n}\nfunction kt(e) {\n  return j({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"g\", attr: {}, child: [{ tag: \"path\", attr: { fill: \"none\", d: \"M0 0H24V24H0z\" } }, { tag: \"path\", attr: { d: \"M13 20h-2v-7H4v7H2V4h2v7h7V4h2v16zm8-12v12h-2v-9.796l-2 .536V8.67L19.5 8H21z\" } }] }] })(e);\n}\nfunction yt(e) {\n  return j({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"g\", attr: {}, child: [{ tag: \"path\", attr: { fill: \"none\", d: \"M0 0H24V24H0z\" } }, { tag: \"path\", attr: { d: \"M4 4v7h7V4h2v16h-2v-7H4v7H2V4h2zm14.5 4c2.071 0 3.75 1.679 3.75 3.75 0 .857-.288 1.648-.772 2.28l-.148.18L18.034 18H22v2h-7v-1.556l4.82-5.546c.268-.307.43-.709.43-1.148 0-.966-.784-1.75-1.75-1.75-.918 0-1.671.707-1.744 1.606l-.006.144h-2C14.75 9.679 16.429 8 18.5 8z\" } }] }] })(e);\n}\nfunction pt(e) {\n  return j({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"g\", attr: {}, child: [{ tag: \"path\", attr: { fill: \"none\", d: \"M0 0H24V24H0z\" } }, { tag: \"path\", attr: { d: \"M22 8l-.002 2-2.505 2.883c1.59.435 2.757 1.89 2.757 3.617 0 2.071-1.679 3.75-3.75 3.75-1.826 0-3.347-1.305-3.682-3.033l1.964-.382c.156.806.866 1.415 1.718 1.415.966 0 1.75-.784 1.75-1.75s-.784-1.75-1.75-1.75c-.286 0-.556.069-.794.19l-1.307-1.547L19.35 10H15V8h7zM4 4v7h7V4h2v16h-2v-7H4v7H2V4h2z\" } }] }] })(e);\n}\nfunction Vr(e) {\n  return j({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"g\", attr: {}, child: [{ tag: \"path\", attr: { fill: \"none\", d: \"M0 0h24v24H0z\" } }, { tag: \"path\", attr: { d: \"M3 4h18v2H3V4zm0 15h18v2H3v-2zm8-5h10v2H11v-2zm0-5h10v2H11V9zm-8 3.5L7 9v7l-4-3.5z\" } }] }] })(e);\n}\nfunction Ur(e) {\n  return j({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"g\", attr: {}, child: [{ tag: \"path\", attr: { fill: \"none\", d: \"M0 0h24v24H0z\" } }, { tag: \"path\", attr: { d: \"M3 4h18v2H3V4zm0 15h18v2H3v-2zm8-5h10v2H11v-2zm0-5h10v2H11V9zm-4 3.5L3 16V9l4 3.5z\" } }] }] })(e);\n}\nfunction Nr(e) {\n  return j({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"g\", attr: {}, child: [{ tag: \"path\", attr: { fill: \"none\", d: \"M0 0h24v24H0z\" } }, { tag: \"path\", attr: { d: \"M15 20H7v-2h2.927l2.116-12H9V4h8v2h-2.927l-2.116 12H15z\" } }] }] })(e);\n}\nfunction $r(e) {\n  return j({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"g\", attr: {}, child: [{ tag: \"path\", attr: { fill: \"none\", d: \"M0 0h24v24H0z\" } }, { tag: \"path\", attr: { d: \"M17 17h5v2h-3v3h-2v-5zM7 7H2V5h3V2h2v5zm11.364 8.536L16.95 14.12l1.414-1.414a5 5 0 1 0-7.071-7.071L9.879 7.05 8.464 5.636 9.88 4.222a7 7 0 0 1 9.9 9.9l-1.415 1.414zm-2.828 2.828l-1.415 1.414a7 7 0 0 1-9.9-9.9l1.415-1.414L7.05 9.88l-1.414 1.414a5 5 0 1 0 7.071 7.071l1.414-1.414 1.415 1.414zm-.708-10.607l1.415 1.415-7.071 7.07-1.415-1.414 7.071-7.07z\" } }] }] })(e);\n}\nfunction Ct(e) {\n  return j({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"g\", attr: {}, child: [{ tag: \"path\", attr: { fill: \"none\", d: \"M0 0h24v24H0z\" } }, { tag: \"path\", attr: { d: \"M18.364 15.536L16.95 14.12l1.414-1.414a5 5 0 1 0-7.071-7.071L9.879 7.05 8.464 5.636 9.88 4.222a7 7 0 0 1 9.9 9.9l-1.415 1.414zm-2.828 2.828l-1.415 1.414a7 7 0 0 1-9.9-9.9l1.415-1.414L7.05 9.88l-1.414 1.414a5 5 0 1 0 7.071 7.071l1.414-1.414 1.415 1.414zm-.708-10.607l1.415 1.415-7.071 7.07-1.415-1.414 7.071-7.07z\" } }] }] })(e);\n}\nfunction jt(e) {\n  return j({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"g\", attr: {}, child: [{ tag: \"path\", attr: { fill: \"none\", d: \"M0 0h24v24H0z\" } }, { tag: \"path\", attr: { d: \"M8 4h13v2H8V4zM5 3v3h1v1H3V6h1V4H3V3h2zM3 14v-2.5h2V11H3v-1h3v2.5H4v.5h2v1H3zm2 5.5H3v-1h2V18H3v-1h3v4H3v-1h2v-.5zM8 11h13v2H8v-2zm0 7h13v2H8v-2z\" } }] }] })(e);\n}\nfunction Tt(e) {\n  return j({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"g\", attr: {}, child: [{ tag: \"path\", attr: { fill: \"none\", d: \"M0 0h24v24H0z\" } }, { tag: \"path\", attr: { d: \"M8 4h13v2H8V4zM4.5 6.5a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zm0 7a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zm0 6.9a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zM8 11h13v2H8v-2zm0 7h13v2H8v-2z\" } }] }] })(e);\n}\nfunction Wr(e) {\n  return j({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"g\", attr: {}, child: [{ tag: \"path\", attr: { fill: \"none\", d: \"M0 0h24v24H0z\" } }, { tag: \"path\", attr: { d: \"M17.154 14c.23.516.346 1.09.346 1.72 0 1.342-.524 2.392-1.571 3.147C14.88 19.622 13.433 20 11.586 20c-1.64 0-3.263-.381-4.87-1.144V16.6c1.52.877 3.075 1.316 4.666 1.316 2.551 0 3.83-.732 3.839-2.197a2.21 2.21 0 0 0-.648-1.603l-.12-.117H3v-2h18v2h-3.846zm-4.078-3H7.629a4.086 4.086 0 0 1-.481-.522C6.716 9.92 6.5 9.246 6.5 8.452c0-1.236.466-2.287 1.397-3.153C8.83 4.433 10.271 4 12.222 4c1.471 0 2.879.328 4.222.984v2.152c-1.2-.687-2.515-1.03-3.946-1.03-2.48 0-3.719.782-3.719 2.346 0 .42.218.786.654 1.099.436.313.974.562 1.613.75.62.18 1.297.414 2.03.699z\" } }] }] })(e);\n}\nfunction ie(e) {\n  return j({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"g\", attr: {}, child: [{ tag: \"path\", attr: { fill: \"none\", d: \"M0 0h24v24H0z\" } }, { tag: \"path\", attr: { d: \"M13 6v15h-2V6H5V4h14v2z\" } }] }] })(e);\n}\nfunction Yr(e) {\n  return j({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"g\", attr: {}, child: [{ tag: \"path\", attr: { fill: \"none\", d: \"M0 0h24v24H0z\" } }, { tag: \"path\", attr: { d: \"M8 3v9a4 4 0 1 0 8 0V3h2v9a6 6 0 1 1-12 0V3h2zM4 20h16v2H4v-2z\" } }] }] })(e);\n}\nfunction qr(e) {\n  return j({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"g\", attr: {}, child: [{ tag: \"path\", attr: { fill: \"none\", d: \"M0 0h24v24H0z\" } }, { tag: \"path\", attr: { d: \"M5 11.1l2-2 5.5 5.5 3.5-3.5 3 3V5H5v6.1zM4 3h16a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1zm11.5 7a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3z\" } }] }] })(e);\n}\nfunction Kr(e) {\n  return j({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"g\", attr: {}, child: [{ tag: \"path\", attr: { fill: \"none\", d: \"M0 0H24V24H0z\" } }, { tag: \"path\", attr: { d: \"M20 3c.552 0 1 .448 1 1v1.757l-2 2V5H5v8.1l4-4 4.328 4.329-1.327 1.327-.006 4.239 4.246.006 1.33-1.33L18.899 19H19v-2.758l2-2V20c0 .552-.448 1-1 1H4c-.552 0-1-.448-1-1V4c0-.552.448-1 1-1h16zm1.778 4.808l1.414 1.414L15.414 17l-1.416-.002.002-1.412 7.778-7.778zM15.5 7c.828 0 1.5.672 1.5 1.5s-.672 1.5-1.5 1.5S14 9.328 14 8.5 14.672 7 15.5 7z\" } }] }] })(e);\n}\nfunction Gr(e) {\n  return j({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"g\", attr: {}, child: [{ tag: \"path\", attr: { fill: \"none\", d: \"M0 0h24v24H0z\" } }, { tag: \"path\", attr: { d: \"M10 6v2H5v11h11v-5h2v6a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h6zm11-3v9l-3.794-3.793-5.999 6-1.414-1.414 5.999-6L12 3h9z\" } }] }] })(e);\n}\nfunction Re(e) {\n  return j({ tag: \"svg\", attr: { version: \"1.2\", baseProfile: \"tiny\", viewBox: \"0 0 24 24\" }, child: [{ tag: \"path\", attr: { d: \"M16.972 6.251c-.967-.538-2.185-.188-2.72.777l-3.713 6.682-2.125-2.125c-.781-.781-2.047-.781-2.828 0-.781.781-.781 2.047 0 2.828l4 4c.378.379.888.587 1.414.587l.277-.02c.621-.087 1.166-.46 1.471-1.009l5-9c.537-.966.189-2.183-.776-2.72z\" } }] })(e);\n}\nfunction Jr(e) {\n  const n = e.icon;\n  return /* @__PURE__ */ r.jsx(\n    _mantine_core__WEBPACK_IMPORTED_MODULE_4__.Menu.Item,\n    {\n      onClick: e.onClick,\n      icon: n && /* @__PURE__ */ r.jsx(n, { size: 16 }),\n      rightSection: e.isSelected ? /* @__PURE__ */ r.jsx(Re, { size: 16 }) : (\n        // Ensures space for tick even if item isn't currently selected.\n        /* @__PURE__ */ r.jsx(\"div\", { style: { width: \"16px\", padding: \"0\" } })\n      ),\n      disabled: e.isDisabled,\n      children: e.text\n    },\n    e.text\n  );\n}\nfunction Xr(e) {\n  return j({ tag: \"svg\", attr: { viewBox: \"0 0 20 20\", fill: \"currentColor\", \"aria-hidden\": \"true\" }, child: [{ tag: \"path\", attr: { fillRule: \"evenodd\", d: \"M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z\", clipRule: \"evenodd\" } }] })(e);\n}\nfunction Zr(e) {\n  return j({ tag: \"svg\", attr: { viewBox: \"0 0 20 20\", fill: \"currentColor\", \"aria-hidden\": \"true\" }, child: [{ tag: \"path\", attr: { fillRule: \"evenodd\", d: \"M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z\", clipRule: \"evenodd\" } }] })(e);\n}\nconst Qr = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((e, n) => {\n  const o = e.icon;\n  return /* @__PURE__ */ r.jsx(\n    _mantine_core__WEBPACK_IMPORTED_MODULE_4__.Button,\n    {\n      leftIcon: o && /* @__PURE__ */ r.jsx(o, { size: 16 }),\n      rightIcon: /* @__PURE__ */ r.jsx(Xr, {}),\n      size: \"xs\",\n      variant: \"subtle\",\n      disabled: e.isDisabled,\n      onClick: e.onClick,\n      ref: n,\n      children: e.text\n    }\n  );\n});\nfunction xe() {\n  const e = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  return {\n    ref: e,\n    updateMaxHeight: () => {\n      setTimeout(() => {\n        if (e.current && e.current.childElementCount > 0) {\n          e.current.firstElementChild.style.maxHeight = \"none\";\n          const n = e.current.firstElementChild.getBoundingClientRect();\n          e.current.firstElementChild.style.maxHeight = `${Math.min(\n            n.top >= 0 ? window.innerHeight - n.top - 20 : n.bottom - 20\n          )}px`;\n        }\n      }, 10);\n    }\n  };\n}\nfunction en(e) {\n  const n = e.items.filter((s) => s.isSelected)[0], { ref: o, updateMaxHeight: i } = xe();\n  return n ? /* @__PURE__ */ r.jsxs(\n    _mantine_core__WEBPACK_IMPORTED_MODULE_4__.Menu,\n    {\n      exitTransitionDuration: 0,\n      disabled: e.isDisabled,\n      onOpen: i,\n      children: [\n        /* @__PURE__ */ r.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_4__.Menu.Target, { children: /* @__PURE__ */ r.jsx(\n          Qr,\n          {\n            text: n.text,\n            icon: n.icon,\n            isDisabled: n.isDisabled\n          }\n        ) }),\n        /* @__PURE__ */ r.jsx(\"div\", { ref: o, children: /* @__PURE__ */ r.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_4__.Menu.Dropdown, { children: e.items.map((s) => /* @__PURE__ */ r.jsx(Jr, { ...s }, s.text)) }) })\n      ]\n    }\n  ) : null;\n}\nfunction tn(e, n) {\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => (e._tiptapEditor.on(\"update\", n), () => {\n    e._tiptapEditor.off(\"update\", n);\n  }), [n, e._tiptapEditor]);\n}\nfunction rn(e, n) {\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => (e._tiptapEditor.on(\"selectionUpdate\", n), () => {\n    e._tiptapEditor.off(\"selectionUpdate\", n);\n  }), [n, e._tiptapEditor]);\n}\nfunction q(e, n) {\n  tn(e, n), rn(e, n);\n}\nfunction G(e) {\n  const [n, o] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\n    () => {\n      var i;\n      return ((i = e.getSelection()) == null ? void 0 : i.blocks) || [e.getTextCursorPosition().block];\n    }\n  );\n  return q(\n    e,\n    () => {\n      var i;\n      return o(\n        ((i = e.getSelection()) == null ? void 0 : i.blocks) || [e.getTextCursorPosition().block]\n      );\n    }\n  ), n;\n}\nconst nn = [\n  {\n    name: \"Paragraph\",\n    type: \"paragraph\",\n    icon: ie,\n    isSelected: (e) => e.type === \"paragraph\"\n  },\n  {\n    name: \"Heading 1\",\n    type: \"heading\",\n    props: { level: 1 },\n    icon: kt,\n    isSelected: (e) => e.type === \"heading\" && \"level\" in e.props && e.props.level === 1\n  },\n  {\n    name: \"Heading 2\",\n    type: \"heading\",\n    props: { level: 2 },\n    icon: yt,\n    isSelected: (e) => e.type === \"heading\" && \"level\" in e.props && e.props.level === 2\n  },\n  {\n    name: \"Heading 3\",\n    type: \"heading\",\n    props: { level: 3 },\n    icon: pt,\n    isSelected: (e) => e.type === \"heading\" && \"level\" in e.props && e.props.level === 3\n  },\n  {\n    name: \"Bullet List\",\n    type: \"bulletListItem\",\n    icon: Tt,\n    isSelected: (e) => e.type === \"bulletListItem\"\n  },\n  {\n    name: \"Numbered List\",\n    type: \"numberedListItem\",\n    icon: jt,\n    isSelected: (e) => e.type === \"numberedListItem\"\n  }\n], on = (e) => {\n  const n = G(e.editor), [o, i] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\n    e.editor.getTextCursorPosition().block\n  ), s = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => (e.items || nn).filter((g) => {\n    if (!(g.type in e.editor.schema))\n      return !1;\n    for (const [a, y] of Object.entries(g.props || {})) {\n      const h = e.editor.schema[g.type].propSchema;\n      if (!(a in h) || h[a].values !== void 0 && !h[a].values.includes(y))\n        return !1;\n    }\n    return !0;\n  }), [e.editor, e.items]), c = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(\n    () => s.find((g) => g.type === o.type) !== void 0,\n    [o.type, s]\n  ), u = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    const g = (a) => {\n      e.editor.focus();\n      for (const y of n)\n        e.editor.updateBlock(y, {\n          type: a.type,\n          props: a.props\n        });\n    };\n    return s.map((a) => ({\n      text: a.name,\n      icon: a.icon,\n      onClick: () => g(a),\n      isSelected: a.isSelected(o)\n    }));\n  }, [o, s, e.editor, n]);\n  return q(e.editor, () => {\n    i(e.editor.getTextCursorPosition().block);\n  }), c ? /* @__PURE__ */ r.jsx(en, { items: u }) : null;\n}, an = (e) => {\n  const { classes: n } = (0,_mantine_core__WEBPACK_IMPORTED_MODULE_4__.createStyles)({ root: {} })(void 0, {\n    name: \"Tooltip\"\n  });\n  return /* @__PURE__ */ r.jsxs(_mantine_core__WEBPACK_IMPORTED_MODULE_4__.Stack, { spacing: 0, className: n.root, children: [\n    /* @__PURE__ */ r.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_4__.Text, { size: \"sm\", children: e.mainTooltip }),\n    e.secondaryTooltip && /* @__PURE__ */ r.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_4__.Text, { size: \"xs\", children: e.secondaryTooltip })\n  ] });\n}, P = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(\n  (e, n) => {\n    const o = e.icon;\n    return /* @__PURE__ */ r.jsx(\n      _tippyjs_react__WEBPACK_IMPORTED_MODULE_5__,\n      {\n        content: /* @__PURE__ */ r.jsx(\n          an,\n          {\n            mainTooltip: e.mainTooltip,\n            secondaryTooltip: e.secondaryTooltip\n          }\n        ),\n        trigger: \"mouseenter\",\n        children: e.children ? /* @__PURE__ */ r.jsxs(\n          _mantine_core__WEBPACK_IMPORTED_MODULE_4__.Button,\n          {\n            onClick: e.onClick,\n            \"data-selected\": e.isSelected ? \"true\" : void 0,\n            \"data-test\": e.mainTooltip.slice(0, 1).toLowerCase() + e.mainTooltip.replace(/\\s+/g, \"\").slice(1),\n            size: \"xs\",\n            disabled: e.isDisabled || !1,\n            ref: n,\n            children: [\n              o && /* @__PURE__ */ r.jsx(o, {}),\n              e.children\n            ]\n          }\n        ) : /* @__PURE__ */ r.jsx(\n          _mantine_core__WEBPACK_IMPORTED_MODULE_4__.ActionIcon,\n          {\n            onClick: e.onClick,\n            \"data-selected\": e.isSelected ? \"true\" : void 0,\n            \"data-test\": e.mainTooltip.slice(0, 1).toLowerCase() + e.mainTooltip.replace(/\\s+/g, \"\").slice(1),\n            size: 30,\n            disabled: e.isDisabled || !1,\n            ref: n,\n            children: o && /* @__PURE__ */ r.jsx(o, {})\n          }\n        )\n      }\n    );\n  }\n), ln = () => typeof navigator < \"u\" && (/Mac/.test(navigator.platform) || /AppleWebKit/.test(navigator.userAgent) && /Mobile\\/\\w+/.test(navigator.userAgent));\nfunction A(e) {\n  return ln() ? e.replace(\"Mod\", \"⌘\") : e.replace(\"Mod\", \"Ctrl\");\n}\nconst cn = {\n  bold: \"Mod+B\",\n  italic: \"Mod+I\",\n  underline: \"Mod+U\",\n  strike: \"Mod+Shift+X\",\n  code: \"\"\n}, sn = {\n  bold: Lr,\n  italic: Nr,\n  underline: Yr,\n  strike: Wr,\n  code: Dr\n}, he = (e) => {\n  const n = G(e.editor), [o, i] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\n    e.toggledStyle in e.editor.getActiveStyles()\n  );\n  q(e.editor, () => {\n    i(e.toggledStyle in e.editor.getActiveStyles());\n  });\n  const s = (u) => {\n    e.editor.focus(), e.editor.toggleStyles({ [u]: !0 });\n  };\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => !!n.find((u) => u.content !== void 0), [n]) ? /* @__PURE__ */ r.jsx(\n    P,\n    {\n      onClick: () => s(e.toggledStyle),\n      isSelected: o,\n      mainTooltip: e.toggledStyle.slice(0, 1).toUpperCase() + e.toggledStyle.slice(1),\n      secondaryTooltip: A(cn[e.toggledStyle]),\n      icon: sn[e.toggledStyle]\n    }\n  ) : null;\n}, dn = {\n  left: Fr,\n  center: Pr,\n  right: Ar,\n  justify: Or\n}, Se = (e) => {\n  const n = G(e.editor), o = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    const c = n[0];\n    if (\"textAlignment\" in c.props)\n      return c.props.textAlignment;\n  }, [n]), i = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (c) => {\n      e.editor.focus();\n      for (const u of n)\n        e.editor.updateBlock(u, {\n          props: { textAlignment: c }\n        });\n    },\n    [e.editor, n]\n  );\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => !!n.find((c) => \"textAlignment\" in c.props), [n]) ? /* @__PURE__ */ r.jsx(\n    P,\n    {\n      onClick: () => i(e.textAlignment),\n      isSelected: o === e.textAlignment,\n      mainTooltip: e.textAlignment === \"justify\" ? \"Justify Text\" : \"Align Text \" + e.textAlignment.slice(0, 1).toUpperCase() + e.textAlignment.slice(1),\n      icon: dn[e.textAlignment]\n    }\n  ) : null;\n}, Ee = (e) => {\n  const { classes: n } = (0,_mantine_core__WEBPACK_IMPORTED_MODULE_4__.createStyles)({ root: {} })(void 0, {\n    name: \"ColorIcon\"\n  }), o = e.textColor || \"default\", i = e.backgroundColor || \"default\", s = e.size || 16;\n  return /* @__PURE__ */ r.jsx(\n    _mantine_core__WEBPACK_IMPORTED_MODULE_4__.Box,\n    {\n      className: n.root,\n      sx: (c) => ({\n        pointerEvents: \"none\",\n        backgroundColor: c.other.backgroundColors[i],\n        color: c.other.textColors[o],\n        fontSize: (s * 0.75).toString() + \"px\",\n        height: s.toString() + \"px\",\n        lineHeight: s.toString() + \"px\",\n        textAlign: \"center\",\n        width: s.toString() + \"px\"\n      }),\n      children: \"A\"\n    }\n  );\n}, wt = (e) => {\n  const n = () => e.text ? /* @__PURE__ */ r.jsxs(r.Fragment, { children: [\n    /* @__PURE__ */ r.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_4__.Menu.Label, { children: \"Text\" }),\n    [\n      \"default\",\n      \"gray\",\n      \"brown\",\n      \"red\",\n      \"orange\",\n      \"yellow\",\n      \"green\",\n      \"blue\",\n      \"purple\",\n      \"pink\"\n    ].map((i) => /* @__PURE__ */ r.jsx(\n      _mantine_core__WEBPACK_IMPORTED_MODULE_4__.Menu.Item,\n      {\n        onClick: () => {\n          e.onClick && e.onClick(), e.text.setColor(i);\n        },\n        component: \"div\",\n        \"data-test\": \"text-color-\" + i,\n        icon: /* @__PURE__ */ r.jsx(Ee, { textColor: i, size: e.iconSize }),\n        rightSection: e.text.color === i ? /* @__PURE__ */ r.jsx(Re, { size: 16, style: { paddingLeft: \"8px\" } }) : /* @__PURE__ */ r.jsx(\"div\", { style: { width: \"24px\", padding: \"0\" } }),\n        children: i.charAt(0).toUpperCase() + i.slice(1)\n      },\n      \"text-color-\" + i\n    ))\n  ] }) : null, o = () => e.background ? /* @__PURE__ */ r.jsxs(r.Fragment, { children: [\n    /* @__PURE__ */ r.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_4__.Menu.Label, { children: \"Background\" }),\n    [\n      \"default\",\n      \"gray\",\n      \"brown\",\n      \"red\",\n      \"orange\",\n      \"yellow\",\n      \"green\",\n      \"blue\",\n      \"purple\",\n      \"pink\"\n    ].map((i) => /* @__PURE__ */ r.jsx(\n      _mantine_core__WEBPACK_IMPORTED_MODULE_4__.Menu.Item,\n      {\n        onClick: () => {\n          e.onClick && e.onClick(), e.background.setColor(i);\n        },\n        component: \"div\",\n        \"data-test\": \"background-color-\" + i,\n        icon: /* @__PURE__ */ r.jsx(Ee, { backgroundColor: i, size: e.iconSize }),\n        rightSection: e.background.color === i ? /* @__PURE__ */ r.jsx(Re, { size: 16, style: { paddingLeft: \"8px\" } }) : /* @__PURE__ */ r.jsx(\"div\", { style: { width: \"24px\", padding: \"0\" } }),\n        children: i.charAt(0).toUpperCase() + i.slice(1)\n      },\n      \"background-color-\" + i\n    ))\n  ] }) : null;\n  return /* @__PURE__ */ r.jsxs(r.Fragment, { children: [\n    /* @__PURE__ */ r.jsx(n, {}),\n    /* @__PURE__ */ r.jsx(o, {})\n  ] });\n}, un = (e) => {\n  const n = G(e.editor), [o, i] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\n    e.editor.getActiveStyles().textColor || \"default\"\n  ), [s, c] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\n    e.editor.getActiveStyles().backgroundColor || \"default\"\n  );\n  q(e.editor, () => {\n    i(e.editor.getActiveStyles().textColor || \"default\"), c(\n      e.editor.getActiveStyles().backgroundColor || \"default\"\n    );\n  });\n  const { ref: u, updateMaxHeight: g } = xe(), a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (p) => {\n      e.editor.focus(), p === \"default\" ? e.editor.removeStyles({ textColor: p }) : e.editor.addStyles({ textColor: p });\n    },\n    [e.editor]\n  ), y = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (p) => {\n      e.editor.focus(), p === \"default\" ? e.editor.removeStyles({ backgroundColor: p }) : e.editor.addStyles({ backgroundColor: p });\n    },\n    [e.editor]\n  );\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    for (const p of n)\n      if (p.content !== void 0)\n        return !0;\n    return !1;\n  }, [n]) ? /* @__PURE__ */ r.jsxs(_mantine_core__WEBPACK_IMPORTED_MODULE_4__.Menu, { onOpen: g, children: [\n    /* @__PURE__ */ r.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_4__.Menu.Target, { children: /* @__PURE__ */ r.jsx(\n      P,\n      {\n        mainTooltip: \"Colors\",\n        icon: () => /* @__PURE__ */ r.jsx(\n          Ee,\n          {\n            textColor: o,\n            backgroundColor: s,\n            size: 20\n          }\n        )\n      }\n    ) }),\n    /* @__PURE__ */ r.jsx(\"div\", { ref: u, children: /* @__PURE__ */ r.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_4__.Menu.Dropdown, { children: /* @__PURE__ */ r.jsx(\n      wt,\n      {\n        text: {\n          color: o,\n          setColor: a\n        },\n        background: {\n          color: s,\n          setColor: y\n        }\n      }\n    ) }) })\n  ] }) : null;\n}, gn = (e) => {\n  const [n, o] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n  q(e.editor, () => {\n    o(e.editor.canNestBlock());\n  });\n  const i = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    e.editor.focus(), e.editor.nestBlock();\n  }, [e.editor]);\n  return /* @__PURE__ */ r.jsx(\n    P,\n    {\n      onClick: i,\n      isDisabled: !n,\n      mainTooltip: \"Nest Block\",\n      secondaryTooltip: A(\"Tab\"),\n      icon: Ur\n    }\n  );\n}, fn = (e) => {\n  const [n, o] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n  q(e.editor, () => {\n    o(e.editor.canUnnestBlock());\n  });\n  const i = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    e.editor.focus(), e.editor.unnestBlock();\n  }, [e]);\n  return /* @__PURE__ */ r.jsx(\n    P,\n    {\n      onClick: i,\n      isDisabled: !n,\n      mainTooltip: \"Unnest Block\",\n      secondaryTooltip: A(\"Shift+Tab\"),\n      icon: Vr\n    }\n  );\n}, St = (e) => {\n  const [n, o] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), i = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    o(!1);\n  }, []), s = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    o(!0);\n  }, []);\n  return /* @__PURE__ */ r.jsx(\n    _tippyjs_react__WEBPACK_IMPORTED_MODULE_5__,\n    {\n      onShow: (c) => {\n        var u;\n        s(), (u = e.onShow) == null || u.call(e, c);\n      },\n      onHidden: (c) => {\n        var u;\n        i(), (u = e.onShow) == null || u.call(e, c);\n      },\n      content: n ? e.children[1] : null,\n      trigger: e.visible === void 0 ? \"click\" : void 0,\n      interactive: !0,\n      maxWidth: 500,\n      zIndex: 9e3,\n      ...e,\n      children: e.children[0]\n    }\n  );\n}, Mt = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ className: e, ...n }, o) => {\n  const { classes: i } = (0,_mantine_core__WEBPACK_IMPORTED_MODULE_4__.createStyles)({ root: {} })(void 0, {\n    name: \"ToolbarInputDropdown\"\n  });\n  return /* @__PURE__ */ r.jsx(\n    _mantine_core__WEBPACK_IMPORTED_MODULE_4__.Stack,\n    {\n      ...n,\n      className: (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.mergeCSSClasses)(i.root, e || \"\"),\n      ref: o,\n      children: n.children\n    }\n  );\n}), hn = {\n  text: _mantine_core__WEBPACK_IMPORTED_MODULE_4__.TextInput,\n  file: _mantine_core__WEBPACK_IMPORTED_MODULE_4__.FileInput\n}, ze = (e) => {\n  const n = e.icon, o = hn[e.type];\n  return /* @__PURE__ */ r.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_4__.Group, { children: /* @__PURE__ */ r.jsx(o, { size: \"xs\", icon: /* @__PURE__ */ r.jsx(n, {}), ...e.inputProps }) });\n}, Rt = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ url: e, text: n, update: o, ...i }, s) => {\n  const [c, u] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(e), [g, a] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(n);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    u(e), a(n);\n  }, [n, e]);\n  const y = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (T) => {\n      T.key === \"Enter\" && (T.preventDefault(), o(c, g));\n    },\n    [o, c, g]\n  ), h = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (T) => u(T.currentTarget.value),\n    []\n  ), p = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (T) => a(T.currentTarget.value),\n    []\n  ), S = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    () => o(c, g),\n    [o, c, g]\n  );\n  return /* @__PURE__ */ r.jsxs(Mt, { ...i, ref: s, children: [\n    /* @__PURE__ */ r.jsx(\n      ze,\n      {\n        type: \"text\",\n        icon: Ct,\n        inputProps: {\n          autoFocus: !0,\n          placeholder: \"Edit URL\",\n          value: c,\n          onKeyDown: y,\n          onChange: h,\n          onSubmit: S\n        }\n      }\n    ),\n    /* @__PURE__ */ r.jsx(\n      ze,\n      {\n        type: \"text\",\n        icon: ie,\n        inputProps: {\n          placeholder: \"Edit Title\",\n          value: g,\n          onKeyDown: y,\n          onChange: p,\n          onSubmit: S\n        }\n      }\n    )\n  ] });\n}), vn = (e) => {\n  const n = G(e.editor), [o, i] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\n    e.editor.getSelectedLinkUrl() || \"\"\n  ), [s, c] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(e.editor.getSelectedText());\n  q(e.editor, () => {\n    c(e.editor.getSelectedText() || \"\"), i(e.editor.getSelectedLinkUrl() || \"\");\n  });\n  const u = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (a, y) => {\n      e.editor.createLink(a, y), e.editor.focus();\n    },\n    [e.editor]\n  );\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    for (const a of n)\n      if (a.content === void 0)\n        return !1;\n    return !0;\n  }, [n]) ? /* @__PURE__ */ r.jsxs(St, { children: [\n    /* @__PURE__ */ r.jsx(\n      P,\n      {\n        mainTooltip: \"Create Link\",\n        secondaryTooltip: A(\"Mod+K\"),\n        icon: Ct\n      }\n    ),\n    /* @__PURE__ */ r.jsx(Rt, { url: o, text: s, update: u })\n  ] }) : null;\n}, Et = (e) => {\n  const [n, o] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\n    e.editor.uploadFile !== void 0 ? \"upload\" : \"embed\"\n  ), [i, s] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), [c, u] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    c && setTimeout(() => {\n      u(!1);\n    }, 3e3);\n  }, [c]);\n  const g = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    async (T) => {\n      if (s(!0), e.editor.uploadFile !== void 0)\n        try {\n          const D = await e.editor.uploadFile(T);\n          e.editor.updateBlock(e.block, {\n            type: \"image\",\n            props: {\n              url: D\n            }\n          });\n        } catch {\n          u(!0);\n        } finally {\n          s(!1);\n        }\n    },\n    [e.block, e.editor]\n  ), [a, y] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\"), h = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (T) => {\n      y(T.currentTarget.value);\n    },\n    []\n  ), p = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (T) => {\n      T.key === \"Enter\" && (T.preventDefault(), e.editor.updateBlock(e.block, {\n        type: \"image\",\n        props: {\n          url: a\n        }\n      }));\n    },\n    [a, e.block, e.editor]\n  ), S = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    e.editor.updateBlock(e.block, {\n      type: \"image\",\n      props: {\n        url: a\n      }\n    });\n  }, [a, e.block, e.editor]);\n  return /* @__PURE__ */ r.jsx(\n    _e,\n    {\n      style: {\n        width: \"500px\"\n      },\n      children: /* @__PURE__ */ r.jsxs(_mantine_core__WEBPACK_IMPORTED_MODULE_4__.Tabs, { value: n, onTabChange: o, children: [\n        i && /* @__PURE__ */ r.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_4__.LoadingOverlay, { visible: i }),\n        /* @__PURE__ */ r.jsxs(_mantine_core__WEBPACK_IMPORTED_MODULE_4__.Tabs.List, { children: [\n          e.editor.uploadFile !== void 0 && /* @__PURE__ */ r.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_4__.Tabs.Tab, { value: \"upload\", \"data-test\": \"upload-tab\", children: \"Upload\" }),\n          /* @__PURE__ */ r.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_4__.Tabs.Tab, { value: \"embed\", \"data-test\": \"embed-tab\", children: \"Embed\" })\n        ] }),\n        e.editor.uploadFile !== void 0 && /* @__PURE__ */ r.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_4__.Tabs.Panel, { value: \"upload\", children: /* @__PURE__ */ r.jsxs(\n          \"div\",\n          {\n            style: {\n              display: \"flex\",\n              flexDirection: \"column\",\n              alignItems: \"stretch\",\n              gap: \"8px\"\n            },\n            children: [\n              /* @__PURE__ */ r.jsx(\n                _mantine_core__WEBPACK_IMPORTED_MODULE_4__.FileInput,\n                {\n                  placeholder: \"Upload Image\",\n                  size: \"xs\",\n                  value: null,\n                  onChange: g,\n                  \"data-test\": \"upload-input\"\n                }\n              ),\n              c && /* @__PURE__ */ r.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_4__.Text, { color: \"red\", size: 12, style: { textAlign: \"center\" }, children: \"Error: Upload failed\" })\n            ]\n          }\n        ) }),\n        /* @__PURE__ */ r.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_4__.Tabs.Panel, { value: \"embed\", children: /* @__PURE__ */ r.jsxs(\n          \"div\",\n          {\n            style: {\n              width: \"100%\",\n              display: \"flex\",\n              flexDirection: \"column\",\n              alignItems: \"center\",\n              gap: \"8px\"\n            },\n            children: [\n              /* @__PURE__ */ r.jsx(\n                _mantine_core__WEBPACK_IMPORTED_MODULE_4__.TextInput,\n                {\n                  size: \"xs\",\n                  placeholder: \"Enter URL\",\n                  value: a,\n                  onChange: h,\n                  onKeyDown: p,\n                  style: { width: \"100%\" },\n                  \"data-test\": \"embed-input\"\n                }\n              ),\n              /* @__PURE__ */ r.jsx(\n                _mantine_core__WEBPACK_IMPORTED_MODULE_4__.Button,\n                {\n                  onClick: S,\n                  size: \"xs\",\n                  \"data-test\": \"embed-input-button\",\n                  children: \"Embed Image\"\n                }\n              )\n            ]\n          }\n        ) })\n      ] })\n    }\n  );\n}, bn = (e) => {\n  const n = G(e.editor), [o, i] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    i(!1);\n  }, [n]), // Checks if only one block is selected.\n  n.length === 1 && // Checks if the selected block is an image.\n  n[0].type === \"image\" ? /* @__PURE__ */ r.jsx(\n    _tippyjs_react__WEBPACK_IMPORTED_MODULE_5__,\n    {\n      visible: o,\n      interactive: !0,\n      content: /* @__PURE__ */ r.jsx(\n        Et,\n        {\n          block: n[0],\n          editor: e.editor\n        }\n      ),\n      children: /* @__PURE__ */ r.jsx(\n        P,\n        {\n          onClick: () => i(!o),\n          isSelected: o,\n          mainTooltip: \"Replace Image\",\n          icon: Kr\n        }\n      )\n    }\n  ) : null;\n}, xn = (e) => {\n  const n = G(e.editor), o = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(\n    () => (\n      // Checks if only one block is selected.\n      n.length === 1 && // Checks if the selected block is an image.\n      n[0].type === \"image\" && // Checks if the block has a `caption` prop which can take any string\n      // value.\n      \"caption\" in e.editor.schema.image.propSchema && typeof e.editor.schema.image.propSchema.caption.default == \"string\" && e.editor.schema.image.propSchema.caption.values === void 0 && // Checks if the block has a `src` prop which can take any string value.\n      \"src\" in e.editor.schema.image.propSchema && typeof e.editor.schema.image.propSchema.src.default == \"string\" && e.editor.schema.image.propSchema.src.values === void 0 && // Checks if the `src` prop is not set to an empty string.\n      n[0].props.src !== \"\"\n    ),\n    [e.editor.schema, n]\n  ), [i, s] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\n    o ? n[0].props.caption : \"\"\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n    () => s(\n      o ? n[0].props.caption : \"\"\n    ),\n    [n, o]\n  );\n  const c = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (g) => {\n      g.key === \"Enter\" && (g.preventDefault(), e.editor.updateBlock(n[0], {\n        type: \"image\",\n        props: {\n          caption: i\n        }\n      }));\n    },\n    [i, e.editor, n]\n  ), u = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (g) => s(g.currentTarget.value),\n    []\n  );\n  return o ? /* @__PURE__ */ r.jsxs(St, { children: [\n    /* @__PURE__ */ r.jsx(\n      P,\n      {\n        mainTooltip: \"Edit Caption\",\n        icon: ie,\n        isSelected: n[0].props.caption !== \"\"\n      }\n    ),\n    /* @__PURE__ */ r.jsx(Mt, { children: /* @__PURE__ */ r.jsx(\n      ze,\n      {\n        type: \"text\",\n        icon: ie,\n        inputProps: {\n          autoFocus: !0,\n          placeholder: \"Edit Caption\",\n          value: i,\n          onKeyDown: c,\n          onChange: u\n        }\n      }\n    ) })\n  ] }) : null;\n}, mn = (e) => /* @__PURE__ */ r.jsxs(_e, { children: [\n  /* @__PURE__ */ r.jsx(on, { ...e, items: e.blockTypeDropdownItems }),\n  /* @__PURE__ */ r.jsx(xn, { editor: e.editor }),\n  /* @__PURE__ */ r.jsx(bn, { editor: e.editor }),\n  /* @__PURE__ */ r.jsx(he, { editor: e.editor, toggledStyle: \"bold\" }),\n  /* @__PURE__ */ r.jsx(he, { editor: e.editor, toggledStyle: \"italic\" }),\n  /* @__PURE__ */ r.jsx(he, { editor: e.editor, toggledStyle: \"underline\" }),\n  /* @__PURE__ */ r.jsx(he, { editor: e.editor, toggledStyle: \"strike\" }),\n  /* @__PURE__ */ r.jsx(Se, { editor: e.editor, textAlignment: \"left\" }),\n  /* @__PURE__ */ r.jsx(Se, { editor: e.editor, textAlignment: \"center\" }),\n  /* @__PURE__ */ r.jsx(Se, { editor: e.editor, textAlignment: \"right\" }),\n  /* @__PURE__ */ r.jsx(un, { editor: e.editor }),\n  /* @__PURE__ */ r.jsx(gn, { editor: e.editor }),\n  /* @__PURE__ */ r.jsx(fn, { editor: e.editor }),\n  /* @__PURE__ */ r.jsx(vn, { editor: e.editor })\n] }), st = (e) => {\n  switch (e) {\n    case \"left\":\n      return \"top-start\";\n    case \"center\":\n      return \"top\";\n    case \"right\":\n      return \"top-end\";\n    default:\n      return \"top-start\";\n  }\n}, kn = (e) => {\n  const [n, o] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), [i, s] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\n    () => {\n      const a = e.editor.getTextCursorPosition().block;\n      return \"textAlignment\" in a.props ? st(\n        a.props.textAlignment\n      ) : \"top-start\";\n    }\n  ), c = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => (_tippyjs_react__WEBPACK_IMPORTED_MODULE_5__.tippy.setDefaultProps({ maxWidth: \"\" }), e.editor.formattingToolbar.onUpdate((a) => {\n    o(a.show), c.current = a.referencePos;\n  })), [e.editor]), q(e.editor, () => {\n    const a = e.editor.getTextCursorPosition().block;\n    \"textAlignment\" in a.props ? s(\n      st(\n        a.props.textAlignment\n      )\n    ) : s(\"top-start\");\n  });\n  const u = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(\n    () => {\n      if (c)\n        return () => c.current;\n    },\n    [c.current]\n    // eslint-disable-line\n  ), g = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    const a = e.formattingToolbar || mn;\n    return /* @__PURE__ */ r.jsx(a, { editor: e.editor });\n  }, [e.editor, e.formattingToolbar]);\n  return /* @__PURE__ */ r.jsx(\n    _tippyjs_react__WEBPACK_IMPORTED_MODULE_5__,\n    {\n      appendTo: e.editor.domElement.parentElement,\n      content: g,\n      getReferenceClientRect: u,\n      interactive: !0,\n      visible: n,\n      animation: \"fade\",\n      placement: i,\n      sticky: !0,\n      plugins: yn,\n      zIndex: 3e3\n    }\n  );\n}, yn = [tippy_js__WEBPACK_IMPORTED_MODULE_6__.sticky], pn = (e) => {\n  const [n, o] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), i = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  return n ? /* @__PURE__ */ r.jsx(\n    Rt,\n    {\n      url: e.url,\n      text: e.text,\n      update: e.editHyperlink,\n      onBlur: (s) => setTimeout(() => {\n        var c;\n        (c = i.current) != null && c.contains(s.relatedTarget) || o(!1);\n      }, 500),\n      ref: i\n    }\n  ) : /* @__PURE__ */ r.jsxs(\n    _e,\n    {\n      onMouseEnter: e.stopHideTimer,\n      onMouseLeave: e.startHideTimer,\n      children: [\n        /* @__PURE__ */ r.jsx(\n          P,\n          {\n            mainTooltip: \"Edit\",\n            isSelected: !1,\n            onClick: () => o(!0),\n            children: \"Edit Link\"\n          }\n        ),\n        /* @__PURE__ */ r.jsx(\n          P,\n          {\n            mainTooltip: \"Open in new tab\",\n            isSelected: !1,\n            onClick: () => {\n              window.open(e.url, \"_blank\");\n            },\n            icon: Gr\n          }\n        ),\n        /* @__PURE__ */ r.jsx(\n          P,\n          {\n            mainTooltip: \"Remove link\",\n            isSelected: !1,\n            onClick: e.deleteHyperlink,\n            icon: $r\n          }\n        )\n      ]\n    }\n  );\n}, Cn = (e) => {\n  const [n, o] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), [i, s] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(), [c, u] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(), g = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => e.editor.hyperlinkToolbar.on(\n    \"update\",\n    (h) => {\n      o(h.show), s(h.url), u(h.text), g.current = h.referencePos;\n    }\n  ), [e.editor]);\n  const a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(\n    () => {\n      if (g.current)\n        return () => g.current;\n    },\n    [g.current]\n    // eslint-disable-line\n  ), y = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    if (!i || !c)\n      return null;\n    const h = e.hyperlinkToolbar || pn;\n    return /* @__PURE__ */ r.jsx(\n      h,\n      {\n        url: i,\n        text: c,\n        editHyperlink: e.editor.hyperlinkToolbar.editHyperlink,\n        deleteHyperlink: e.editor.hyperlinkToolbar.deleteHyperlink,\n        startHideTimer: e.editor.hyperlinkToolbar.startHideTimer,\n        stopHideTimer: e.editor.hyperlinkToolbar.stopHideTimer\n      }\n    );\n  }, [e.hyperlinkToolbar, e.editor, c, i]);\n  return /* @__PURE__ */ r.jsx(\n    _tippyjs_react__WEBPACK_IMPORTED_MODULE_5__,\n    {\n      appendTo: e.editor.domElement.parentElement,\n      content: y,\n      getReferenceClientRect: a,\n      interactive: !0,\n      visible: n,\n      animation: \"fade\",\n      placement: \"top-start\",\n      zIndex: 4e3\n    }\n  );\n}, jn = (e) => {\n  const { classes: n } = (0,_mantine_core__WEBPACK_IMPORTED_MODULE_4__.createStyles)({ root: {} })(void 0, {\n    name: \"SideMenu\"\n  });\n  return /* @__PURE__ */ r.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_4__.Group, { className: n.root, spacing: 0, children: e.children });\n};\nfunction Tn(e) {\n  return j({ tag: \"svg\", attr: { t: \"1551322312294\", style: \"\", viewBox: \"0 0 1024 1024\", version: \"1.1\" }, child: [{ tag: \"defs\", attr: {}, child: [] }, { tag: \"path\", attr: { d: \"M474 152m8 0l60 0q8 0 8 8l0 704q0 8-8 8l-60 0q-8 0-8-8l0-704q0-8 8-8Z\" } }, { tag: \"path\", attr: { d: \"M168 474m8 0l672 0q8 0 8 8l0 60q0 8-8 8l-672 0q-8 0-8-8l0-60q0-8 8-8Z\" } }] })(e);\n}\nconst zt = (e) => /* @__PURE__ */ r.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_4__.ActionIcon, { size: 24, children: e.children }), wn = (e) => /* @__PURE__ */ r.jsx(zt, { children: /* @__PURE__ */ r.jsx(\n  Tn,\n  {\n    size: 24,\n    onClick: e.addBlock,\n    \"data-test\": \"dragHandleAdd\"\n  }\n) });\nfunction Sn(e) {\n  return j({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"path\", attr: { fill: \"none\", d: \"M0 0h24v24H0V0z\" } }, { tag: \"path\", attr: { d: \"M11 18c0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2 2 .9 2 2zm-2-8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0-6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm6 4c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z\" } }] })(e);\n}\nconst Mn = (e) => {\n  const { classes: n } = (0,_mantine_core__WEBPACK_IMPORTED_MODULE_4__.createStyles)({ root: {} })(void 0, {\n    name: \"DragHandleMenu\"\n  });\n  return /* @__PURE__ */ r.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_4__.Menu.Dropdown, { className: n.root, style: { overflow: \"visible\" }, children: e.children });\n}, Ht = (e) => {\n  const { children: n, ...o } = e;\n  return /* @__PURE__ */ r.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_4__.Menu.Item, { ...o, children: n });\n}, Rn = (e) => /* @__PURE__ */ r.jsx(\n  Ht,\n  {\n    onClick: () => e.editor.removeBlocks([e.block]),\n    children: e.children\n  }\n), En = (e) => {\n  const [n, o] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), { ref: i, updateMaxHeight: s } = xe(), c = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(), u = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    c.current && clearTimeout(c.current), c.current = setTimeout(() => {\n      o(!1);\n    }, 250);\n  }, []), g = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    c.current && clearTimeout(c.current), n || s(), o(!0);\n  }, [n, s]);\n  return !(\"textColor\" in e.block.props) && !(\"backgroundColor\" in e.block.props) ? null : /* @__PURE__ */ r.jsx(\n    Ht,\n    {\n      onMouseLeave: u,\n      onMouseOver: g,\n      children: /* @__PURE__ */ r.jsxs(_mantine_core__WEBPACK_IMPORTED_MODULE_4__.Menu, { opened: n, position: \"right\", children: [\n        /* @__PURE__ */ r.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_4__.Menu.Target, { children: /* @__PURE__ */ r.jsxs(\"div\", { style: { display: \"flex\", alignItems: \"center\" }, children: [\n          /* @__PURE__ */ r.jsx(\"div\", { style: { flex: 1 }, children: e.children }),\n          /* @__PURE__ */ r.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_4__.Box, { style: { display: \"flex\", alignItems: \"center\" }, children: /* @__PURE__ */ r.jsx(Zr, { size: 15 }) })\n        ] }) }),\n        /* @__PURE__ */ r.jsx(\"div\", { ref: i, children: /* @__PURE__ */ r.jsx(\n          _mantine_core__WEBPACK_IMPORTED_MODULE_4__.Menu.Dropdown,\n          {\n            onMouseLeave: u,\n            onMouseOver: g,\n            style: { marginLeft: \"5px\" },\n            children: /* @__PURE__ */ r.jsx(\n              wt,\n              {\n                iconSize: 18,\n                text: \"textColor\" in e.block.props && typeof e.block.props.textColor == \"string\" ? {\n                  color: e.block.props.textColor,\n                  setColor: (a) => e.editor.updateBlock(e.block, {\n                    props: { textColor: a }\n                  })\n                } : void 0,\n                background: \"backgroundColor\" in e.block.props && typeof e.block.props.backgroundColor == \"string\" ? {\n                  color: e.block.props.backgroundColor,\n                  setColor: (a) => e.editor.updateBlock(e.block, {\n                    props: { backgroundColor: a }\n                  })\n                } : void 0\n              }\n            )\n          }\n        ) })\n      ] })\n    }\n  );\n}, zn = (e) => /* @__PURE__ */ r.jsxs(Mn, { children: [\n  /* @__PURE__ */ r.jsx(Rn, { ...e, children: \"Delete\" }),\n  /* @__PURE__ */ r.jsx(En, { ...e, children: \"Colors\" })\n] }), Hn = (e) => {\n  const n = e.dragHandleMenu || zn;\n  return /* @__PURE__ */ r.jsxs(\n    _mantine_core__WEBPACK_IMPORTED_MODULE_4__.Menu,\n    {\n      trigger: \"click\",\n      onOpen: e.freezeMenu,\n      onClose: e.unfreezeMenu,\n      width: 100,\n      position: \"left\",\n      children: [\n        /* @__PURE__ */ r.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_4__.Menu.Target, { children: /* @__PURE__ */ r.jsx(\n          \"div\",\n          {\n            draggable: \"true\",\n            onDragStart: e.blockDragStart,\n            onDragEnd: e.blockDragEnd,\n            children: /* @__PURE__ */ r.jsx(zt, { children: /* @__PURE__ */ r.jsx(Sn, { size: 24, \"data-test\": \"dragHandle\" }) })\n          }\n        ) }),\n        /* @__PURE__ */ r.jsx(n, { editor: e.editor, block: e.block })\n      ]\n    }\n  );\n}, In = (e) => /* @__PURE__ */ r.jsxs(jn, { children: [\n  /* @__PURE__ */ r.jsx(wn, { ...e }),\n  /* @__PURE__ */ r.jsx(Hn, { ...e })\n] }), Bn = (e) => {\n  const [n, o] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), [i, s] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(), c = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => e.editor.sideMenu.onUpdate((a) => {\n    o(a.show), s(a.block), c.current = a.referencePos;\n  }), [e.editor]);\n  const u = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(\n    () => {\n      if (c.current)\n        return () => c.current;\n    },\n    [c.current]\n    // eslint-disable-line\n  ), g = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    if (!i)\n      return null;\n    const a = e.sideMenu || In;\n    return /* @__PURE__ */ r.jsx(\n      a,\n      {\n        block: i,\n        editor: e.editor,\n        blockDragStart: e.editor.sideMenu.blockDragStart,\n        blockDragEnd: e.editor.sideMenu.blockDragEnd,\n        addBlock: e.editor.sideMenu.addBlock,\n        freezeMenu: e.editor.sideMenu.freezeMenu,\n        unfreezeMenu: e.editor.sideMenu.unfreezeMenu\n      }\n    );\n  }, [i, e.editor, e.sideMenu]);\n  return /* @__PURE__ */ r.jsx(\n    _tippyjs_react__WEBPACK_IMPORTED_MODULE_5__,\n    {\n      appendTo: e.editor.domElement.parentElement,\n      content: g,\n      getReferenceClientRect: u,\n      interactive: !0,\n      visible: n,\n      animation: \"fade\",\n      offset: _n,\n      placement: \"left\",\n      popperOptions: Dn,\n      zIndex: 1e3\n    }\n  );\n}, _n = [0, 0], Dn = {\n  modifiers: [\n    {\n      name: \"flip\",\n      options: {\n        fallbackPlacements: []\n      }\n    },\n    {\n      name: \"preventOverflow\",\n      options: {\n        mainAxis: !1,\n        altAxis: !1\n      }\n    }\n  ]\n}, Pn = 5;\nfunction On(e) {\n  const n = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), { classes: o } = (0,_mantine_core__WEBPACK_IMPORTED_MODULE_4__.createStyles)({ root: {} })(void 0, {\n    name: \"SuggestionListItem\"\n  });\n  function i() {\n    var g;\n    const c = e.isSelected, u = (g = n.current) == null ? void 0 : g.matches(\":hover\");\n    return c || u;\n  }\n  function s() {\n    var c, u;\n    i() ? (c = n.current) == null || c.setAttribute(\"data-hovered\", \"true\") : (u = n.current) == null || u.removeAttribute(\"data-hovered\");\n  }\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    s(), i() && n.current && n.current.getBoundingClientRect().left > Pn && n.current.scrollIntoView({\n      behavior: \"smooth\",\n      block: \"nearest\"\n    });\n  }), /* @__PURE__ */ r.jsx(\n    _mantine_core__WEBPACK_IMPORTED_MODULE_4__.Menu.Item,\n    {\n      className: o.root,\n      icon: e.icon,\n      onClick: e.set,\n      closeMenuOnClick: !1,\n      onMouseLeave: () => {\n        setTimeout(() => {\n          s();\n        }, 1);\n      },\n      ref: n,\n      rightSection: e.shortcut && /* @__PURE__ */ r.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_4__.Badge, { size: \"xs\", children: e.shortcut }),\n      children: /* @__PURE__ */ r.jsxs(_mantine_core__WEBPACK_IMPORTED_MODULE_4__.Stack, { children: [\n        /* @__PURE__ */ r.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_4__.Text, { size: 14, weight: 500, children: e.name }),\n        /* @__PURE__ */ r.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_4__.Text, { size: 10, children: e.hint })\n      ] })\n    }\n  );\n}\nfunction Fn(e) {\n  const { classes: n } = (0,_mantine_core__WEBPACK_IMPORTED_MODULE_4__.createStyles)({ root: {} })(void 0, {\n    name: \"SlashMenu\"\n  }), o = [];\n  let i = 0;\n  const s = lodash__WEBPACK_IMPORTED_MODULE_3__.groupBy(e.filteredItems, (c) => c.group);\n  return lodash__WEBPACK_IMPORTED_MODULE_3__.forEach(s, (c) => {\n    o.push(\n      /* @__PURE__ */ r.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_4__.Menu.Label, { children: c[0].group }, c[0].group)\n    );\n    for (const u of c)\n      o.push(\n        /* @__PURE__ */ r.jsx(\n          On,\n          {\n            name: u.name,\n            icon: u.icon,\n            hint: u.hint,\n            shortcut: u.shortcut,\n            isSelected: e.keyboardHoveredItemIndex === i,\n            set: () => e.itemCallback(u)\n          },\n          u.name\n        )\n      ), i++;\n  }), /* @__PURE__ */ r.jsx(\n    _mantine_core__WEBPACK_IMPORTED_MODULE_4__.Menu,\n    {\n      defaultOpened: !0,\n      trigger: \"hover\",\n      closeDelay: 1e7,\n      children: /* @__PURE__ */ r.jsx(\n        _mantine_core__WEBPACK_IMPORTED_MODULE_4__.Menu.Dropdown,\n        {\n          onMouseDown: (c) => c.preventDefault(),\n          className: n.root,\n          children: o.length > 0 ? o : /* @__PURE__ */ r.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_4__.Menu.Item, { children: \"No match found\" })\n        }\n      )\n    }\n  );\n}\nconst An = (e) => {\n  const [n, o] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), [i, s] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(), [c, u] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(), g = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => e.editor.slashMenu.onUpdate((S) => {\n    o(S.show), s(S.filteredItems), u(S.keyboardHoveredItemIndex), g.current = S.referencePos;\n  }), [e.editor]);\n  const a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(\n    () => {\n      if (g.current)\n        return () => g.current;\n    },\n    [g.current]\n    // eslint-disable-line\n  ), { ref: y, updateMaxHeight: h } = xe(), p = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    if (!i || c === void 0)\n      return null;\n    const S = e.slashMenu || Fn;\n    return /* @__PURE__ */ r.jsx(\"div\", { ref: y, children: /* @__PURE__ */ r.jsx(\n      S,\n      {\n        filteredItems: i,\n        itemCallback: (T) => e.editor.slashMenu.itemCallback(T),\n        keyboardHoveredItemIndex: c\n      }\n    ) });\n  }, [\n    i,\n    c,\n    e.editor.slashMenu,\n    e.slashMenu,\n    y\n  ]);\n  return /* @__PURE__ */ r.jsx(\n    _tippyjs_react__WEBPACK_IMPORTED_MODULE_5__,\n    {\n      onShow: h,\n      appendTo: e.editor.domElement.parentElement,\n      content: p,\n      getReferenceClientRect: a,\n      interactive: !0,\n      visible: n,\n      animation: \"fade\",\n      placement: \"bottom-start\",\n      zIndex: 2e3\n    }\n  );\n}, k = [\n  \"#FFFFFF\",\n  \"#EFEFEF\",\n  \"#CFCFCF\",\n  \"#AFAFAF\",\n  \"#7F7F7F\",\n  \"#3F3F3F\",\n  \"#1F1F1F\",\n  \"#161616\",\n  \"#0F0F0F\",\n  \"#000000\"\n], ve = {\n  colors: {\n    editor: {\n      text: k[5],\n      background: k[0]\n    },\n    menu: {\n      text: k[5],\n      background: k[0]\n    },\n    tooltip: {\n      text: k[5],\n      background: k[1]\n    },\n    hovered: {\n      text: k[5],\n      background: k[1]\n    },\n    selected: {\n      text: k[0],\n      background: k[5]\n    },\n    disabled: {\n      text: k[3],\n      background: k[1]\n    },\n    shadow: k[2],\n    border: k[1],\n    sideMenu: k[2],\n    highlightColors: {\n      gray: {\n        text: \"#9b9a97\",\n        background: \"#ebeced\"\n      },\n      brown: {\n        text: \"#64473a\",\n        background: \"#e9e5e3\"\n      },\n      red: {\n        text: \"#e03e3e\",\n        background: \"#fbe4e4\"\n      },\n      orange: {\n        text: \"#d9730d\",\n        background: \"#f6e9d9\"\n      },\n      yellow: {\n        text: \"#dfab01\",\n        background: \"#fbf3db\"\n      },\n      green: {\n        text: \"#4d6461\",\n        background: \"#ddedea\"\n      },\n      blue: {\n        text: \"#0b6e99\",\n        background: \"#ddebf1\"\n      },\n      purple: {\n        text: \"#6940a5\",\n        background: \"#eae4f2\"\n      },\n      pink: {\n        text: \"#ad1a72\",\n        background: \"#f4dfeb\"\n      }\n    }\n  },\n  borderRadius: 6,\n  fontFamily: '\"Inter\", \"SF Pro Display\", -apple-system, BlinkMacSystemFont, \"Open Sans\", \"Segoe UI\", \"Roboto\", \"Oxygen\", \"Ubuntu\", \"Cantarell\", \"Fira Sans\", \"Droid Sans\", \"Helvetica Neue\", sans-serif'\n}, dt = {\n  colors: {\n    editor: {\n      text: k[2],\n      background: k[6]\n    },\n    menu: {\n      text: k[2],\n      background: k[6]\n    },\n    tooltip: {\n      text: k[2],\n      background: k[7]\n    },\n    hovered: {\n      text: k[2],\n      background: k[7]\n    },\n    selected: {\n      text: k[2],\n      background: k[8]\n    },\n    disabled: {\n      text: k[5],\n      background: k[7]\n    },\n    shadow: k[8],\n    border: k[7],\n    sideMenu: k[4],\n    highlightColors: {\n      gray: {\n        text: \"#bebdb8\",\n        background: \"#9b9a97\"\n      },\n      brown: {\n        text: \"#8e6552\",\n        background: \"#64473a\"\n      },\n      red: {\n        text: \"#ec4040\",\n        background: \"#be3434\"\n      },\n      orange: {\n        text: \"#e3790d\",\n        background: \"#b7600a\"\n      },\n      yellow: {\n        text: \"#dfab01\",\n        background: \"#b58b00\"\n      },\n      green: {\n        text: \"#6b8b87\",\n        background: \"#4d6461\"\n      },\n      blue: {\n        text: \"#0e87bc\",\n        background: \"#0b6e99\"\n      },\n      purple: {\n        text: \"#8552d7\",\n        background: \"#6940a5\"\n      },\n      pink: {\n        text: \"#da208f\",\n        background: \"#ad1a72\"\n      }\n    }\n  },\n  borderRadius: ve.borderRadius,\n  fontFamily: ve.fontFamily\n}, Ln = (e) => {\n  const [n, o] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), [i, s] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(), c = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => (_tippyjs_react__WEBPACK_IMPORTED_MODULE_5__.tippy.setDefaultProps({ maxWidth: \"\" }), e.editor.imageToolbar.onUpdate((a) => {\n    o(a.show), s(a.block), c.current = a.referencePos;\n  })), [e.editor]);\n  const u = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(\n    () => {\n      if (c)\n        return () => c.current;\n    },\n    [c.current]\n    // eslint-disable-line\n  ), g = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    const a = e.imageToolbar || Et;\n    return /* @__PURE__ */ r.jsx(a, { editor: e.editor, block: i });\n  }, [i, e.editor, e.imageToolbar]);\n  return /* @__PURE__ */ r.jsx(\n    _tippyjs_react__WEBPACK_IMPORTED_MODULE_5__,\n    {\n      appendTo: e.editor.domElement.parentElement,\n      content: g,\n      getReferenceClientRect: u,\n      interactive: !0,\n      visible: n,\n      animation: \"fade\",\n      placement: \"bottom\",\n      zIndex: 5e3\n    }\n  );\n};\nfunction Vn(e) {\n  var u;\n  const { classes: n } = (0,_mantine_core__WEBPACK_IMPORTED_MODULE_4__.createStyles)({ root: {} })(void 0, {\n    name: \"Editor\"\n  }), { editor: o, children: i, className: s, ...c } = e;\n  return /* @__PURE__ */ r.jsx(\n    _tiptap_react__WEBPACK_IMPORTED_MODULE_7__.EditorContent,\n    {\n      editor: (u = e.editor) == null ? void 0 : u._tiptapEditor,\n      className: (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.mergeCSSClasses)(n.root, e.className || \"\"),\n      ...c,\n      children: e.children || /* @__PURE__ */ r.jsxs(r.Fragment, { children: [\n        /* @__PURE__ */ r.jsx(kn, { editor: e.editor }),\n        /* @__PURE__ */ r.jsx(Cn, { editor: e.editor }),\n        /* @__PURE__ */ r.jsx(An, { editor: e.editor }),\n        /* @__PURE__ */ r.jsx(Bn, { editor: e.editor }),\n        /* @__PURE__ */ r.jsx(Ln, { editor: e.editor })\n      ] })\n    }\n  );\n}\nfunction eo(e) {\n  const {\n    theme: n = { light: ve, dark: dt },\n    ...o\n  } = e, i = use_prefers_color_scheme__WEBPACK_IMPORTED_MODULE_2__(), s = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => n === \"light\" ? fe(ve) : n === \"dark\" ? fe(dt) : \"light\" in n && \"dark\" in n ? fe(\n    n[i === \"dark\" ? \"dark\" : \"light\"]\n  ) : fe(n), [i, n]);\n  return /* @__PURE__ */ r.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_4__.MantineProvider, { theme: s, children: /* @__PURE__ */ r.jsx(Vn, { ...o }) });\n}\nconst Un = {\n  Heading: {\n    group: \"Headings\",\n    icon: /* @__PURE__ */ r.jsx(kt, { size: 18 }),\n    hint: \"Used for a top-level heading\",\n    shortcut: A(\"Mod-Alt-1\")\n  },\n  \"Heading 2\": {\n    group: \"Headings\",\n    icon: /* @__PURE__ */ r.jsx(yt, { size: 18 }),\n    hint: \"Used for key sections\",\n    shortcut: A(\"Mod-Alt-2\")\n  },\n  \"Heading 3\": {\n    group: \"Headings\",\n    icon: /* @__PURE__ */ r.jsx(pt, { size: 18 }),\n    hint: \"Used for subsections and group headings\",\n    shortcut: A(\"Mod-Alt-3\")\n  },\n  \"Numbered List\": {\n    group: \"Basic blocks\",\n    icon: /* @__PURE__ */ r.jsx(jt, { size: 18 }),\n    hint: \"Used to display a numbered list\",\n    shortcut: A(\"Mod-Alt-7\")\n  },\n  \"Bullet List\": {\n    group: \"Basic blocks\",\n    icon: /* @__PURE__ */ r.jsx(Tt, { size: 18 }),\n    hint: \"Used to display an unordered list\",\n    shortcut: A(\"Mod-Alt-9\")\n  },\n  Paragraph: {\n    group: \"Basic blocks\",\n    icon: /* @__PURE__ */ r.jsx(ie, { size: 18 }),\n    hint: \"Used for the body of your document\",\n    shortcut: A(\"Mod-Alt-0\")\n  },\n  Image: {\n    group: \"Media\",\n    icon: /* @__PURE__ */ r.jsx(qr, {}),\n    hint: \"Insert an image\"\n  }\n};\nfunction Nn(e = _blocknote_core__WEBPACK_IMPORTED_MODULE_1__.defaultBlockSchema) {\n  return (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.getDefaultSlashMenuItems)(e).map((o) => ({\n    ...o,\n    ...Un[o.name]\n  }));\n}\nconst $n = (e) => new _blocknote_core__WEBPACK_IMPORTED_MODULE_1__.BlockNoteEditor({\n  slashMenuItems: Nn(\n    e.blockSchema || _blocknote_core__WEBPACK_IMPORTED_MODULE_1__.defaultBlockSchema\n  ),\n  ...e\n}), to = (e = {}, n = []) => {\n  const o = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => (o.current && o.current._tiptapEditor.destroy(), o.current = $n(e), o.current), n);\n};\nfunction Wn() {\n  const [, e] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n  return () => e((n) => n + 1);\n}\nconst ro = (e) => {\n  const n = Wn();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const o = () => {\n      requestAnimationFrame(() => {\n        requestAnimationFrame(() => {\n          n();\n        });\n      });\n    };\n    return e.on(\"transaction\", o), () => {\n      e.off(\"transaction\", o);\n    };\n  }, [e]);\n}, It = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({}), no = (e) => {\n  const n = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(It).inlineContent || {}, o = (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.mergeCSSClasses)(\n    e.className || \"\",\n    _blocknote_core__WEBPACK_IMPORTED_MODULE_1__.blockStyles.inlineContent,\n    n.class\n  );\n  return /* @__PURE__ */ r.jsx(\n    _tiptap_react__WEBPACK_IMPORTED_MODULE_7__.NodeViewContent,\n    {\n      ...Object.fromEntries(\n        Object.entries(n).filter(\n          ([i]) => i !== \"class\"\n        )\n      ),\n      ...e,\n      className: o\n    }\n  );\n};\nfunction oo(e) {\n  return {\n    node: (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.createTipTapBlock)({\n      name: e.type,\n      content: e.containsInlineContent ? \"inline*\" : \"\",\n      selectable: !0,\n      addAttributes() {\n        return (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.propsToAttributes)(e);\n      },\n      parseHTML() {\n        return (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.parse)(e);\n      },\n      renderHTML({ HTMLAttributes: o }) {\n        return (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.render)(e, o);\n      },\n      addNodeView() {\n        return (0,_tiptap_react__WEBPACK_IMPORTED_MODULE_7__.ReactNodeViewRenderer)((i) => {\n          var T;\n          const s = e.render, c = ((T = this.options.domAttributes) == null ? void 0 : T.blockContent) || {}, u = {};\n          for (const [D, le] of Object.entries(i.node.attrs))\n            D in e.propSchema && le !== e.propSchema[D].default && (u[(0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.camelToDataKebab)(D)] = le);\n          const g = this.options.editor, a = typeof i.getPos == \"function\" ? i.getPos() : void 0, p = g._tiptapEditor.state.doc.resolve(a).node().attrs.id, S = g.getBlock(p);\n          if (S.type !== e.type)\n            throw new Error(\"Block type does not match\");\n          return /* @__PURE__ */ r.jsx(\n            _tiptap_react__WEBPACK_IMPORTED_MODULE_7__.NodeViewWrapper,\n            {\n              ...Object.fromEntries(\n                Object.entries(c).filter(\n                  ([D]) => D !== \"class\"\n                )\n              ),\n              className: (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.mergeCSSClasses)(\n                _blocknote_core__WEBPACK_IMPORTED_MODULE_1__.blockStyles.blockContent,\n                c.class\n              ),\n              \"data-content-type\": e.type,\n              ...u,\n              children: /* @__PURE__ */ r.jsx(\n                It.Provider,\n                {\n                  value: this.options.domAttributes || {},\n                  children: /* @__PURE__ */ r.jsx(s, { block: S, editor: g })\n                }\n              )\n            }\n          );\n        }, {\n          className: _blocknote_core__WEBPACK_IMPORTED_MODULE_1__.blockStyles.reactNodeViewRenderer\n        });\n      }\n    }),\n    propSchema: e.propSchema\n  };\n}\n\n//# sourceMappingURL=blocknote-react.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJsb2Nrbm90ZS9yZWFjdC9kaXN0L2Jsb2Nrbm90ZS1yZWFjdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStKO0FBQ2lHO0FBQ1g7QUFDdEg7QUFDckY7QUFDYjtBQUNOO0FBQ3lCO0FBQ1I7QUFDeEMsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtDQUFDLDRMQUE0TDtBQUN2TTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEtBQXFDO0FBQzdELFlBQVksa0NBQUM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsT0FBTztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2Isc0JBQXNCO0FBQ3RCO0FBQ0EsYUFBYTtBQUNiLHNCQUFzQjtBQUN0QjtBQUNBLGFBQWE7QUFDYix1QkFBdUI7QUFDdkI7QUFDQSxhQUFhO0FBQ2IsdUJBQXVCO0FBQ3ZCO0FBQ0EsYUFBYTtBQUNiLGdDQUFnQztBQUNoQztBQUNBLGFBQWE7QUFDYiwwQkFBMEI7QUFDMUI7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxtQ0FBbUM7QUFDM0U7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0Y7QUFDL0Y7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxtR0FBbUc7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHNCQUFzQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLE1BQXFDLEdBQUcsQ0FBaUI7QUFDekQ7QUFDQTtBQUNBLDBCQUEwQixnQkFBZ0Isb0JBQW9CLGdCQUFnQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsU0FBUyxnQ0FBZ0MsWUFBWSxlQUFlLFlBQVksZ0NBQWdDO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix5Q0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix5Q0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsaUJBQWlCO0FBQ2xEO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkY7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsK0JBQStCLGlCQUFpQjtBQUNoRDtBQUNBLGFBQWE7QUFDYjtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkY7QUFDM0Y7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlCQUFpQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlDQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix5Q0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlDQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLHFCQUFxQix3REFBQyxVQUFVLEdBQUcsd0RBQUMsZUFBZSxZQUFZLHdEQUFDLFdBQVcsR0FBRyx3REFBQyxlQUFlO0FBQzlGO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EscUJBQXFCLHdEQUFDLFlBQVk7QUFDbEMsdUJBQXVCLHdEQUFDLFlBQVk7QUFDcEMseUJBQXlCLHdEQUFDLFlBQVk7QUFDdEMsK0NBQStDLGtCQUFrQjtBQUNqRTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxFQUFFO0FBQzNDLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLEVBQUU7QUFDakQsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IseUNBQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix5Q0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix5Q0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlDQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix5Q0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsT0FBTyxpREFBRTtBQUNWLFVBQVUsYUFBYSxFQUFFLDJEQUFDLEdBQUcsVUFBVTtBQUN2QztBQUNBLEdBQUc7QUFDSDtBQUNBLElBQUksZ0RBQUU7QUFDTjtBQUNBLGtDQUFrQyxRQUFRLEVBQUUsWUFBWTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsT0FBTyxnREFBZSxJQUFJLGdEQUFlO0FBQzFDO0FBQ0EsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsY0FBYztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnREFBZTtBQUMxQjtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnREFBZTtBQUMxQixnQkFBZ0I7QUFDaEIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvR0FBb0csZ0RBQWU7QUFDbkg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLLFFBQVEsZ0RBQWU7QUFDNUI7QUFDQSx5QkFBeUIsZ0RBQWU7QUFDeEM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGFBQWEsb0JBQW9CLHNCQUFzQixZQUFZLGtCQUFrQixZQUFZLHFCQUFxQixvQ0FBb0MsSUFBSSxxQkFBcUIsMEpBQTBKLEdBQUcsR0FBRztBQUNuVjtBQUNBO0FBQ0EsYUFBYSxvQkFBb0Isc0JBQXNCLFlBQVksa0JBQWtCLFlBQVkscUJBQXFCLG9DQUFvQyxJQUFJLHFCQUFxQixxRUFBcUUsR0FBRyxHQUFHO0FBQzlQO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQixzQkFBc0IsWUFBWSxrQkFBa0IsWUFBWSxxQkFBcUIsb0NBQW9DLElBQUkscUJBQXFCLG9FQUFvRSxHQUFHLEdBQUc7QUFDN1A7QUFDQTtBQUNBLGFBQWEsb0JBQW9CLHNCQUFzQixZQUFZLGtCQUFrQixZQUFZLHFCQUFxQixvQ0FBb0MsSUFBSSxxQkFBcUIsb0VBQW9FLEdBQUcsR0FBRztBQUM3UDtBQUNBO0FBQ0EsYUFBYSxvQkFBb0Isc0JBQXNCLFlBQVksa0JBQWtCLFlBQVkscUJBQXFCLG9DQUFvQyxJQUFJLHFCQUFxQixxRUFBcUUsR0FBRyxHQUFHO0FBQzlQO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQixzQkFBc0IsWUFBWSxrQkFBa0IsWUFBWSxxQkFBcUIsb0NBQW9DLElBQUkscUJBQXFCLG1LQUFtSyxHQUFHLEdBQUc7QUFDNVY7QUFDQTtBQUNBLGFBQWEsb0JBQW9CLHNCQUFzQixZQUFZLGtCQUFrQixZQUFZLHFCQUFxQixvQ0FBb0MsSUFBSSxxQkFBcUIscUZBQXFGLEdBQUcsR0FBRztBQUM5UTtBQUNBO0FBQ0EsYUFBYSxvQkFBb0Isc0JBQXNCLFlBQVksa0JBQWtCLFlBQVkscUJBQXFCLG9DQUFvQyxJQUFJLHFCQUFxQixtUkFBbVIsR0FBRyxHQUFHO0FBQzVjO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQixzQkFBc0IsWUFBWSxrQkFBa0IsWUFBWSxxQkFBcUIsb0NBQW9DLElBQUkscUJBQXFCLCtTQUErUyxHQUFHLEdBQUc7QUFDeGU7QUFDQTtBQUNBLGFBQWEsb0JBQW9CLHNCQUFzQixZQUFZLGtCQUFrQixZQUFZLHFCQUFxQixvQ0FBb0MsSUFBSSxxQkFBcUIsMkZBQTJGLEdBQUcsR0FBRztBQUNwUjtBQUNBO0FBQ0EsYUFBYSxvQkFBb0Isc0JBQXNCLFlBQVksa0JBQWtCLFlBQVkscUJBQXFCLG9DQUFvQyxJQUFJLHFCQUFxQiwyRkFBMkYsR0FBRyxHQUFHO0FBQ3BSO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQixzQkFBc0IsWUFBWSxrQkFBa0IsWUFBWSxxQkFBcUIsb0NBQW9DLElBQUkscUJBQXFCLGdFQUFnRSxHQUFHLEdBQUc7QUFDelA7QUFDQTtBQUNBLGFBQWEsb0JBQW9CLHNCQUFzQixZQUFZLGtCQUFrQixZQUFZLHFCQUFxQixvQ0FBb0MsSUFBSSxxQkFBcUIsdVdBQXVXLEdBQUcsR0FBRztBQUNoaUI7QUFDQTtBQUNBLGFBQWEsb0JBQW9CLHNCQUFzQixZQUFZLGtCQUFrQixZQUFZLHFCQUFxQixvQ0FBb0MsSUFBSSxxQkFBcUIsaVVBQWlVLEdBQUcsR0FBRztBQUMxZjtBQUNBO0FBQ0EsYUFBYSxvQkFBb0Isc0JBQXNCLFlBQVksa0JBQWtCLFlBQVkscUJBQXFCLG9DQUFvQyxJQUFJLHFCQUFxQiwwSkFBMEosR0FBRyxHQUFHO0FBQ25WO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQixzQkFBc0IsWUFBWSxrQkFBa0IsWUFBWSxxQkFBcUIsb0NBQW9DLElBQUkscUJBQXFCLHVMQUF1TCxHQUFHLEdBQUc7QUFDaFg7QUFDQTtBQUNBLGFBQWEsb0JBQW9CLHNCQUFzQixZQUFZLGtCQUFrQixZQUFZLHFCQUFxQixvQ0FBb0MsSUFBSSxxQkFBcUIscWpCQUFxakIsR0FBRyxHQUFHO0FBQzl1QjtBQUNBO0FBQ0EsYUFBYSxvQkFBb0Isc0JBQXNCLFlBQVksa0JBQWtCLFlBQVkscUJBQXFCLG9DQUFvQyxJQUFJLHFCQUFxQixnQ0FBZ0MsR0FBRyxHQUFHO0FBQ3pOO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQixzQkFBc0IsWUFBWSxrQkFBa0IsWUFBWSxxQkFBcUIsb0NBQW9DLElBQUkscUJBQXFCLHVFQUF1RSxHQUFHLEdBQUc7QUFDaFE7QUFDQTtBQUNBLGFBQWEsb0JBQW9CLHNCQUFzQixZQUFZLGtCQUFrQixZQUFZLHFCQUFxQixvQ0FBb0MsSUFBSSxxQkFBcUIsb0tBQW9LLEdBQUcsR0FBRztBQUM3VjtBQUNBO0FBQ0EsYUFBYSxvQkFBb0Isc0JBQXNCLFlBQVksa0JBQWtCLFlBQVkscUJBQXFCLG9DQUFvQyxJQUFJLHFCQUFxQiw2VkFBNlYsR0FBRyxHQUFHO0FBQ3RoQjtBQUNBO0FBQ0EsYUFBYSxvQkFBb0Isc0JBQXNCLFlBQVksa0JBQWtCLFlBQVkscUJBQXFCLG9DQUFvQyxJQUFJLHFCQUFxQix3SUFBd0ksR0FBRyxHQUFHO0FBQ2pVO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQiwyREFBMkQsWUFBWSxxQkFBcUIsbVBBQW1QLEdBQUc7QUFDblg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLCtDQUFDO0FBQ0w7QUFDQTtBQUNBLDRDQUE0QyxVQUFVO0FBQ3RELCtEQUErRCxVQUFVO0FBQ3pFO0FBQ0EsdUNBQXVDLFNBQVMsK0JBQStCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CLG1FQUFtRSxZQUFZLHFCQUFxQixxS0FBcUssR0FBRztBQUM3UztBQUNBO0FBQ0EsYUFBYSxvQkFBb0IsbUVBQW1FLFlBQVkscUJBQXFCLHFLQUFxSyxHQUFHO0FBQzdTO0FBQ0EsV0FBVyxpREFBRTtBQUNiO0FBQ0E7QUFDQSxJQUFJLGlEQUFFO0FBQ047QUFDQSxnREFBZ0QsVUFBVTtBQUMxRCw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLFlBQVksNkNBQUM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBLFlBQVk7QUFDWjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCw2QkFBNkI7QUFDbkY7QUFDQSxJQUFJLCtDQUFDO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwrQ0FBQyxXQUFXO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCx1Q0FBdUMsd0NBQXdDLCtDQUFDLGFBQWEseURBQXlELE1BQU0sWUFBWSxHQUFHO0FBQzNLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGdEQUFDO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUUsZ0RBQUM7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLCtDQUFDO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLCtDQUFDO0FBQ25DO0FBQ0EsU0FBUyw4Q0FBQztBQUNWO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsNkJBQTZCLDhDQUFDO0FBQ2pDO0FBQ0E7QUFDQSxTQUFTLDhDQUFDO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUcsbUNBQW1DLFVBQVU7QUFDaEQsQ0FBQztBQUNELFVBQVUsYUFBYSxFQUFFLDJEQUFDLEdBQUcsVUFBVTtBQUN2QztBQUNBLEdBQUc7QUFDSCxnQ0FBZ0MsZ0RBQUUsSUFBSTtBQUN0QywwQkFBMEIsK0NBQUUsSUFBSSxxQ0FBcUM7QUFDckUsZ0RBQWdELCtDQUFFLElBQUksMENBQTBDO0FBQ2hHLEtBQUs7QUFDTCxDQUFDLE1BQU0saURBQUU7QUFDVDtBQUNBO0FBQ0E7QUFDQSxNQUFNLDJDQUFDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlEQUFFO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUscURBQUU7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQ0FBa0MsK0NBQUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBLFNBQVMsOENBQUM7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsNkJBQTZCLDhDQUFDO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLEdBQUcsWUFBWSxrREFBQztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSxTQUFTLDhDQUFDO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxVQUFVLGFBQWEsRUFBRSwyREFBQyxHQUFHLFVBQVU7QUFDdkM7QUFDQSxHQUFHO0FBQ0g7QUFDQSxJQUFJLDhDQUFFO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZ0VBQWdFO0FBQ2hFLDBCQUEwQiwrQ0FBQyxVQUFVLGtCQUFrQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLCtDQUFDO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwwQ0FBMEMsZ0NBQWdDO0FBQzFFLHVFQUF1RSxtQkFBbUIsc0JBQXNCLG1DQUFtQyxTQUFTLCtCQUErQjtBQUMzTDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSyx3RUFBd0U7QUFDN0UsMEJBQTBCLCtDQUFDLFVBQVUsd0JBQXdCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sK0NBQUM7QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDBDQUEwQyxzQ0FBc0M7QUFDaEYsNkVBQTZFLG1CQUFtQixzQkFBc0IsbUNBQW1DLFNBQVMsK0JBQStCO0FBQ2pNO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsOENBQThDO0FBQzlDLCtCQUErQjtBQUMvQiwrQkFBK0I7QUFDL0IsS0FBSztBQUNMLENBQUM7QUFDRCxrQ0FBa0MsK0NBQUM7QUFDbkM7QUFDQSxjQUFjLCtDQUFDO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFVBQVUsNkJBQTZCLFlBQVksa0RBQUM7QUFDcEQ7QUFDQSxrRUFBa0UsY0FBYyx5QkFBeUIsY0FBYztBQUN2SCxLQUFLO0FBQ0w7QUFDQSxTQUFTLGtEQUFDO0FBQ1Y7QUFDQSxrRUFBa0Usb0JBQW9CLHlCQUF5QixvQkFBb0I7QUFDbkksS0FBSztBQUNMO0FBQ0E7QUFDQSxTQUFTLDhDQUFDO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGdDQUFnQywrQ0FBQyxJQUFJO0FBQ3hDLDBCQUEwQiwrQ0FBQyxXQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxtQ0FBbUMsd0NBQXdDLCtDQUFDLGFBQWE7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxHQUFHO0FBQ1YsS0FBSztBQUNMLENBQUM7QUFDRCxpQkFBaUIsK0NBQUM7QUFDbEI7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLGtEQUFDO0FBQ2I7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsaUJBQWlCLCtDQUFDO0FBQ2xCO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsWUFBWSxrREFBQztBQUNiO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGlCQUFpQiwrQ0FBQyxVQUFVLGtEQUFDO0FBQzdCO0FBQ0EsR0FBRyxXQUFXLGtEQUFDO0FBQ2Y7QUFDQSxHQUFHO0FBQ0g7QUFDQSxJQUFJLDJDQUFDO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsT0FBTyxpREFBRSxJQUFJLG9CQUFvQjtBQUNsQyxVQUFVLGFBQWEsRUFBRSwyREFBQyxHQUFHLFVBQVU7QUFDdkM7QUFDQSxHQUFHO0FBQ0g7QUFDQSxJQUFJLGdEQUFFO0FBQ047QUFDQTtBQUNBLGlCQUFpQixnRUFBRTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxRQUFRLG9EQUFFO0FBQ1YsUUFBUSxvREFBRTtBQUNWLENBQUM7QUFDRDtBQUNBLCtCQUErQixnREFBRSxJQUFJLHFDQUFxQyw2Q0FBNkMsb0JBQW9CLEdBQUc7QUFDOUksQ0FBQyxPQUFPLGlEQUFFLElBQUksa0NBQWtDO0FBQ2hELGlCQUFpQiwrQ0FBQyxjQUFjLCtDQUFDO0FBQ2pDLEVBQUUsZ0RBQUM7QUFDSDtBQUNBLEdBQUc7QUFDSCxZQUFZLGtEQUFDO0FBQ2I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLFNBQVMsa0RBQUM7QUFDVjtBQUNBO0FBQ0EsU0FBUyxrREFBQztBQUNWO0FBQ0E7QUFDQSxTQUFTLGtEQUFDO0FBQ1Y7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNELGtDQUFrQywrQ0FBQztBQUNuQztBQUNBLGNBQWMsK0NBQUM7QUFDZjtBQUNBO0FBQ0EsR0FBRztBQUNILFlBQVksa0RBQUM7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxTQUFTLDhDQUFDO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLHNDQUFzQztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDRCQUE0QjtBQUM1RCxLQUFLO0FBQ0wsQ0FBQztBQUNELGlCQUFpQiwrQ0FBQztBQUNsQjtBQUNBLGNBQWMsK0NBQUMsZUFBZSwrQ0FBQztBQUMvQixFQUFFLGdEQUFDO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsWUFBWSxrREFBQztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGNBQWMsK0NBQUMsVUFBVSxrREFBQztBQUMxQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsU0FBUyxrREFBQztBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxTQUFTLGtEQUFDO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCx1Q0FBdUMsK0NBQUMsSUFBSTtBQUM1QyxtQ0FBbUMseURBQUUsSUFBSSxZQUFZO0FBQ3JELCtCQUErQiwrQ0FBQyxTQUFTO0FBQ3pDLGtFQUFrRSwrQ0FBQyxRQUFRLGdFQUFnRTtBQUMzSSxnQ0FBZ0MsK0NBQUMsUUFBUSw2REFBNkQ7QUFDdEcsV0FBVztBQUNYLGdFQUFnRSwrQ0FBQyxVQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxnQkFBZ0Isb0RBQUU7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QywrQ0FBRSxJQUFJLGlDQUFpQyxxQkFBcUIsb0NBQW9DO0FBQ3pJO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsOEJBQThCLCtDQUFDLFVBQVU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZ0JBQWdCLG9EQUFFO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixlQUFlO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlEQUFFO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRCxrQ0FBa0MsK0NBQUM7QUFDbkMsU0FBUyxnREFBQztBQUNWO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJLDJDQUFDO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDZCQUE2Qiw4Q0FBQztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsK0NBQUM7QUFDZjtBQUNBO0FBQ0EsRUFBRSxnREFBQztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtEQUFDO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLFNBQVMsa0RBQUM7QUFDVjtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLENBQUMsMkNBQTJDO0FBQzVDLDhCQUE4Qix1Q0FBdUM7QUFDckUsOEJBQThCLGtCQUFrQjtBQUNoRCw4QkFBOEIsa0JBQWtCO0FBQ2hELDhCQUE4Qix3Q0FBd0M7QUFDdEUsOEJBQThCLDBDQUEwQztBQUN4RSw4QkFBOEIsNkNBQTZDO0FBQzNFLDhCQUE4QiwwQ0FBMEM7QUFDeEUsOEJBQThCLHlDQUF5QztBQUN2RSw4QkFBOEIsMkNBQTJDO0FBQ3pFLDhCQUE4QiwwQ0FBMEM7QUFDeEUsOEJBQThCLGtCQUFrQjtBQUNoRCw4QkFBOEIsa0JBQWtCO0FBQ2hELDhCQUE4QixrQkFBa0I7QUFDaEQsOEJBQThCLGtCQUFrQjtBQUNoRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsaUJBQWlCLCtDQUFDLGVBQWUsK0NBQUM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw2Q0FBQztBQUNWLEVBQUUsZ0RBQUMsUUFBUSxpREFBRSxtQkFBbUIsY0FBYztBQUM5QztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsWUFBWSw4Q0FBQztBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsU0FBUyw4Q0FBQztBQUNWO0FBQ0Esc0NBQXNDLGtCQUFrQjtBQUN4RCxHQUFHO0FBQ0g7QUFDQSxJQUFJLDJDQUFDO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLFFBQVEsNENBQUU7QUFDWCxpQkFBaUIsK0NBQUMsVUFBVSw2Q0FBQztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxpQkFBaUIsK0NBQUMsZUFBZSwrQ0FBQyxhQUFhLCtDQUFDLFFBQVEsNkNBQUM7QUFDekQsRUFBRSxnREFBQztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhDQUFDO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxTQUFTLDhDQUFDO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLElBQUksMkNBQUM7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELFVBQVUsYUFBYSxFQUFFLDJEQUFDLEdBQUcsVUFBVTtBQUN2QztBQUNBLEdBQUc7QUFDSCwrQkFBK0IsZ0RBQUUsSUFBSSxxREFBcUQ7QUFDMUY7QUFDQTtBQUNBLGFBQWEsb0JBQW9CLHlFQUF5RSxZQUFZLHFCQUFxQixhQUFhLElBQUkscUJBQXFCLDhFQUE4RSxJQUFJLHFCQUFxQiw4RUFBOEUsR0FBRztBQUN6VztBQUNBLHdDQUF3QyxxREFBRSxJQUFJLGdDQUFnQywyQ0FBMkM7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsYUFBYSxvQkFBb0Isc0JBQXNCLFlBQVkscUJBQXFCLHNDQUFzQyxJQUFJLHFCQUFxQiw0U0FBNFMsR0FBRztBQUN0YztBQUNBO0FBQ0EsVUFBVSxhQUFhLEVBQUUsMkRBQUMsR0FBRyxVQUFVO0FBQ3ZDO0FBQ0EsR0FBRztBQUNILCtCQUErQiwrQ0FBQyxhQUFhLDRCQUE0QixxQkFBcUIsd0JBQXdCO0FBQ3RILENBQUM7QUFDRCxVQUFVLG9CQUFvQjtBQUM5QiwrQkFBK0IsK0NBQUMsU0FBUyxtQkFBbUI7QUFDNUQsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwrQ0FBQyxRQUFRLDZCQUE2QixZQUFZLDZDQUFDLFFBQVEsa0RBQUM7QUFDN0U7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHLFdBQVcsa0RBQUM7QUFDZjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLCtDQUFDLElBQUk7QUFDNUMsOEJBQThCLCtDQUFDLFdBQVcsMENBQTBDLFNBQVMsdUNBQXVDO0FBQ3BJLHlDQUF5QyxTQUFTLFNBQVMsd0JBQXdCO0FBQ25GLGdDQUFnQyw4Q0FBRSxJQUFJLFNBQVMsdUNBQXVDLHdDQUF3QyxVQUFVLEdBQUc7QUFDM0ksV0FBVyxHQUFHO0FBQ2QsdUNBQXVDO0FBQ3ZDLFVBQVUsK0NBQUM7QUFDWDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLG1CQUFtQjtBQUNuQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLG1CQUFtQjtBQUNuQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQywyQ0FBMkM7QUFDNUMsOEJBQThCLDBCQUEwQjtBQUN4RCw4QkFBOEIsMEJBQTBCO0FBQ3hELEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSSwrQ0FBQztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLCtDQUFDLFdBQVc7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxzQ0FBc0MscUNBQXFDLEdBQUc7QUFDaEk7QUFDQSxXQUFXO0FBQ1gsbUNBQW1DLGtDQUFrQztBQUNyRTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJDQUEyQztBQUM1Qyw4QkFBOEIsTUFBTTtBQUNwQyw4QkFBOEIsTUFBTTtBQUNwQyxHQUFHO0FBQ0gsaUJBQWlCLCtDQUFDLGVBQWUsK0NBQUMsUUFBUSw2Q0FBQztBQUMzQyxFQUFFLGdEQUFDO0FBQ0g7QUFDQSxHQUFHO0FBQ0gsWUFBWSw4Q0FBQztBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsU0FBUyw4Q0FBQztBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLElBQUksMkNBQUM7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLFlBQVksNkNBQUMsVUFBVSxhQUFhLEVBQUUsMkRBQUMsR0FBRyxVQUFVO0FBQ3BEO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsZ0RBQUM7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILElBQUksK0NBQUM7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLHdEQUF3RCxnREFBRSxJQUFJLGtDQUFrQztBQUNoRyx1Q0FBdUMsZ0RBQUUsSUFBSTtBQUM3Qyw4QkFBOEIsK0NBQUUsSUFBSSx5Q0FBeUM7QUFDN0UsOEJBQThCLCtDQUFFLElBQUksNEJBQTRCO0FBQ2hFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsYUFBYSxFQUFFLDJEQUFDLEdBQUcsVUFBVTtBQUN2QztBQUNBLEdBQUc7QUFDSDtBQUNBLFlBQVksMkNBQVU7QUFDdEIsU0FBUywyQ0FBVTtBQUNuQjtBQUNBLDRCQUE0QiwrQ0FBQyxVQUFVLHNCQUFzQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILElBQUksK0NBQUM7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrQ0FBQztBQUNUO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCwrQ0FBQyxTQUFTLDRCQUE0QjtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsK0NBQUMsZUFBZSwrQ0FBQyxhQUFhLCtDQUFDLFFBQVEsNkNBQUM7QUFDekQsRUFBRSxnREFBQztBQUNIO0FBQ0EsR0FBRztBQUNILFlBQVksOENBQUM7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU8sNkJBQTZCLFlBQVksOENBQUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDJDQUFDO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNELGlCQUFpQiwrQ0FBQyxlQUFlLCtDQUFDLFFBQVEsNkNBQUM7QUFDM0MsRUFBRSxnREFBQyxRQUFRLGlEQUFFLG1CQUFtQixjQUFjO0FBQzlDO0FBQ0EsR0FBRztBQUNILFlBQVksOENBQUM7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFNBQVMsOENBQUM7QUFDVjtBQUNBLHNDQUFzQyw0QkFBNEI7QUFDbEUsR0FBRztBQUNIO0FBQ0EsSUFBSSwyQ0FBQztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGFBQWEsRUFBRSwyREFBQyxHQUFHLFVBQVU7QUFDdkM7QUFDQSxHQUFHLEtBQUssNkNBQTZDO0FBQ3JEO0FBQ0EsSUFBSSx3REFBRTtBQUNOO0FBQ0E7QUFDQSxpQkFBaUIsZ0VBQUU7QUFDbkI7QUFDQSxtRUFBbUU7QUFDbkUsb0NBQW9DLGtCQUFrQjtBQUN0RCxvQ0FBb0Msa0JBQWtCO0FBQ3RELG9DQUFvQyxrQkFBa0I7QUFDdEQsb0NBQW9DLGtCQUFrQjtBQUN0RCxvQ0FBb0Msa0JBQWtCO0FBQ3RELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBLElBQUksU0FBUyxxREFBRSxRQUFRLDhDQUFDO0FBQ3hCO0FBQ0E7QUFDQSwrQkFBK0IsMERBQUUsSUFBSSxnREFBZ0QsTUFBTSxHQUFHO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFVBQVU7QUFDaEQ7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esc0NBQXNDLFVBQVU7QUFDaEQ7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esc0NBQXNDLFVBQVU7QUFDaEQ7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esc0NBQXNDLFVBQVU7QUFDaEQ7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esc0NBQXNDLFVBQVU7QUFDaEQ7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esc0NBQXNDLFVBQVU7QUFDaEQ7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrREFBRTtBQUNsQixTQUFTLHlFQUFFO0FBQ1g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHNCQUFzQiw0REFBRTtBQUN4QjtBQUNBLHFCQUFxQiwrREFBRTtBQUN2QjtBQUNBO0FBQ0EsQ0FBQyxlQUFlO0FBQ2hCLFlBQVksNkNBQUM7QUFDYixTQUFTLDhDQUFDO0FBQ1Y7QUFDQTtBQUNBLGdCQUFnQiwrQ0FBQztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsZ0RBQUM7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQyxPQUFPLG9EQUFFLEdBQUc7QUFDYixZQUFZLGlEQUFFLHdCQUF3QixNQUFNLGdFQUFFO0FBQzlDO0FBQ0EsSUFBSSx3REFBQztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUksMERBQUU7QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0VBQUU7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0VBQUU7QUFDakIsT0FBTztBQUNQO0FBQ0EsZUFBZSxzREFBRTtBQUNqQixPQUFPO0FBQ1AsbUJBQW1CLG1CQUFtQjtBQUN0QyxlQUFlLHVEQUFFO0FBQ2pCLE9BQU87QUFDUDtBQUNBLGVBQWUsb0VBQUU7QUFDakI7QUFDQSw0R0FBNEc7QUFDNUc7QUFDQSxzRUFBc0UsaUVBQUU7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBEQUFFO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdFQUFFO0FBQzNCLGdCQUFnQix3REFBQztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RCx1REFBdUQscUJBQXFCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHFCQUFxQix3REFBQztBQUN0QixTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBOENFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8yOF9ub3Rpb24tY2xvbmUvLi9ub2RlX21vZHVsZXMvQGJsb2Nrbm90ZS9yZWFjdC9kaXN0L2Jsb2Nrbm90ZS1yZWFjdC5qcz85YzkxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBOLCB7IGZvcndhcmRSZWYgYXMgYWUsIHVzZVJlZiBhcyBMLCB1c2VFZmZlY3QgYXMgQiwgdXNlU3RhdGUgYXMgeCwgdXNlTWVtbyBhcyBSLCB1c2VDYWxsYmFjayBhcyB6LCBjcmVhdGVDb250ZXh0IGFzIGZyLCB1c2VDb250ZXh0IGFzIGhyIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBibG9ja1N0eWxlcyBhcyBGLCBtZXJnZUNTU0NsYXNzZXMgYXMgYmUsIGdldERlZmF1bHRTbGFzaE1lbnVJdGVtcyBhcyB2ciwgZGVmYXVsdEJsb2NrU2NoZW1hIGFzIHV0LCBCbG9ja05vdGVFZGl0b3IgYXMgYnIsIGNyZWF0ZVRpcFRhcEJsb2NrIGFzIHhyLCBwcm9wc1RvQXR0cmlidXRlcyBhcyBtciwgcGFyc2UgYXMga3IsIHJlbmRlciBhcyB5ciwgY2FtZWxUb0RhdGFLZWJhYiBhcyBwciB9IGZyb20gXCJAYmxvY2tub3RlL2NvcmVcIjtcbmltcG9ydCB7IGNyZWF0ZVN0eWxlcyBhcyAkLCBHcm91cCBhcyBIZSwgTWVudSBhcyB3LCBCdXR0b24gYXMgSWUsIFN0YWNrIGFzIEJlLCBUZXh0IGFzIG9lLCBBY3Rpb25JY29uIGFzIGd0LCBCb3ggYXMgZnQsIFRleHRJbnB1dCBhcyBodCwgRmlsZUlucHV0IGFzIHZ0LCBUYWJzIGFzIFEsIExvYWRpbmdPdmVybGF5IGFzIENyLCBCYWRnZSBhcyBqciwgTWFudGluZVByb3ZpZGVyIGFzIFRyIH0gZnJvbSBcIkBtYW50aW5lL2NvcmVcIjtcbmltcG9ydCB7IEVkaXRvckNvbnRlbnQgYXMgd3IsIE5vZGVWaWV3Q29udGVudCBhcyBTciwgUmVhY3ROb2RlVmlld1JlbmRlcmVyIGFzIE1yLCBOb2RlVmlld1dyYXBwZXIgYXMgUnIgfSBmcm9tIFwiQHRpcHRhcC9yZWFjdFwiO1xuaW1wb3J0IEVyIGZyb20gXCJ1c2UtcHJlZmVycy1jb2xvci1zY2hlbWVcIjtcbmltcG9ydCAqIGFzIGl0IGZyb20gXCJsb2Rhc2hcIjtcbmltcG9ydCBPIGZyb20gXCJsb2Rhc2hcIjtcbmltcG9ydCBZLCB7IHRpcHB5IGFzIGJ0IH0gZnJvbSBcIkB0aXBweWpzL3JlYWN0XCI7XG5pbXBvcnQgeyBzdGlja3kgYXMgenIgfSBmcm9tIFwidGlwcHkuanNcIjtcbnZhciBNZSA9IHsgZXhwb3J0czoge30gfSwgcmUgPSB7fTtcbi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbnZhciBhdDtcbmZ1bmN0aW9uIEhyKCkge1xuICBpZiAoYXQpXG4gICAgcmV0dXJuIHJlO1xuICBhdCA9IDE7XG4gIHZhciBlID0gTiwgbiA9IFN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpLCBvID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLCBpID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgcyA9IGUuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQuUmVhY3RDdXJyZW50T3duZXIsIGMgPSB7IGtleTogITAsIHJlZjogITAsIF9fc2VsZjogITAsIF9fc291cmNlOiAhMCB9O1xuICBmdW5jdGlvbiB1KGcsIGEsIHkpIHtcbiAgICB2YXIgaCwgcCA9IHt9LCBTID0gbnVsbCwgVCA9IG51bGw7XG4gICAgeSAhPT0gdm9pZCAwICYmIChTID0gXCJcIiArIHkpLCBhLmtleSAhPT0gdm9pZCAwICYmIChTID0gXCJcIiArIGEua2V5KSwgYS5yZWYgIT09IHZvaWQgMCAmJiAoVCA9IGEucmVmKTtcbiAgICBmb3IgKGggaW4gYSlcbiAgICAgIGkuY2FsbChhLCBoKSAmJiAhYy5oYXNPd25Qcm9wZXJ0eShoKSAmJiAocFtoXSA9IGFbaF0pO1xuICAgIGlmIChnICYmIGcuZGVmYXVsdFByb3BzKVxuICAgICAgZm9yIChoIGluIGEgPSBnLmRlZmF1bHRQcm9wcywgYSlcbiAgICAgICAgcFtoXSA9PT0gdm9pZCAwICYmIChwW2hdID0gYVtoXSk7XG4gICAgcmV0dXJuIHsgJCR0eXBlb2Y6IG4sIHR5cGU6IGcsIGtleTogUywgcmVmOiBULCBwcm9wczogcCwgX293bmVyOiBzLmN1cnJlbnQgfTtcbiAgfVxuICByZXR1cm4gcmUuRnJhZ21lbnQgPSBvLCByZS5qc3ggPSB1LCByZS5qc3hzID0gdSwgcmU7XG59XG52YXIgbmUgPSB7fTtcbi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbnZhciBsdDtcbmZ1bmN0aW9uIElyKCkge1xuICByZXR1cm4gbHQgfHwgKGx0ID0gMSwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGZ1bmN0aW9uKCkge1xuICAgIHZhciBlID0gTiwgbiA9IFN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpLCBvID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSwgaSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSwgcyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKSwgYyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKSwgdSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKSwgZyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpLCBhID0gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpLCB5ID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpLCBoID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIiksIHAgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSwgUyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpLCBUID0gU3ltYm9sLmZvcihcInJlYWN0Lm9mZnNjcmVlblwiKSwgRCA9IFN5bWJvbC5pdGVyYXRvciwgbGUgPSBcIkBAaXRlcmF0b3JcIjtcbiAgICBmdW5jdGlvbiBCdCh0KSB7XG4gICAgICBpZiAodCA9PT0gbnVsbCB8fCB0eXBlb2YgdCAhPSBcIm9iamVjdFwiKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBsID0gRCAmJiB0W0RdIHx8IHRbbGVdO1xuICAgICAgcmV0dXJuIHR5cGVvZiBsID09IFwiZnVuY3Rpb25cIiA/IGwgOiBudWxsO1xuICAgIH1cbiAgICB2YXIgSiA9IGUuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG4gICAgZnVuY3Rpb24gSCh0KSB7XG4gICAgICB7XG4gICAgICAgIGZvciAodmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoLCBkID0gbmV3IEFycmF5KGwgPiAxID8gbCAtIDEgOiAwKSwgZiA9IDE7IGYgPCBsOyBmKyspXG4gICAgICAgICAgZFtmIC0gMV0gPSBhcmd1bWVudHNbZl07XG4gICAgICAgIF90KFwiZXJyb3JcIiwgdCwgZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIF90KHQsIGwsIGQpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIGYgPSBKLlJlYWN0RGVidWdDdXJyZW50RnJhbWUsIG0gPSBmLmdldFN0YWNrQWRkZW5kdW0oKTtcbiAgICAgICAgbSAhPT0gXCJcIiAmJiAobCArPSBcIiVzXCIsIGQgPSBkLmNvbmNhdChbbV0pKTtcbiAgICAgICAgdmFyIEMgPSBkLm1hcChmdW5jdGlvbihiKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyhiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIEMudW5zaGlmdChcIldhcm5pbmc6IFwiICsgbCksIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbdF0sIGNvbnNvbGUsIEMpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgRHQgPSAhMSwgUHQgPSAhMSwgT3QgPSAhMSwgRnQgPSAhMSwgQXQgPSAhMSwgRGU7XG4gICAgRGUgPSBTeW1ib2wuZm9yKFwicmVhY3QubW9kdWxlLnJlZmVyZW5jZVwiKTtcbiAgICBmdW5jdGlvbiBMdCh0KSB7XG4gICAgICByZXR1cm4gISEodHlwZW9mIHQgPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIgfHwgdCA9PT0gaSB8fCB0ID09PSBjIHx8IEF0IHx8IHQgPT09IHMgfHwgdCA9PT0geSB8fCB0ID09PSBoIHx8IEZ0IHx8IHQgPT09IFQgfHwgRHQgfHwgUHQgfHwgT3QgfHwgdHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0ICE9PSBudWxsICYmICh0LiQkdHlwZW9mID09PSBTIHx8IHQuJCR0eXBlb2YgPT09IHAgfHwgdC4kJHR5cGVvZiA9PT0gdSB8fCB0LiQkdHlwZW9mID09PSBnIHx8IHQuJCR0eXBlb2YgPT09IGEgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgICAgLy8gdHlwZXMgc3VwcG9ydGVkIGJ5IGFueSBGbGlnaHQgY29uZmlndXJhdGlvbiBhbnl3aGVyZSBzaW5jZVxuICAgICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgICAvLyB3aXRoLlxuICAgICAgdC4kJHR5cGVvZiA9PT0gRGUgfHwgdC5nZXRNb2R1bGVJZCAhPT0gdm9pZCAwKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFZ0KHQsIGwsIGQpIHtcbiAgICAgIHZhciBmID0gdC5kaXNwbGF5TmFtZTtcbiAgICAgIGlmIChmKVxuICAgICAgICByZXR1cm4gZjtcbiAgICAgIHZhciBtID0gbC5kaXNwbGF5TmFtZSB8fCBsLm5hbWUgfHwgXCJcIjtcbiAgICAgIHJldHVybiBtICE9PSBcIlwiID8gZCArIFwiKFwiICsgbSArIFwiKVwiIDogZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gUGUodCkge1xuICAgICAgcmV0dXJuIHQuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFYodCkge1xuICAgICAgaWYgKHQgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBpZiAodHlwZW9mIHQudGFnID09IFwibnVtYmVyXCIgJiYgSChcIlJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIpLCB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHJldHVybiB0LmRpc3BsYXlOYW1lIHx8IHQubmFtZSB8fCBudWxsO1xuICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiB0O1xuICAgICAgc3dpdGNoICh0KSB7XG4gICAgICAgIGNhc2UgaTpcbiAgICAgICAgICByZXR1cm4gXCJGcmFnbWVudFwiO1xuICAgICAgICBjYXNlIG86XG4gICAgICAgICAgcmV0dXJuIFwiUG9ydGFsXCI7XG4gICAgICAgIGNhc2UgYzpcbiAgICAgICAgICByZXR1cm4gXCJQcm9maWxlclwiO1xuICAgICAgICBjYXNlIHM6XG4gICAgICAgICAgcmV0dXJuIFwiU3RyaWN0TW9kZVwiO1xuICAgICAgICBjYXNlIHk6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VcIjtcbiAgICAgICAgY2FzZSBoOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0ID09IFwib2JqZWN0XCIpXG4gICAgICAgIHN3aXRjaCAodC4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgZzpcbiAgICAgICAgICAgIHZhciBsID0gdDtcbiAgICAgICAgICAgIHJldHVybiBQZShsKSArIFwiLkNvbnN1bWVyXCI7XG4gICAgICAgICAgY2FzZSB1OlxuICAgICAgICAgICAgdmFyIGQgPSB0O1xuICAgICAgICAgICAgcmV0dXJuIFBlKGQuX2NvbnRleHQpICsgXCIuUHJvdmlkZXJcIjtcbiAgICAgICAgICBjYXNlIGE6XG4gICAgICAgICAgICByZXR1cm4gVnQodCwgdC5yZW5kZXIsIFwiRm9yd2FyZFJlZlwiKTtcbiAgICAgICAgICBjYXNlIHA6XG4gICAgICAgICAgICB2YXIgZiA9IHQuZGlzcGxheU5hbWUgfHwgbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBmICE9PSBudWxsID8gZiA6IFYodC50eXBlKSB8fCBcIk1lbW9cIjtcbiAgICAgICAgICBjYXNlIFM6IHtcbiAgICAgICAgICAgIHZhciBtID0gdCwgQyA9IG0uX3BheWxvYWQsIGIgPSBtLl9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIFYoYihDKSk7XG4gICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIEsgPSBPYmplY3QuYXNzaWduLCBlZSA9IDAsIE9lLCBGZSwgQWUsIExlLCBWZSwgVWUsIE5lO1xuICAgIGZ1bmN0aW9uICRlKCkge1xuICAgIH1cbiAgICAkZS5fX3JlYWN0RGlzYWJsZWRMb2cgPSAhMDtcbiAgICBmdW5jdGlvbiBVdCgpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKGVlID09PSAwKSB7XG4gICAgICAgICAgT2UgPSBjb25zb2xlLmxvZywgRmUgPSBjb25zb2xlLmluZm8sIEFlID0gY29uc29sZS53YXJuLCBMZSA9IGNvbnNvbGUuZXJyb3IsIFZlID0gY29uc29sZS5ncm91cCwgVWUgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkLCBOZSA9IGNvbnNvbGUuZ3JvdXBFbmQ7XG4gICAgICAgICAgdmFyIHQgPSB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICB2YWx1ZTogJGUsXG4gICAgICAgICAgICB3cml0YWJsZTogITBcbiAgICAgICAgICB9O1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgICAgIGluZm86IHQsXG4gICAgICAgICAgICBsb2c6IHQsXG4gICAgICAgICAgICB3YXJuOiB0LFxuICAgICAgICAgICAgZXJyb3I6IHQsXG4gICAgICAgICAgICBncm91cDogdCxcbiAgICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiB0LFxuICAgICAgICAgICAgZ3JvdXBFbmQ6IHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlZSsrO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBOdCgpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKGVlLS0sIGVlID09PSAwKSB7XG4gICAgICAgICAgdmFyIHQgPSB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICB3cml0YWJsZTogITBcbiAgICAgICAgICB9O1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgICAgIGxvZzogSyh7fSwgdCwge1xuICAgICAgICAgICAgICB2YWx1ZTogT2VcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgaW5mbzogSyh7fSwgdCwge1xuICAgICAgICAgICAgICB2YWx1ZTogRmVcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgd2FybjogSyh7fSwgdCwge1xuICAgICAgICAgICAgICB2YWx1ZTogQWVcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZXJyb3I6IEsoe30sIHQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IExlXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGdyb3VwOiBLKHt9LCB0LCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBWZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBncm91cENvbGxhcHNlZDogSyh7fSwgdCwge1xuICAgICAgICAgICAgICB2YWx1ZTogVWVcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZ3JvdXBFbmQ6IEsoe30sIHQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IE5lXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVlIDwgMCAmJiBIKFwiZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIG1lID0gSi5SZWFjdEN1cnJlbnREaXNwYXRjaGVyLCBrZTtcbiAgICBmdW5jdGlvbiBjZSh0LCBsLCBkKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChrZSA9PT0gdm9pZCAwKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKG0pIHtcbiAgICAgICAgICAgIHZhciBmID0gbS5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgICAgIGtlID0gZiAmJiBmWzFdIHx8IFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICByZXR1cm4gYFxuYCArIGtlICsgdDtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHllID0gITEsIHNlO1xuICAgIHtcbiAgICAgIHZhciAkdCA9IHR5cGVvZiBXZWFrTWFwID09IFwiZnVuY3Rpb25cIiA/IFdlYWtNYXAgOiBNYXA7XG4gICAgICBzZSA9IG5ldyAkdCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBXZSh0LCBsKSB7XG4gICAgICBpZiAoIXQgfHwgeWUpXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAge1xuICAgICAgICB2YXIgZCA9IHNlLmdldCh0KTtcbiAgICAgICAgaWYgKGQgIT09IHZvaWQgMClcbiAgICAgICAgICByZXR1cm4gZDtcbiAgICAgIH1cbiAgICAgIHZhciBmO1xuICAgICAgeWUgPSAhMDtcbiAgICAgIHZhciBtID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7XG4gICAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHZvaWQgMDtcbiAgICAgIHZhciBDO1xuICAgICAgQyA9IG1lLmN1cnJlbnQsIG1lLmN1cnJlbnQgPSBudWxsLCBVdCgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGwpIHtcbiAgICAgICAgICB2YXIgYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkoYi5wcm90b3R5cGUsIFwicHJvcHNcIiwge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSwgdHlwZW9mIFJlZmxlY3QgPT0gXCJvYmplY3RcIiAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoYiwgW10pO1xuICAgICAgICAgICAgfSBjYXRjaCAoVSkge1xuICAgICAgICAgICAgICBmID0gVTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KHQsIFtdLCBiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYi5jYWxsKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChVKSB7XG4gICAgICAgICAgICAgIGYgPSBVO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdC5jYWxsKGIucHJvdG90eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoVSkge1xuICAgICAgICAgICAgZiA9IFU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHQoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoVSkge1xuICAgICAgICBpZiAoVSAmJiBmICYmIHR5cGVvZiBVLnN0YWNrID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBmb3IgKHZhciB2ID0gVS5zdGFjay5zcGxpdChgXG5gKSwgSSA9IGYuc3RhY2suc3BsaXQoYFxuYCksIE0gPSB2Lmxlbmd0aCAtIDEsIEUgPSBJLmxlbmd0aCAtIDE7IE0gPj0gMSAmJiBFID49IDAgJiYgdltNXSAhPT0gSVtFXTsgKVxuICAgICAgICAgICAgRS0tO1xuICAgICAgICAgIGZvciAoOyBNID49IDEgJiYgRSA+PSAwOyBNLS0sIEUtLSlcbiAgICAgICAgICAgIGlmICh2W01dICE9PSBJW0VdKSB7XG4gICAgICAgICAgICAgIGlmIChNICE9PSAxIHx8IEUgIT09IDEpXG4gICAgICAgICAgICAgICAgZG9cbiAgICAgICAgICAgICAgICAgIGlmIChNLS0sIEUtLSwgRSA8IDAgfHwgdltNXSAhPT0gSVtFXSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgXyA9IGBcbmAgKyB2W01dLnJlcGxhY2UoXCIgYXQgbmV3IFwiLCBcIiBhdCBcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0LmRpc3BsYXlOYW1lICYmIF8uaW5jbHVkZXMoXCI8YW5vbnltb3VzPlwiKSAmJiAoXyA9IF8ucmVwbGFjZShcIjxhbm9ueW1vdXM+XCIsIHQuZGlzcGxheU5hbWUpKSwgdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiICYmIHNlLnNldCh0LCBfKSwgXztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoTSA+PSAxICYmIEUgPj0gMCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB5ZSA9ICExLCBtZS5jdXJyZW50ID0gQywgTnQoKSwgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBtO1xuICAgICAgfVxuICAgICAgdmFyIFogPSB0ID8gdC5kaXNwbGF5TmFtZSB8fCB0Lm5hbWUgOiBcIlwiLCBvdCA9IFogPyBjZShaKSA6IFwiXCI7XG4gICAgICByZXR1cm4gdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiICYmIHNlLnNldCh0LCBvdCksIG90O1xuICAgIH1cbiAgICBmdW5jdGlvbiBXdCh0LCBsLCBkKSB7XG4gICAgICByZXR1cm4gV2UodCwgITEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBZdCh0KSB7XG4gICAgICB2YXIgbCA9IHQucHJvdG90eXBlO1xuICAgICAgcmV0dXJuICEhKGwgJiYgbC5pc1JlYWN0Q29tcG9uZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGUodCwgbCwgZCkge1xuICAgICAgaWYgKHQgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICBpZiAodHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICByZXR1cm4gV2UodCwgWXQodCkpO1xuICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBjZSh0KTtcbiAgICAgIHN3aXRjaCAodCkge1xuICAgICAgICBjYXNlIHk6XG4gICAgICAgICAgcmV0dXJuIGNlKFwiU3VzcGVuc2VcIik7XG4gICAgICAgIGNhc2UgaDpcbiAgICAgICAgICByZXR1cm4gY2UoXCJTdXNwZW5zZUxpc3RcIik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHQgPT0gXCJvYmplY3RcIilcbiAgICAgICAgc3dpdGNoICh0LiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBhOlxuICAgICAgICAgICAgcmV0dXJuIFd0KHQucmVuZGVyKTtcbiAgICAgICAgICBjYXNlIHA6XG4gICAgICAgICAgICByZXR1cm4gZGUodC50eXBlLCBsLCBkKTtcbiAgICAgICAgICBjYXNlIFM6IHtcbiAgICAgICAgICAgIHZhciBmID0gdCwgbSA9IGYuX3BheWxvYWQsIEMgPSBmLl9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRlKEMobSksIGwsIGQpO1xuICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgdmFyIHVlID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgWWUgPSB7fSwgcWUgPSBKLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgZnVuY3Rpb24gZ2UodCkge1xuICAgICAgaWYgKHQpIHtcbiAgICAgICAgdmFyIGwgPSB0Ll9vd25lciwgZCA9IGRlKHQudHlwZSwgdC5fc291cmNlLCBsID8gbC50eXBlIDogbnVsbCk7XG4gICAgICAgIHFlLnNldEV4dHJhU3RhY2tGcmFtZShkKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBxZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHF0KHQsIGwsIGQsIGYsIG0pIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIEMgPSBGdW5jdGlvbi5jYWxsLmJpbmQodWUpO1xuICAgICAgICBmb3IgKHZhciBiIGluIHQpXG4gICAgICAgICAgaWYgKEModCwgYikpIHtcbiAgICAgICAgICAgIHZhciB2ID0gdm9pZCAwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0W2JdICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHZhciBJID0gRXJyb3IoKGYgfHwgXCJSZWFjdCBjbGFzc1wiKSArIFwiOiBcIiArIGQgKyBcIiB0eXBlIGBcIiArIGIgKyBcImAgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYFwiICsgdHlwZW9mIHRbYl0gKyBcImAuVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuXCIpO1xuICAgICAgICAgICAgICAgIHRocm93IEkubmFtZSA9IFwiSW52YXJpYW50IFZpb2xhdGlvblwiLCBJO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHYgPSB0W2JdKGwsIGIsIGYsIGQsIG51bGwsIFwiU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRURcIik7XG4gICAgICAgICAgICB9IGNhdGNoIChNKSB7XG4gICAgICAgICAgICAgIHYgPSBNO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdiAmJiAhKHYgaW5zdGFuY2VvZiBFcnJvcikgJiYgKGdlKG0pLCBIKFwiJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuIFlvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyIGNyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLlwiLCBmIHx8IFwiUmVhY3QgY2xhc3NcIiwgZCwgYiwgdHlwZW9mIHYpLCBnZShudWxsKSksIHYgaW5zdGFuY2VvZiBFcnJvciAmJiAhKHYubWVzc2FnZSBpbiBZZSkgJiYgKFllW3YubWVzc2FnZV0gPSAhMCwgZ2UobSksIEgoXCJGYWlsZWQgJXMgdHlwZTogJXNcIiwgZCwgdi5tZXNzYWdlKSwgZ2UobnVsbCkpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIEt0ID0gQXJyYXkuaXNBcnJheTtcbiAgICBmdW5jdGlvbiBwZSh0KSB7XG4gICAgICByZXR1cm4gS3QodCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEd0KHQpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIGwgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wudG9TdHJpbmdUYWcsIGQgPSBsICYmIHRbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB0LmNvbnN0cnVjdG9yLm5hbWUgfHwgXCJPYmplY3RcIjtcbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIEp0KHQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBLZSh0KSwgITE7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBLZSh0KSB7XG4gICAgICByZXR1cm4gXCJcIiArIHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEdlKHQpIHtcbiAgICAgIGlmIChKdCh0KSlcbiAgICAgICAgcmV0dXJuIEgoXCJUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS5cIiwgR3QodCkpLCBLZSh0KTtcbiAgICB9XG4gICAgdmFyIHRlID0gSi5SZWFjdEN1cnJlbnRPd25lciwgWHQgPSB7XG4gICAgICBrZXk6ICEwLFxuICAgICAgcmVmOiAhMCxcbiAgICAgIF9fc2VsZjogITAsXG4gICAgICBfX3NvdXJjZTogITBcbiAgICB9LCBKZSwgWGUsIENlO1xuICAgIENlID0ge307XG4gICAgZnVuY3Rpb24gWnQodCkge1xuICAgICAgaWYgKHVlLmNhbGwodCwgXCJyZWZcIikpIHtcbiAgICAgICAgdmFyIGwgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIFwicmVmXCIpLmdldDtcbiAgICAgICAgaWYgKGwgJiYgbC5pc1JlYWN0V2FybmluZylcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gdC5yZWYgIT09IHZvaWQgMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gUXQodCkge1xuICAgICAgaWYgKHVlLmNhbGwodCwgXCJrZXlcIikpIHtcbiAgICAgICAgdmFyIGwgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIFwia2V5XCIpLmdldDtcbiAgICAgICAgaWYgKGwgJiYgbC5pc1JlYWN0V2FybmluZylcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gdC5rZXkgIT09IHZvaWQgMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXIodCwgbCkge1xuICAgICAgaWYgKHR5cGVvZiB0LnJlZiA9PSBcInN0cmluZ1wiICYmIHRlLmN1cnJlbnQgJiYgbCAmJiB0ZS5jdXJyZW50LnN0YXRlTm9kZSAhPT0gbCkge1xuICAgICAgICB2YXIgZCA9IFYodGUuY3VycmVudC50eXBlKTtcbiAgICAgICAgQ2VbZF0gfHwgKEgoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiBTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuIExlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBWKHRlLmN1cnJlbnQudHlwZSksIHQucmVmKSwgQ2VbZF0gPSAhMCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyKHQsIGwpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIGQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBKZSB8fCAoSmUgPSAhMCwgSChcIiVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgdmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCBwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpXCIsIGwpKTtcbiAgICAgICAgfTtcbiAgICAgICAgZC5pc1JlYWN0V2FybmluZyA9ICEwLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJrZXlcIiwge1xuICAgICAgICAgIGdldDogZCxcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBycih0LCBsKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgWGUgfHwgKFhlID0gITAsIEgoXCIlczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lIHZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgcHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKVwiLCBsKSk7XG4gICAgICAgIH07XG4gICAgICAgIGQuaXNSZWFjdFdhcm5pbmcgPSAhMCwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwicmVmXCIsIHtcbiAgICAgICAgICBnZXQ6IGQsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIG5yID0gZnVuY3Rpb24odCwgbCwgZCwgZiwgbSwgQywgYikge1xuICAgICAgdmFyIHYgPSB7XG4gICAgICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICAgICAkJHR5cGVvZjogbixcbiAgICAgICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgICAgICB0eXBlOiB0LFxuICAgICAgICBrZXk6IGwsXG4gICAgICAgIHJlZjogZCxcbiAgICAgICAgcHJvcHM6IGIsXG4gICAgICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgICAgIF9vd25lcjogQ1xuICAgICAgfTtcbiAgICAgIHJldHVybiB2Ll9zdG9yZSA9IHt9LCBPYmplY3QuZGVmaW5lUHJvcGVydHkodi5fc3RvcmUsIFwidmFsaWRhdGVkXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6ICExXG4gICAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHYsIFwiX3NlbGZcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICExLFxuICAgICAgICB2YWx1ZTogZlxuICAgICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2LCBcIl9zb3VyY2VcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICExLFxuICAgICAgICB2YWx1ZTogbVxuICAgICAgfSksIE9iamVjdC5mcmVlemUgJiYgKE9iamVjdC5mcmVlemUodi5wcm9wcyksIE9iamVjdC5mcmVlemUodikpLCB2O1xuICAgIH07XG4gICAgZnVuY3Rpb24gb3IodCwgbCwgZCwgZiwgbSkge1xuICAgICAge1xuICAgICAgICB2YXIgQywgYiA9IHt9LCB2ID0gbnVsbCwgSSA9IG51bGw7XG4gICAgICAgIGQgIT09IHZvaWQgMCAmJiAoR2UoZCksIHYgPSBcIlwiICsgZCksIFF0KGwpICYmIChHZShsLmtleSksIHYgPSBcIlwiICsgbC5rZXkpLCBadChsKSAmJiAoSSA9IGwucmVmLCBlcihsLCBtKSk7XG4gICAgICAgIGZvciAoQyBpbiBsKVxuICAgICAgICAgIHVlLmNhbGwobCwgQykgJiYgIVh0Lmhhc093blByb3BlcnR5KEMpICYmIChiW0NdID0gbFtDXSk7XG4gICAgICAgIGlmICh0ICYmIHQuZGVmYXVsdFByb3BzKSB7XG4gICAgICAgICAgdmFyIE0gPSB0LmRlZmF1bHRQcm9wcztcbiAgICAgICAgICBmb3IgKEMgaW4gTSlcbiAgICAgICAgICAgIGJbQ10gPT09IHZvaWQgMCAmJiAoYltDXSA9IE1bQ10pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2IHx8IEkpIHtcbiAgICAgICAgICB2YXIgRSA9IHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIiA/IHQuZGlzcGxheU5hbWUgfHwgdC5uYW1lIHx8IFwiVW5rbm93blwiIDogdDtcbiAgICAgICAgICB2ICYmIHRyKGIsIEUpLCBJICYmIHJyKGIsIEUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBucih0LCB2LCBJLCBtLCBmLCB0ZS5jdXJyZW50LCBiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGplID0gSi5SZWFjdEN1cnJlbnRPd25lciwgWmUgPSBKLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgZnVuY3Rpb24gWCh0KSB7XG4gICAgICBpZiAodCkge1xuICAgICAgICB2YXIgbCA9IHQuX293bmVyLCBkID0gZGUodC50eXBlLCB0Ll9zb3VyY2UsIGwgPyBsLnR5cGUgOiBudWxsKTtcbiAgICAgICAgWmUuc2V0RXh0cmFTdGFja0ZyYW1lKGQpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIFplLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gICAgdmFyIFRlO1xuICAgIFRlID0gITE7XG4gICAgZnVuY3Rpb24gd2UodCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdCAhPT0gbnVsbCAmJiB0LiQkdHlwZW9mID09PSBuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBRZSgpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKGplLmN1cnJlbnQpIHtcbiAgICAgICAgICB2YXIgdCA9IFYoamUuY3VycmVudC50eXBlKTtcbiAgICAgICAgICBpZiAodClcbiAgICAgICAgICAgIHJldHVybiBgXG5cbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIFxcYGAgKyB0ICsgXCJgLlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpcih0KSB7XG4gICAgICB7XG4gICAgICAgIGlmICh0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICB2YXIgbCA9IHQuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgXCJcIiksIGQgPSB0LmxpbmVOdW1iZXI7XG4gICAgICAgICAgcmV0dXJuIGBcblxuQ2hlY2sgeW91ciBjb2RlIGF0IGAgKyBsICsgXCI6XCIgKyBkICsgXCIuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBldCA9IHt9O1xuICAgIGZ1bmN0aW9uIGFyKHQpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIGwgPSBRZSgpO1xuICAgICAgICBpZiAoIWwpIHtcbiAgICAgICAgICB2YXIgZCA9IHR5cGVvZiB0ID09IFwic3RyaW5nXCIgPyB0IDogdC5kaXNwbGF5TmFtZSB8fCB0Lm5hbWU7XG4gICAgICAgICAgZCAmJiAobCA9IGBcblxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8YCArIGQgKyBcIj4uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0dCh0LCBsKSB7XG4gICAgICB7XG4gICAgICAgIGlmICghdC5fc3RvcmUgfHwgdC5fc3RvcmUudmFsaWRhdGVkIHx8IHQua2V5ICE9IG51bGwpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0Ll9zdG9yZS52YWxpZGF0ZWQgPSAhMDtcbiAgICAgICAgdmFyIGQgPSBhcihsKTtcbiAgICAgICAgaWYgKGV0W2RdKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZXRbZF0gPSAhMDtcbiAgICAgICAgdmFyIGYgPSBcIlwiO1xuICAgICAgICB0ICYmIHQuX293bmVyICYmIHQuX293bmVyICE9PSBqZS5jdXJyZW50ICYmIChmID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBWKHQuX293bmVyLnR5cGUpICsgXCIuXCIpLCBYKHQpLCBIKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBkLCBmKSwgWChudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcnQodCwgbCkge1xuICAgICAge1xuICAgICAgICBpZiAodHlwZW9mIHQgIT0gXCJvYmplY3RcIilcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChwZSh0KSlcbiAgICAgICAgICBmb3IgKHZhciBkID0gMDsgZCA8IHQubGVuZ3RoOyBkKyspIHtcbiAgICAgICAgICAgIHZhciBmID0gdFtkXTtcbiAgICAgICAgICAgIHdlKGYpICYmIHR0KGYsIGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAod2UodCkpXG4gICAgICAgICAgdC5fc3RvcmUgJiYgKHQuX3N0b3JlLnZhbGlkYXRlZCA9ICEwKTtcbiAgICAgICAgZWxzZSBpZiAodCkge1xuICAgICAgICAgIHZhciBtID0gQnQodCk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBtID09IFwiZnVuY3Rpb25cIiAmJiBtICE9PSB0LmVudHJpZXMpXG4gICAgICAgICAgICBmb3IgKHZhciBDID0gbS5jYWxsKHQpLCBiOyAhKGIgPSBDLm5leHQoKSkuZG9uZTsgKVxuICAgICAgICAgICAgICB3ZShiLnZhbHVlKSAmJiB0dChiLnZhbHVlLCBsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBscih0KSB7XG4gICAgICB7XG4gICAgICAgIHZhciBsID0gdC50eXBlO1xuICAgICAgICBpZiAobCA9PSBudWxsIHx8IHR5cGVvZiBsID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgZDtcbiAgICAgICAgaWYgKHR5cGVvZiBsID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICBkID0gbC5wcm9wVHlwZXM7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBsID09IFwib2JqZWN0XCIgJiYgKGwuJCR0eXBlb2YgPT09IGEgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgICAgICAvLyBJbm5lciBwcm9wcyBhcmUgY2hlY2tlZCBpbiB0aGUgcmVjb25jaWxlci5cbiAgICAgICAgbC4kJHR5cGVvZiA9PT0gcCkpXG4gICAgICAgICAgZCA9IGwucHJvcFR5cGVzO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoZCkge1xuICAgICAgICAgIHZhciBmID0gVihsKTtcbiAgICAgICAgICBxdChkLCB0LnByb3BzLCBcInByb3BcIiwgZiwgdCk7XG4gICAgICAgIH0gZWxzZSBpZiAobC5Qcm9wVHlwZXMgIT09IHZvaWQgMCAmJiAhVGUpIHtcbiAgICAgICAgICBUZSA9ICEwO1xuICAgICAgICAgIHZhciBtID0gVihsKTtcbiAgICAgICAgICBIKFwiQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/XCIsIG0gfHwgXCJVbmtub3duXCIpO1xuICAgICAgICB9XG4gICAgICAgIHR5cGVvZiBsLmdldERlZmF1bHRQcm9wcyA9PSBcImZ1bmN0aW9uXCIgJiYgIWwuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkICYmIEgoXCJnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY3IodCkge1xuICAgICAge1xuICAgICAgICBmb3IgKHZhciBsID0gT2JqZWN0LmtleXModC5wcm9wcyksIGQgPSAwOyBkIDwgbC5sZW5ndGg7IGQrKykge1xuICAgICAgICAgIHZhciBmID0gbFtkXTtcbiAgICAgICAgICBpZiAoZiAhPT0gXCJjaGlsZHJlblwiICYmIGYgIT09IFwia2V5XCIpIHtcbiAgICAgICAgICAgIFgodCksIEgoXCJJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiBSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLlwiLCBmKSwgWChudWxsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0LnJlZiAhPT0gbnVsbCAmJiAoWCh0KSwgSChcIkludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuXCIpLCBYKG51bGwpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbnQodCwgbCwgZCwgZiwgbSwgQykge1xuICAgICAge1xuICAgICAgICB2YXIgYiA9IEx0KHQpO1xuICAgICAgICBpZiAoIWIpIHtcbiAgICAgICAgICB2YXIgdiA9IFwiXCI7XG4gICAgICAgICAgKHQgPT09IHZvaWQgMCB8fCB0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQgIT09IG51bGwgJiYgT2JqZWN0LmtleXModCkubGVuZ3RoID09PSAwKSAmJiAodiArPSBcIiBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSBpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCIpO1xuICAgICAgICAgIHZhciBJID0gaXIobSk7XG4gICAgICAgICAgSSA/IHYgKz0gSSA6IHYgKz0gUWUoKTtcbiAgICAgICAgICB2YXIgTTtcbiAgICAgICAgICB0ID09PSBudWxsID8gTSA9IFwibnVsbFwiIDogcGUodCkgPyBNID0gXCJhcnJheVwiIDogdCAhPT0gdm9pZCAwICYmIHQuJCR0eXBlb2YgPT09IG4gPyAoTSA9IFwiPFwiICsgKFYodC50eXBlKSB8fCBcIlVua25vd25cIikgKyBcIiAvPlwiLCB2ID0gXCIgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD9cIikgOiBNID0gdHlwZW9mIHQsIEgoXCJSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXNcIiwgTSwgdik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIEUgPSBvcih0LCBsLCBkLCBtLCBDKTtcbiAgICAgICAgaWYgKEUgPT0gbnVsbClcbiAgICAgICAgICByZXR1cm4gRTtcbiAgICAgICAgaWYgKGIpIHtcbiAgICAgICAgICB2YXIgXyA9IGwuY2hpbGRyZW47XG4gICAgICAgICAgaWYgKF8gIT09IHZvaWQgMClcbiAgICAgICAgICAgIGlmIChmKVxuICAgICAgICAgICAgICBpZiAocGUoXykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBaID0gMDsgWiA8IF8ubGVuZ3RoOyBaKyspXG4gICAgICAgICAgICAgICAgICBydChfW1pdLCB0KTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZnJlZXplICYmIE9iamVjdC5mcmVlemUoXyk7XG4gICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIEgoXCJSZWFjdC5qc3g6IFN0YXRpYyBjaGlsZHJlbiBzaG91bGQgYWx3YXlzIGJlIGFuIGFycmF5LiBZb3UgYXJlIGxpa2VseSBleHBsaWNpdGx5IGNhbGxpbmcgUmVhY3QuanN4cyBvciBSZWFjdC5qc3hERVYuIFVzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBydChfLCB0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdCA9PT0gaSA/IGNyKEUpIDogbHIoRSksIEU7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNyKHQsIGwsIGQpIHtcbiAgICAgIHJldHVybiBudCh0LCBsLCBkLCAhMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRyKHQsIGwsIGQpIHtcbiAgICAgIHJldHVybiBudCh0LCBsLCBkLCAhMSk7XG4gICAgfVxuICAgIHZhciB1ciA9IGRyLCBnciA9IHNyO1xuICAgIG5lLkZyYWdtZW50ID0gaSwgbmUuanN4ID0gdXIsIG5lLmpzeHMgPSBncjtcbiAgfSgpKSwgbmU7XG59XG5wcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBNZS5leHBvcnRzID0gSHIoKSA6IE1lLmV4cG9ydHMgPSBJcigpO1xudmFyIHIgPSBNZS5leHBvcnRzO1xuY29uc3QgZmUgPSAoZSkgPT4ge1xuICBjb25zdCBuID0gYDAgNHB4IDEycHggJHtlLmNvbG9ycy5zaGFkb3d9YCwgbyA9IGAxcHggc29saWQgJHtlLmNvbG9ycy5ib3JkZXJ9YCwgaSA9IHtcbiAgICBkZWZhdWx0OiBlLmNvbG9ycy5lZGl0b3IudGV4dCxcbiAgICBncmF5OiBlLmNvbG9ycy5oaWdobGlnaHRDb2xvcnMuZ3JheS50ZXh0LFxuICAgIGJyb3duOiBlLmNvbG9ycy5oaWdobGlnaHRDb2xvcnMuYnJvd24udGV4dCxcbiAgICByZWQ6IGUuY29sb3JzLmhpZ2hsaWdodENvbG9ycy5yZWQudGV4dCxcbiAgICBvcmFuZ2U6IGUuY29sb3JzLmhpZ2hsaWdodENvbG9ycy5vcmFuZ2UudGV4dCxcbiAgICB5ZWxsb3c6IGUuY29sb3JzLmhpZ2hsaWdodENvbG9ycy55ZWxsb3cudGV4dCxcbiAgICBncmVlbjogZS5jb2xvcnMuaGlnaGxpZ2h0Q29sb3JzLmdyZWVuLnRleHQsXG4gICAgYmx1ZTogZS5jb2xvcnMuaGlnaGxpZ2h0Q29sb3JzLmJsdWUudGV4dCxcbiAgICBwdXJwbGU6IGUuY29sb3JzLmhpZ2hsaWdodENvbG9ycy5wdXJwbGUudGV4dCxcbiAgICBwaW5rOiBlLmNvbG9ycy5oaWdobGlnaHRDb2xvcnMucGluay50ZXh0XG4gIH0sIHMgPSB7XG4gICAgZGVmYXVsdDogZS5jb2xvcnMuZWRpdG9yLmJhY2tncm91bmQsXG4gICAgZ3JheTogZS5jb2xvcnMuaGlnaGxpZ2h0Q29sb3JzLmdyYXkuYmFja2dyb3VuZCxcbiAgICBicm93bjogZS5jb2xvcnMuaGlnaGxpZ2h0Q29sb3JzLmJyb3duLmJhY2tncm91bmQsXG4gICAgcmVkOiBlLmNvbG9ycy5oaWdobGlnaHRDb2xvcnMucmVkLmJhY2tncm91bmQsXG4gICAgb3JhbmdlOiBlLmNvbG9ycy5oaWdobGlnaHRDb2xvcnMub3JhbmdlLmJhY2tncm91bmQsXG4gICAgeWVsbG93OiBlLmNvbG9ycy5oaWdobGlnaHRDb2xvcnMueWVsbG93LmJhY2tncm91bmQsXG4gICAgZ3JlZW46IGUuY29sb3JzLmhpZ2hsaWdodENvbG9ycy5ncmVlbi5iYWNrZ3JvdW5kLFxuICAgIGJsdWU6IGUuY29sb3JzLmhpZ2hsaWdodENvbG9ycy5ibHVlLmJhY2tncm91bmQsXG4gICAgcHVycGxlOiBlLmNvbG9ycy5oaWdobGlnaHRDb2xvcnMucHVycGxlLmJhY2tncm91bmQsXG4gICAgcGluazogZS5jb2xvcnMuaGlnaGxpZ2h0Q29sb3JzLnBpbmsuYmFja2dyb3VuZFxuICB9LCBjID0gYCR7TWF0aC5tYXgoZS5ib3JkZXJSYWRpdXMgKyAyLCAxKX1weGAsIHUgPSBgJHtlLmJvcmRlclJhZGl1c31weGAsIGcgPSBgJHtNYXRoLm1heChlLmJvcmRlclJhZGl1cyAtIDIsIDEpfXB4YDtcbiAgcmV0dXJuIHtcbiAgICBhY3RpdmVTdHlsZXM6IHtcbiAgICAgIC8vIFJlbW92ZXMgYnV0dG9uIHByZXNzIGVmZmVjdC5cbiAgICAgIHRyYW5zZm9ybTogXCJub25lXCJcbiAgICB9LFxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgIC8vIFNsYXNoIE1lbnUsIEZvcm1hdHRpbmcgVG9vbGJhciBkcm9wZG93biwgY29sb3IgcGlja2VyIGRyb3Bkb3duXG4gICAgICBNZW51OiB7XG4gICAgICAgIHN0eWxlczogKCkgPT4ge1xuICAgICAgICAgIHZhciBhO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkcm9wZG93bjogTy5tZXJnZShcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogZS5jb2xvcnMubWVudS5iYWNrZ3JvdW5kLFxuICAgICAgICAgICAgICAgIGJvcmRlcjogbyxcbiAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IHUsXG4gICAgICAgICAgICAgICAgYm94U2hhZG93OiBuLFxuICAgICAgICAgICAgICAgIGNvbG9yOiBlLmNvbG9ycy5tZW51LnRleHQsXG4gICAgICAgICAgICAgICAgcGFkZGluZzogXCIycHhcIixcbiAgICAgICAgICAgICAgICBvdmVyZmxvd1k6IFwic2Nyb2xsXCIsXG4gICAgICAgICAgICAgICAgXCIubWFudGluZS1NZW51LWxhYmVsXCI6IHtcbiAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogZS5jb2xvcnMubWVudS5iYWNrZ3JvdW5kLFxuICAgICAgICAgICAgICAgICAgY29sb3I6IGUuY29sb3JzLm1lbnUudGV4dFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCIubWFudGluZS1NZW51LWl0ZW1cIjoge1xuICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBlLmNvbG9ycy5tZW51LmJhY2tncm91bmQsXG4gICAgICAgICAgICAgICAgICBib3JkZXI6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiBnLFxuICAgICAgICAgICAgICAgICAgY29sb3I6IGUuY29sb3JzLm1lbnUudGV4dFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCIubWFudGluZS1NZW51LWl0ZW1bZGF0YS1ob3ZlcmVkXVwiOiB7XG4gICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGUuY29sb3JzLmhvdmVyZWQuYmFja2dyb3VuZCxcbiAgICAgICAgICAgICAgICAgIGJvcmRlcjogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgICBjb2xvcjogZS5jb2xvcnMuaG92ZXJlZC50ZXh0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAoKGEgPSBlLmNvbXBvbmVudFN0eWxlcykgPT0gbnVsbCA/IHZvaWQgMCA6IGEuY2FsbChlLCBlKS5NZW51KSB8fCB7fVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBUYWJzOiB7XG4gICAgICAgIHN0eWxlczogKCkgPT4ge1xuICAgICAgICAgIHZhciBhO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByb290OiBPLm1lcmdlKFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IFwiMTAwJVwiLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogZS5jb2xvcnMubWVudS5iYWNrZ3JvdW5kXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICgoYSA9IGUuY29tcG9uZW50U3R5bGVzKSA9PSBudWxsID8gdm9pZCAwIDogYS5jYWxsKGUsIGUpLlRhYnMpIHx8IHt9XG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgdGFic0xpc3Q6IHtcbiAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGUuY29sb3JzLmhvdmVyZWQuYmFja2dyb3VuZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRhYjoge1xuICAgICAgICAgICAgICBjb2xvcjogZS5jb2xvcnMubWVudS50ZXh0LFxuICAgICAgICAgICAgICBib3JkZXJDb2xvcjogZS5jb2xvcnMuaG92ZXJlZC5iYWNrZ3JvdW5kLFxuICAgICAgICAgICAgICBcIiY6aG92ZXJcIjoge1xuICAgICAgICAgICAgICAgIGNvbG9yOiBlLmNvbG9ycy5ob3ZlcmVkLnRleHQsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBlLmNvbG9ycy5ob3ZlcmVkLmJhY2tncm91bmQsXG4gICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGUuY29sb3JzLmhvdmVyZWQuYmFja2dyb3VuZFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcIiZbZGF0YS1hY3RpdmVdLCAmW2RhdGEtYWN0aXZlXSY6aG92ZXJcIjoge1xuICAgICAgICAgICAgICAgIGNvbG9yOiBlLmNvbG9ycy5tZW51LnRleHQsXG4gICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGUuY29sb3JzLm1lbnUudGV4dFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFuZWw6IHtcbiAgICAgICAgICAgICAgcGFkZGluZzogXCI4cHhcIixcbiAgICAgICAgICAgICAgXCIubWFudGluZS1VbnN0eWxlZEJ1dHRvbi1yb290XCI6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogXCI2MCVcIixcbiAgICAgICAgICAgICAgICBib3JkZXI6IGBzb2xpZCAke2UuY29sb3JzLmJvcmRlcn0gMXB4YCxcbiAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IFwiNHB4XCIsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBcIjMycHhcIlxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcIi5tYW50aW5lLVVuc3R5bGVkQnV0dG9uLXJvb3Q6aG92ZXJcIjoge1xuICAgICAgICAgICAgICAgIGNvbG9yOiBlLmNvbG9ycy5ob3ZlcmVkLnRleHQsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBlLmNvbG9ycy5ob3ZlcmVkLmJhY2tncm91bmRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBGaWxlSW5wdXQ6IHtcbiAgICAgICAgc3R5bGVzOiAoKSA9PiB7XG4gICAgICAgICAgdmFyIGE7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJvb3Q6ICgoYSA9IGUuY29tcG9uZW50U3R5bGVzKSA9PSBudWxsID8gdm9pZCAwIDogYS5jYWxsKGUsIGUpLkZpbGVJbnB1dCkgfHwge30sXG4gICAgICAgICAgICBpbnB1dDoge1xuICAgICAgICAgICAgICBjb2xvcjogZS5jb2xvcnMubWVudS50ZXh0LFxuICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGUuY29sb3JzLm1lbnUuYmFja2dyb3VuZCxcbiAgICAgICAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICAgICAgICAgIGZsZXhEaXJlY3Rpb246IFwicm93XCIsXG4gICAgICAgICAgICAgIGFsaWduSXRlbXM6IFwiY2VudGVyXCIsXG4gICAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiBcImNlbnRlclwiLFxuICAgICAgICAgICAgICBib3JkZXI6IFwibm9uZVwiLFxuICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IFwiNHB4XCIsXG4gICAgICAgICAgICAgIFwiJjpob3ZlclwiOiB7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBlLmNvbG9ycy5ob3ZlcmVkLmJhY2tncm91bmRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHdyYXBwZXI6IHtcbiAgICAgICAgICAgICAgYm9yZGVyOiBgc29saWQgJHtlLmNvbG9ycy5ib3JkZXJ9IDFweGAsXG4gICAgICAgICAgICAgIGJvcmRlclJhZGl1czogXCI0cHhcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyOiB7XG4gICAgICAgICAgICAgIGNvbG9yOiBgJHtlLmNvbG9ycy5tZW51LnRleHR9ICFpbXBvcnRhbnRgLFxuICAgICAgICAgICAgICBmb250V2VpZ2h0OiA2MDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgVGV4dElucHV0OiB7XG4gICAgICAgIHN0eWxlczogKCkgPT4ge1xuICAgICAgICAgIHZhciBhO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByb290OiAoKGEgPSBlLmNvbXBvbmVudFN0eWxlcykgPT0gbnVsbCA/IHZvaWQgMCA6IGEuY2FsbChlLCBlKS5UZXh0SW5wdXQpIHx8IHt9LFxuICAgICAgICAgICAgaW5wdXQ6IHtcbiAgICAgICAgICAgICAgY29sb3I6IGUuY29sb3JzLm1lbnUudGV4dCxcbiAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBlLmNvbG9ycy5tZW51LmJhY2tncm91bmQsXG4gICAgICAgICAgICAgIGJvcmRlcjogYHNvbGlkICR7ZS5jb2xvcnMuYm9yZGVyfSAxcHhgLFxuICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IFwiNHB4XCIsXG4gICAgICAgICAgICAgIGhlaWdodDogXCIzMnB4XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgQ29sb3JJY29uOiB7XG4gICAgICAgIHN0eWxlczogKCkgPT4ge1xuICAgICAgICAgIHZhciBhO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByb290OiBPLm1lcmdlKFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYm9yZGVyOiBvLFxuICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogZ1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAoKGEgPSBlLmNvbXBvbmVudFN0eWxlcykgPT0gbnVsbCA/IHZvaWQgMCA6IGEuY2FsbChlLCBlKS5Db2xvckljb24pIHx8IHt9XG4gICAgICAgICAgICApXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIERyYWdIYW5kbGVNZW51OiB7XG4gICAgICAgIHN0eWxlczogKCkgPT4ge1xuICAgICAgICAgIHZhciBhO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByb290OiBPLm1lcmdlKFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCIubWFudGluZS1NZW51LWl0ZW1cIjoge1xuICAgICAgICAgICAgICAgICAgZm9udFNpemU6IFwiMTJweFwiLFxuICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBcIjMwcHhcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgKChhID0gZS5jb21wb25lbnRTdHlsZXMpID09IG51bGwgPyB2b2lkIDAgOiBhLmNhbGwoZSwgZSkuRHJhZ0hhbmRsZU1lbnUpIHx8IHt9XG4gICAgICAgICAgICApXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIEVkaXRvcjoge1xuICAgICAgICBzdHlsZXM6ICgpID0+IHtcbiAgICAgICAgICB2YXIgYTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcm9vdDogTy5tZXJnZShcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiLlByb3NlTWlycm9yXCI6IHtcbiAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogZS5jb2xvcnMuZWRpdG9yLmJhY2tncm91bmQsXG4gICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IGMsXG4gICAgICAgICAgICAgICAgICBjb2xvcjogZS5jb2xvcnMuZWRpdG9yLnRleHQsXG4gICAgICAgICAgICAgICAgICBmb250RmFtaWx5OiBlLmZvbnRGYW1pbHlcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIFBsYWNlaG9sZGVyc1xuICAgICAgICAgICAgICAgIFtgLiR7Ri5pc0VtcHR5fSAuJHtGLmlubGluZUNvbnRlbnR9OmJlZm9yZSwgLiR7Ri5pc0ZpbHRlcn0gLiR7Ri5pbmxpbmVDb250ZW50fTpiZWZvcmVgXToge1xuICAgICAgICAgICAgICAgICAgY29sb3I6IGUuY29sb3JzLnNpZGVNZW51XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBJbmRlbnQgbGluZXNcbiAgICAgICAgICAgICAgICBbYC4ke0YuYmxvY2tHcm91cH1gXToge1xuICAgICAgICAgICAgICAgICAgW2AuJHtGLmJsb2NrR3JvdXB9YF06IHtcbiAgICAgICAgICAgICAgICAgICAgW2AuJHtGLmJsb2NrT3V0ZXJ9Om5vdChbZGF0YS1wcmV2LWRlcHRoLWNoYW5nZWRdKTo6YmVmb3JlYF06IHtcbiAgICAgICAgICAgICAgICAgICAgICBib3JkZXJMZWZ0OiBgMXB4IHNvbGlkICR7ZS5jb2xvcnMuc2lkZU1lbnV9YFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBIaWdobGlnaHQgdGV4dCBjb2xvcnNcbiAgICAgICAgICAgICAgICAuLi5PYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgICAgICAgICBPYmplY3QuZW50cmllcyhpKS5tYXAoKFt5LCBoXSkgPT4gW1xuICAgICAgICAgICAgICAgICAgICBgW2RhdGEtdGV4dC1jb2xvcj1cIiR7eX1cIl1gLFxuICAgICAgICAgICAgICAgICAgICB7IGNvbG9yOiBoIH1cbiAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAvLyBIaWdobGlnaHQgYmFja2dyb3VuZCBjb2xvcnNcbiAgICAgICAgICAgICAgICAuLi5PYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgICAgICAgICBPYmplY3QuZW50cmllcyhzKS5tYXAoKFt5LCBoXSkgPT4gW1xuICAgICAgICAgICAgICAgICAgICBgW2RhdGEtYmFja2dyb3VuZC1jb2xvcj1cIiR7eX1cIl1gLFxuICAgICAgICAgICAgICAgICAgICB7IGJhY2tncm91bmRDb2xvcjogaCB9XG4gICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgKChhID0gZS5jb21wb25lbnRTdHlsZXMpID09IG51bGwgPyB2b2lkIDAgOiBhLmNhbGwoZSwgZSkuRWRpdG9yKSB8fCB7fVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBUb29sYmFyOiB7XG4gICAgICAgIHN0eWxlczogKCkgPT4ge1xuICAgICAgICAgIHZhciBhO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByb290OiBPLm1lcmdlKFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBlLmNvbG9ycy5tZW51LmJhY2tncm91bmQsXG4gICAgICAgICAgICAgICAgYm94U2hhZG93OiBuLFxuICAgICAgICAgICAgICAgIGJvcmRlcjogbyxcbiAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IHUsXG4gICAgICAgICAgICAgICAgZmxleFdyYXA6IFwibm93cmFwXCIsXG4gICAgICAgICAgICAgICAgZ2FwOiBcIjJweFwiLFxuICAgICAgICAgICAgICAgIHBhZGRpbmc6IFwiMnB4XCIsXG4gICAgICAgICAgICAgICAgd2lkdGg6IFwiZml0LWNvbnRlbnRcIixcbiAgICAgICAgICAgICAgICAvLyBCdXR0b24gKGluY2x1ZGluZyBkcm9wZG93biB0YXJnZXQpXG4gICAgICAgICAgICAgICAgXCIubWFudGluZS1CdXR0b24tcm9vdCwgLm1hbnRpbmUtQWN0aW9uSWNvbi1yb290XCI6IHtcbiAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogZS5jb2xvcnMubWVudS5iYWNrZ3JvdW5kLFxuICAgICAgICAgICAgICAgICAgYm9yZGVyOiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogZyxcbiAgICAgICAgICAgICAgICAgIGNvbG9yOiBlLmNvbG9ycy5tZW51LnRleHRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIEhvdmVyZWQgYnV0dG9uXG4gICAgICAgICAgICAgICAgXCIubWFudGluZS1CdXR0b24tcm9vdDpob3ZlciwgLm1hbnRpbmUtQWN0aW9uSWNvbi1yb290OmhvdmVyXCI6IHtcbiAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogZS5jb2xvcnMuaG92ZXJlZC5iYWNrZ3JvdW5kLFxuICAgICAgICAgICAgICAgICAgYm9yZGVyOiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICAgIGNvbG9yOiBlLmNvbG9ycy5ob3ZlcmVkLnRleHRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIFNlbGVjdGVkIGJ1dHRvblxuICAgICAgICAgICAgICAgIFwiLm1hbnRpbmUtQnV0dG9uLXJvb3RbZGF0YS1zZWxlY3RlZF0sIC5tYW50aW5lLUFjdGlvbkljb24tcm9vdFtkYXRhLXNlbGVjdGVkXVwiOiB7XG4gICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGUuY29sb3JzLnNlbGVjdGVkLmJhY2tncm91bmQsXG4gICAgICAgICAgICAgICAgICBib3JkZXI6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgICAgY29sb3I6IGUuY29sb3JzLnNlbGVjdGVkLnRleHRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIERpc2FibGVkIGJ1dHRvblxuICAgICAgICAgICAgICAgIFwiLm1hbnRpbmUtQnV0dG9uLXJvb3RbZGF0YS1kaXNhYmxlZF0sIC5tYW50aW5lLUFjdGlvbkljb24tcm9vdFtkYXRhLWRpc2FibGVkXVwiOiB7XG4gICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGUuY29sb3JzLmRpc2FibGVkLmJhY2tncm91bmQsXG4gICAgICAgICAgICAgICAgICBib3JkZXI6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgICAgY29sb3I6IGUuY29sb3JzLmRpc2FibGVkLnRleHRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIERyb3Bkb3duXG4gICAgICAgICAgICAgICAgXCIubWFudGluZS1NZW51LWRyb3Bkb3duXCI6IHtcbiAgICAgICAgICAgICAgICAgIC8vIERyb3Bkb3duIGl0ZW1cbiAgICAgICAgICAgICAgICAgIFwiLm1hbnRpbmUtTWVudS1pdGVtXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6IFwiMTJweFwiLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiMzBweFwiLFxuICAgICAgICAgICAgICAgICAgICBcIi5tYW50aW5lLU1lbnUtaXRlbVJpZ2h0U2VjdGlvblwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgcGFkZGluZ0xlZnQ6IFwiNXB4XCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIFwiLm1hbnRpbmUtTWVudS1pdGVtOmhvdmVyXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBlLmNvbG9ycy5ob3ZlcmVkLmJhY2tncm91bmRcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICgoYSA9IGUuY29tcG9uZW50U3R5bGVzKSA9PSBudWxsID8gdm9pZCAwIDogYS5jYWxsKGUsIGUpLlRvb2xiYXIpIHx8IHt9XG4gICAgICAgICAgICApXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFRvb2xiYXJJbnB1dERyb3Bkb3duOiB7XG4gICAgICAgIHN0eWxlczogKCkgPT4ge1xuICAgICAgICAgIHZhciBhO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByb290OiBPLm1lcmdlKFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBlLmNvbG9ycy5tZW51LmJhY2tncm91bmQsXG4gICAgICAgICAgICAgICAgYm9yZGVyOiBvLFxuICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogdSxcbiAgICAgICAgICAgICAgICBib3hTaGFkb3c6IG4sXG4gICAgICAgICAgICAgICAgY29sb3I6IGUuY29sb3JzLm1lbnUudGV4dCxcbiAgICAgICAgICAgICAgICBnYXA6IFwiNHB4XCIsXG4gICAgICAgICAgICAgICAgbWluV2lkdGg6IFwiMTQ1cHhcIixcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiBcIjJweFwiLFxuICAgICAgICAgICAgICAgIC8vIFJvd1xuICAgICAgICAgICAgICAgIFwiLm1hbnRpbmUtR3JvdXAtcm9vdFwiOiB7XG4gICAgICAgICAgICAgICAgICBmbGV4V3JhcDogXCJub3dyYXBcIixcbiAgICAgICAgICAgICAgICAgIC8vIFJvdyBpbnB1dCBmaWVsZFxuICAgICAgICAgICAgICAgICAgXCIubWFudGluZS1UZXh0SW5wdXQtcm9vdCwgLm1hbnRpbmUtRmlsZUlucHV0LXJvb3RcIjoge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogXCIzMDBweFwiLFxuICAgICAgICAgICAgICAgICAgICBcIi5tYW50aW5lLVRleHRJbnB1dC13cmFwcGVyOmhvdmVyXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGUuY29sb3JzLmhvdmVyZWQuYmFja2dyb3VuZFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBcIi5tYW50aW5lLVRleHRJbnB1dC13cmFwcGVyLCAubWFudGluZS1GaWxlSW5wdXQtd3JhcHBlclwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IFwiNHB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCIubWFudGluZS1GaWxlSW5wdXQtaWNvblwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogZS5jb2xvcnMubWVudS50ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBcIi5tYW50aW5lLVRleHRJbnB1dC1pbnB1dCwgLm1hbnRpbmUtRmlsZUlucHV0LWlucHV0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlcjogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogXCIxMnB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIi5tYW50aW5lLUZpbGVJbnB1dC1wbGFjZWhvbGRlclwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBlLmNvbG9ycy5tZW51LnRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIFwiLm1hbnRpbmUtRmlsZUlucHV0LWlucHV0OmhvdmVyXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogZS5jb2xvcnMuaG92ZXJlZC5iYWNrZ3JvdW5kXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAoKGEgPSBlLmNvbXBvbmVudFN0eWxlcykgPT0gbnVsbCA/IHZvaWQgMCA6IGEuY2FsbChlLCBlKS5FZGl0SHlwZXJsaW5rTWVudSkgfHwge31cbiAgICAgICAgICAgIClcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgVG9vbHRpcDoge1xuICAgICAgICBzdHlsZXM6ICgpID0+IHtcbiAgICAgICAgICB2YXIgYTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcm9vdDogTy5tZXJnZShcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogZS5jb2xvcnMudG9vbHRpcC5iYWNrZ3JvdW5kLFxuICAgICAgICAgICAgICAgIGJvcmRlcjogbyxcbiAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IHUsXG4gICAgICAgICAgICAgICAgYm94U2hhZG93OiBuLFxuICAgICAgICAgICAgICAgIGNvbG9yOiBlLmNvbG9ycy50b29sdGlwLnRleHQsXG4gICAgICAgICAgICAgICAgcGFkZGluZzogXCI0cHggMTBweFwiLFxuICAgICAgICAgICAgICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIixcbiAgICAgICAgICAgICAgICBcImRpdiB+IGRpdlwiOiB7XG4gICAgICAgICAgICAgICAgICBjb2xvcjogZS5jb2xvcnMudG9vbHRpcC50ZXh0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAoKGEgPSBlLmNvbXBvbmVudFN0eWxlcykgPT0gbnVsbCA/IHZvaWQgMCA6IGEuY2FsbChlLCBlKS5Ub29sdGlwKSB8fCB7fVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBTbGFzaE1lbnU6IHtcbiAgICAgICAgc3R5bGVzOiAoKSA9PiB7XG4gICAgICAgICAgdmFyIGE7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJvb3Q6IE8ubWVyZ2UoXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgICAgICAgICAgICAgIFwiLm1hbnRpbmUtTWVudS1pdGVtXCI6IHtcbiAgICAgICAgICAgICAgICAgIC8vIEljb25cbiAgICAgICAgICAgICAgICAgIFwiLm1hbnRpbmUtTWVudS1pdGVtSWNvblwiOiB7XG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogZS5jb2xvcnMudG9vbHRpcC5iYWNrZ3JvdW5kLFxuICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IGcsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBlLmNvbG9ycy50b29sdGlwLnRleHQsXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IFwiOHB4XCJcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAvLyBUZXh0XG4gICAgICAgICAgICAgICAgICBcIi5tYW50aW5lLU1lbnUtaXRlbUxhYmVsXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZ1JpZ2h0OiBcIjE2cHhcIixcbiAgICAgICAgICAgICAgICAgICAgXCIubWFudGluZS1TdGFjay1yb290XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBnYXA6IFwiMFwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAvLyBCYWRnZSAoa2V5Ym9hcmQgc2hvcnRjdXQpXG4gICAgICAgICAgICAgICAgICBcIi5tYW50aW5lLU1lbnUtaXRlbVJpZ2h0U2VjdGlvblwiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiLm1hbnRpbmUtQmFkZ2Utcm9vdFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBlLmNvbG9ycy50b29sdGlwLmJhY2tncm91bmQsXG4gICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGUuY29sb3JzLnRvb2x0aXAudGV4dFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAoKGEgPSBlLmNvbXBvbmVudFN0eWxlcykgPT0gbnVsbCA/IHZvaWQgMCA6IGEuY2FsbChlLCBlKS5TbGFzaE1lbnUpIHx8IHt9XG4gICAgICAgICAgICApXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFNpZGVNZW51OiB7XG4gICAgICAgIHN0eWxlczogKCkgPT4ge1xuICAgICAgICAgIHZhciBhO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByb290OiBPLm1lcmdlKFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcInRyYW5zcGFyZW50XCIsXG4gICAgICAgICAgICAgICAgXCIubWFudGluZS1VbnN0eWxlZEJ1dHRvbi1yb290XCI6IHtcbiAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJ0cmFuc3BhcmVudFwiLFxuICAgICAgICAgICAgICAgICAgY29sb3I6IGUuY29sb3JzLnNpZGVNZW51XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIi5tYW50aW5lLVVuc3R5bGVkQnV0dG9uLXJvb3Q6aG92ZXJcIjoge1xuICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBlLmNvbG9ycy5ob3ZlcmVkLmJhY2tncm91bmRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICgoYSA9IGUuY29tcG9uZW50U3R5bGVzKSA9PSBudWxsID8gdm9pZCAwIDogYS5jYWxsKGUsIGUpLlNpZGVNZW51KSB8fCB7fVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGZvbnRGYW1pbHk6IGUuZm9udEZhbWlseSxcbiAgICBvdGhlcjoge1xuICAgICAgdGV4dENvbG9yczogaSxcbiAgICAgIGJhY2tncm91bmRDb2xvcnM6IHNcbiAgICB9XG4gIH07XG59LCBfZSA9IGFlKChlLCBuKSA9PiB7XG4gIGNvbnN0IHsgY2xhc3NlczogbyB9ID0gJCh7IHJvb3Q6IHt9IH0pKHZvaWQgMCwge1xuICAgIG5hbWU6IFwiVG9vbGJhclwiXG4gIH0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIHIuanN4KFxuICAgIEhlLFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogZS5jbGFzc05hbWUgPyBgJHtvLnJvb3R9ICR7ZS5jbGFzc05hbWV9YCA6IG8ucm9vdCxcbiAgICAgIHJlZjogbixcbiAgICAgIC4uLmUsXG4gICAgICBjaGlsZHJlbjogZS5jaGlsZHJlblxuICAgIH1cbiAgKTtcbn0pO1xudmFyIHh0ID0ge1xuICBjb2xvcjogdm9pZCAwLFxuICBzaXplOiB2b2lkIDAsXG4gIGNsYXNzTmFtZTogdm9pZCAwLFxuICBzdHlsZTogdm9pZCAwLFxuICBhdHRyOiB2b2lkIDBcbn0sIGN0ID0gTi5jcmVhdGVDb250ZXh0ICYmIE4uY3JlYXRlQ29udGV4dCh4dCksIFcgPSBnbG9iYWxUaGlzICYmIGdsb2JhbFRoaXMuX19hc3NpZ24gfHwgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBXID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbihlKSB7XG4gICAgZm9yICh2YXIgbiwgbyA9IDEsIGkgPSBhcmd1bWVudHMubGVuZ3RoOyBvIDwgaTsgbysrKSB7XG4gICAgICBuID0gYXJndW1lbnRzW29dO1xuICAgICAgZm9yICh2YXIgcyBpbiBuKVxuICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobiwgcykgJiYgKGVbc10gPSBuW3NdKTtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH0sIFcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn0sIEJyID0gZ2xvYmFsVGhpcyAmJiBnbG9iYWxUaGlzLl9fcmVzdCB8fCBmdW5jdGlvbihlLCBuKSB7XG4gIHZhciBvID0ge307XG4gIGZvciAodmFyIGkgaW4gZSlcbiAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSwgaSkgJiYgbi5pbmRleE9mKGkpIDwgMCAmJiAob1tpXSA9IGVbaV0pO1xuICBpZiAoZSAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09IFwiZnVuY3Rpb25cIilcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHMgPCBpLmxlbmd0aDsgcysrKVxuICAgICAgbi5pbmRleE9mKGlbc10pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoZSwgaVtzXSkgJiYgKG9baVtzXV0gPSBlW2lbc11dKTtcbiAgcmV0dXJuIG87XG59O1xuZnVuY3Rpb24gbXQoZSkge1xuICByZXR1cm4gZSAmJiBlLm1hcChmdW5jdGlvbihuLCBvKSB7XG4gICAgcmV0dXJuIE4uY3JlYXRlRWxlbWVudChuLnRhZywgVyh7XG4gICAgICBrZXk6IG9cbiAgICB9LCBuLmF0dHIpLCBtdChuLmNoaWxkKSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gaihlKSB7XG4gIHJldHVybiBmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuIE4uY3JlYXRlRWxlbWVudChfciwgVyh7XG4gICAgICBhdHRyOiBXKHt9LCBlLmF0dHIpXG4gICAgfSwgbiksIG10KGUuY2hpbGQpKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIF9yKGUpIHtcbiAgdmFyIG4gPSBmdW5jdGlvbihvKSB7XG4gICAgdmFyIGkgPSBlLmF0dHIsIHMgPSBlLnNpemUsIGMgPSBlLnRpdGxlLCB1ID0gQnIoZSwgW1wiYXR0clwiLCBcInNpemVcIiwgXCJ0aXRsZVwiXSksIGcgPSBzIHx8IG8uc2l6ZSB8fCBcIjFlbVwiLCBhO1xuICAgIHJldHVybiBvLmNsYXNzTmFtZSAmJiAoYSA9IG8uY2xhc3NOYW1lKSwgZS5jbGFzc05hbWUgJiYgKGEgPSAoYSA/IGEgKyBcIiBcIiA6IFwiXCIpICsgZS5jbGFzc05hbWUpLCBOLmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgVyh7XG4gICAgICBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsXG4gICAgICBmaWxsOiBcImN1cnJlbnRDb2xvclwiLFxuICAgICAgc3Ryb2tlV2lkdGg6IFwiMFwiXG4gICAgfSwgby5hdHRyLCBpLCB1LCB7XG4gICAgICBjbGFzc05hbWU6IGEsXG4gICAgICBzdHlsZTogVyhXKHtcbiAgICAgICAgY29sb3I6IGUuY29sb3IgfHwgby5jb2xvclxuICAgICAgfSwgby5zdHlsZSksIGUuc3R5bGUpLFxuICAgICAgaGVpZ2h0OiBnLFxuICAgICAgd2lkdGg6IGcsXG4gICAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICAgfSksIGMgJiYgTi5jcmVhdGVFbGVtZW50KFwidGl0bGVcIiwgbnVsbCwgYyksIGUuY2hpbGRyZW4pO1xuICB9O1xuICByZXR1cm4gY3QgIT09IHZvaWQgMCA/IE4uY3JlYXRlRWxlbWVudChjdC5Db25zdW1lciwgbnVsbCwgZnVuY3Rpb24obykge1xuICAgIHJldHVybiBuKG8pO1xuICB9KSA6IG4oeHQpO1xufVxuZnVuY3Rpb24gRHIoZSkge1xuICByZXR1cm4gaih7IHRhZzogXCJzdmdcIiwgYXR0cjogeyB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiIH0sIGNoaWxkOiBbeyB0YWc6IFwiZ1wiLCBhdHRyOiB7fSwgY2hpbGQ6IFt7IHRhZzogXCJwYXRoXCIsIGF0dHI6IHsgZmlsbDogXCJub25lXCIsIGQ6IFwiTTAgMGgyNHYyNEgwelwiIH0gfSwgeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGQ6IFwiTTIzIDEybC03LjA3MSA3LjA3MS0xLjQxNC0xLjQxNEwyMC4xNzIgMTJsLTUuNjU3LTUuNjU3IDEuNDE0LTEuNDE0TDIzIDEyek0zLjgyOCAxMmw1LjY1NyA1LjY1Ny0xLjQxNCAxLjQxNEwxIDEybDcuMDcxLTcuMDcxIDEuNDE0IDEuNDE0TDMuODI4IDEyelwiIH0gfV0gfV0gfSkoZSk7XG59XG5mdW5jdGlvbiBQcihlKSB7XG4gIHJldHVybiBqKHsgdGFnOiBcInN2Z1wiLCBhdHRyOiB7IHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIgfSwgY2hpbGQ6IFt7IHRhZzogXCJnXCIsIGF0dHI6IHt9LCBjaGlsZDogW3sgdGFnOiBcInBhdGhcIiwgYXR0cjogeyBmaWxsOiBcIm5vbmVcIiwgZDogXCJNMCAwaDI0djI0SDB6XCIgfSB9LCB7IHRhZzogXCJwYXRoXCIsIGF0dHI6IHsgZDogXCJNMyA0aDE4djJIM1Y0em0yIDE1aDE0djJINXYtMnptLTItNWgxOHYySDN2LTJ6bTItNWgxNHYySDVWOXpcIiB9IH1dIH1dIH0pKGUpO1xufVxuZnVuY3Rpb24gT3IoZSkge1xuICByZXR1cm4gaih7IHRhZzogXCJzdmdcIiwgYXR0cjogeyB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiIH0sIGNoaWxkOiBbeyB0YWc6IFwiZ1wiLCBhdHRyOiB7fSwgY2hpbGQ6IFt7IHRhZzogXCJwYXRoXCIsIGF0dHI6IHsgZmlsbDogXCJub25lXCIsIGQ6IFwiTTAgMGgyNHYyNEgwelwiIH0gfSwgeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGQ6IFwiTTMgNGgxOHYySDNWNHptMCAxNWgxOHYySDN2LTJ6bTAtNWgxOHYySDN2LTJ6bTAtNWgxOHYySDNWOXpcIiB9IH1dIH1dIH0pKGUpO1xufVxuZnVuY3Rpb24gRnIoZSkge1xuICByZXR1cm4gaih7IHRhZzogXCJzdmdcIiwgYXR0cjogeyB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiIH0sIGNoaWxkOiBbeyB0YWc6IFwiZ1wiLCBhdHRyOiB7fSwgY2hpbGQ6IFt7IHRhZzogXCJwYXRoXCIsIGF0dHI6IHsgZmlsbDogXCJub25lXCIsIGQ6IFwiTTAgMGgyNHYyNEgwelwiIH0gfSwgeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGQ6IFwiTTMgNGgxOHYySDNWNHptMCAxNWgxNHYySDN2LTJ6bTAtNWgxOHYySDN2LTJ6bTAtNWgxNHYySDNWOXpcIiB9IH1dIH1dIH0pKGUpO1xufVxuZnVuY3Rpb24gQXIoZSkge1xuICByZXR1cm4gaih7IHRhZzogXCJzdmdcIiwgYXR0cjogeyB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiIH0sIGNoaWxkOiBbeyB0YWc6IFwiZ1wiLCBhdHRyOiB7fSwgY2hpbGQ6IFt7IHRhZzogXCJwYXRoXCIsIGF0dHI6IHsgZmlsbDogXCJub25lXCIsIGQ6IFwiTTAgMGgyNHYyNEgwelwiIH0gfSwgeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGQ6IFwiTTMgNGgxOHYySDNWNHptNCAxNWgxNHYySDd2LTJ6bS00LTVoMTh2Mkgzdi0yem00LTVoMTR2Mkg3Vjl6XCIgfSB9XSB9XSB9KShlKTtcbn1cbmZ1bmN0aW9uIExyKGUpIHtcbiAgcmV0dXJuIGooeyB0YWc6IFwic3ZnXCIsIGF0dHI6IHsgdmlld0JveDogXCIwIDAgMjQgMjRcIiB9LCBjaGlsZDogW3sgdGFnOiBcImdcIiwgYXR0cjoge30sIGNoaWxkOiBbeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGZpbGw6IFwibm9uZVwiLCBkOiBcIk0wIDBoMjR2MjRIMHpcIiB9IH0sIHsgdGFnOiBcInBhdGhcIiwgYXR0cjogeyBkOiBcIk04IDExaDQuNWEyLjUgMi41IDAgMSAwIDAtNUg4djV6bTEwIDQuNWE0LjUgNC41IDAgMCAxLTQuNSA0LjVINlY0aDYuNWE0LjUgNC41IDAgMCAxIDMuMjU2IDcuNjA2QTQuNDk4IDQuNDk4IDAgMCAxIDE4IDE1LjV6TTggMTN2NWg1LjVhMi41IDIuNSAwIDEgMCAwLTVIOHpcIiB9IH1dIH1dIH0pKGUpO1xufVxuZnVuY3Rpb24ga3QoZSkge1xuICByZXR1cm4gaih7IHRhZzogXCJzdmdcIiwgYXR0cjogeyB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiIH0sIGNoaWxkOiBbeyB0YWc6IFwiZ1wiLCBhdHRyOiB7fSwgY2hpbGQ6IFt7IHRhZzogXCJwYXRoXCIsIGF0dHI6IHsgZmlsbDogXCJub25lXCIsIGQ6IFwiTTAgMEgyNFYyNEgwelwiIH0gfSwgeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGQ6IFwiTTEzIDIwaC0ydi03SDR2N0gyVjRoMnY3aDdWNGgydjE2em04LTEydjEyaC0ydi05Ljc5NmwtMiAuNTM2VjguNjdMMTkuNSA4SDIxelwiIH0gfV0gfV0gfSkoZSk7XG59XG5mdW5jdGlvbiB5dChlKSB7XG4gIHJldHVybiBqKHsgdGFnOiBcInN2Z1wiLCBhdHRyOiB7IHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIgfSwgY2hpbGQ6IFt7IHRhZzogXCJnXCIsIGF0dHI6IHt9LCBjaGlsZDogW3sgdGFnOiBcInBhdGhcIiwgYXR0cjogeyBmaWxsOiBcIm5vbmVcIiwgZDogXCJNMCAwSDI0VjI0SDB6XCIgfSB9LCB7IHRhZzogXCJwYXRoXCIsIGF0dHI6IHsgZDogXCJNNCA0djdoN1Y0aDJ2MTZoLTJ2LTdINHY3SDJWNGgyem0xNC41IDRjMi4wNzEgMCAzLjc1IDEuNjc5IDMuNzUgMy43NSAwIC44NTctLjI4OCAxLjY0OC0uNzcyIDIuMjhsLS4xNDguMThMMTguMDM0IDE4SDIydjJoLTd2LTEuNTU2bDQuODItNS41NDZjLjI2OC0uMzA3LjQzLS43MDkuNDMtMS4xNDggMC0uOTY2LS43ODQtMS43NS0xLjc1LTEuNzUtLjkxOCAwLTEuNjcxLjcwNy0xLjc0NCAxLjYwNmwtLjAwNi4xNDRoLTJDMTQuNzUgOS42NzkgMTYuNDI5IDggMTguNSA4elwiIH0gfV0gfV0gfSkoZSk7XG59XG5mdW5jdGlvbiBwdChlKSB7XG4gIHJldHVybiBqKHsgdGFnOiBcInN2Z1wiLCBhdHRyOiB7IHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIgfSwgY2hpbGQ6IFt7IHRhZzogXCJnXCIsIGF0dHI6IHt9LCBjaGlsZDogW3sgdGFnOiBcInBhdGhcIiwgYXR0cjogeyBmaWxsOiBcIm5vbmVcIiwgZDogXCJNMCAwSDI0VjI0SDB6XCIgfSB9LCB7IHRhZzogXCJwYXRoXCIsIGF0dHI6IHsgZDogXCJNMjIgOGwtLjAwMiAyLTIuNTA1IDIuODgzYzEuNTkuNDM1IDIuNzU3IDEuODkgMi43NTcgMy42MTcgMCAyLjA3MS0xLjY3OSAzLjc1LTMuNzUgMy43NS0xLjgyNiAwLTMuMzQ3LTEuMzA1LTMuNjgyLTMuMDMzbDEuOTY0LS4zODJjLjE1Ni44MDYuODY2IDEuNDE1IDEuNzE4IDEuNDE1Ljk2NiAwIDEuNzUtLjc4NCAxLjc1LTEuNzVzLS43ODQtMS43NS0xLjc1LTEuNzVjLS4yODYgMC0uNTU2LjA2OS0uNzk0LjE5bC0xLjMwNy0xLjU0N0wxOS4zNSAxMEgxNVY4aDd6TTQgNHY3aDdWNGgydjE2aC0ydi03SDR2N0gyVjRoMnpcIiB9IH1dIH1dIH0pKGUpO1xufVxuZnVuY3Rpb24gVnIoZSkge1xuICByZXR1cm4gaih7IHRhZzogXCJzdmdcIiwgYXR0cjogeyB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiIH0sIGNoaWxkOiBbeyB0YWc6IFwiZ1wiLCBhdHRyOiB7fSwgY2hpbGQ6IFt7IHRhZzogXCJwYXRoXCIsIGF0dHI6IHsgZmlsbDogXCJub25lXCIsIGQ6IFwiTTAgMGgyNHYyNEgwelwiIH0gfSwgeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGQ6IFwiTTMgNGgxOHYySDNWNHptMCAxNWgxOHYySDN2LTJ6bTgtNWgxMHYySDExdi0yem0wLTVoMTB2MkgxMVY5em0tOCAzLjVMNyA5djdsLTQtMy41elwiIH0gfV0gfV0gfSkoZSk7XG59XG5mdW5jdGlvbiBVcihlKSB7XG4gIHJldHVybiBqKHsgdGFnOiBcInN2Z1wiLCBhdHRyOiB7IHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIgfSwgY2hpbGQ6IFt7IHRhZzogXCJnXCIsIGF0dHI6IHt9LCBjaGlsZDogW3sgdGFnOiBcInBhdGhcIiwgYXR0cjogeyBmaWxsOiBcIm5vbmVcIiwgZDogXCJNMCAwaDI0djI0SDB6XCIgfSB9LCB7IHRhZzogXCJwYXRoXCIsIGF0dHI6IHsgZDogXCJNMyA0aDE4djJIM1Y0em0wIDE1aDE4djJIM3YtMnptOC01aDEwdjJIMTF2LTJ6bTAtNWgxMHYySDExVjl6bS00IDMuNUwzIDE2VjlsNCAzLjV6XCIgfSB9XSB9XSB9KShlKTtcbn1cbmZ1bmN0aW9uIE5yKGUpIHtcbiAgcmV0dXJuIGooeyB0YWc6IFwic3ZnXCIsIGF0dHI6IHsgdmlld0JveDogXCIwIDAgMjQgMjRcIiB9LCBjaGlsZDogW3sgdGFnOiBcImdcIiwgYXR0cjoge30sIGNoaWxkOiBbeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGZpbGw6IFwibm9uZVwiLCBkOiBcIk0wIDBoMjR2MjRIMHpcIiB9IH0sIHsgdGFnOiBcInBhdGhcIiwgYXR0cjogeyBkOiBcIk0xNSAyMEg3di0yaDIuOTI3bDIuMTE2LTEySDlWNGg4djJoLTIuOTI3bC0yLjExNiAxMkgxNXpcIiB9IH1dIH1dIH0pKGUpO1xufVxuZnVuY3Rpb24gJHIoZSkge1xuICByZXR1cm4gaih7IHRhZzogXCJzdmdcIiwgYXR0cjogeyB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiIH0sIGNoaWxkOiBbeyB0YWc6IFwiZ1wiLCBhdHRyOiB7fSwgY2hpbGQ6IFt7IHRhZzogXCJwYXRoXCIsIGF0dHI6IHsgZmlsbDogXCJub25lXCIsIGQ6IFwiTTAgMGgyNHYyNEgwelwiIH0gfSwgeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGQ6IFwiTTE3IDE3aDV2MmgtM3YzaC0ydi01ek03IDdIMlY1aDNWMmgydjV6bTExLjM2NCA4LjUzNkwxNi45NSAxNC4xMmwxLjQxNC0xLjQxNGE1IDUgMCAxIDAtNy4wNzEtNy4wNzFMOS44NzkgNy4wNSA4LjQ2NCA1LjYzNiA5Ljg4IDQuMjIyYTcgNyAwIDAgMSA5LjkgOS45bC0xLjQxNSAxLjQxNHptLTIuODI4IDIuODI4bC0xLjQxNSAxLjQxNGE3IDcgMCAwIDEtOS45LTkuOWwxLjQxNS0xLjQxNEw3LjA1IDkuODhsLTEuNDE0IDEuNDE0YTUgNSAwIDEgMCA3LjA3MSA3LjA3MWwxLjQxNC0xLjQxNCAxLjQxNSAxLjQxNHptLS43MDgtMTAuNjA3bDEuNDE1IDEuNDE1LTcuMDcxIDcuMDctMS40MTUtMS40MTQgNy4wNzEtNy4wN3pcIiB9IH1dIH1dIH0pKGUpO1xufVxuZnVuY3Rpb24gQ3QoZSkge1xuICByZXR1cm4gaih7IHRhZzogXCJzdmdcIiwgYXR0cjogeyB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiIH0sIGNoaWxkOiBbeyB0YWc6IFwiZ1wiLCBhdHRyOiB7fSwgY2hpbGQ6IFt7IHRhZzogXCJwYXRoXCIsIGF0dHI6IHsgZmlsbDogXCJub25lXCIsIGQ6IFwiTTAgMGgyNHYyNEgwelwiIH0gfSwgeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGQ6IFwiTTE4LjM2NCAxNS41MzZMMTYuOTUgMTQuMTJsMS40MTQtMS40MTRhNSA1IDAgMSAwLTcuMDcxLTcuMDcxTDkuODc5IDcuMDUgOC40NjQgNS42MzYgOS44OCA0LjIyMmE3IDcgMCAwIDEgOS45IDkuOWwtMS40MTUgMS40MTR6bS0yLjgyOCAyLjgyOGwtMS40MTUgMS40MTRhNyA3IDAgMCAxLTkuOS05LjlsMS40MTUtMS40MTRMNy4wNSA5Ljg4bC0xLjQxNCAxLjQxNGE1IDUgMCAxIDAgNy4wNzEgNy4wNzFsMS40MTQtMS40MTQgMS40MTUgMS40MTR6bS0uNzA4LTEwLjYwN2wxLjQxNSAxLjQxNS03LjA3MSA3LjA3LTEuNDE1LTEuNDE0IDcuMDcxLTcuMDd6XCIgfSB9XSB9XSB9KShlKTtcbn1cbmZ1bmN0aW9uIGp0KGUpIHtcbiAgcmV0dXJuIGooeyB0YWc6IFwic3ZnXCIsIGF0dHI6IHsgdmlld0JveDogXCIwIDAgMjQgMjRcIiB9LCBjaGlsZDogW3sgdGFnOiBcImdcIiwgYXR0cjoge30sIGNoaWxkOiBbeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGZpbGw6IFwibm9uZVwiLCBkOiBcIk0wIDBoMjR2MjRIMHpcIiB9IH0sIHsgdGFnOiBcInBhdGhcIiwgYXR0cjogeyBkOiBcIk04IDRoMTN2Mkg4VjR6TTUgM3YzaDF2MUgzVjZoMVY0SDNWM2gyek0zIDE0di0yLjVoMlYxMUgzdi0xaDN2Mi41SDR2LjVoMnYxSDN6bTIgNS41SDN2LTFoMlYxOEgzdi0xaDN2NEgzdi0xaDJ2LS41ek04IDExaDEzdjJIOHYtMnptMCA3aDEzdjJIOHYtMnpcIiB9IH1dIH1dIH0pKGUpO1xufVxuZnVuY3Rpb24gVHQoZSkge1xuICByZXR1cm4gaih7IHRhZzogXCJzdmdcIiwgYXR0cjogeyB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiIH0sIGNoaWxkOiBbeyB0YWc6IFwiZ1wiLCBhdHRyOiB7fSwgY2hpbGQ6IFt7IHRhZzogXCJwYXRoXCIsIGF0dHI6IHsgZmlsbDogXCJub25lXCIsIGQ6IFwiTTAgMGgyNHYyNEgwelwiIH0gfSwgeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGQ6IFwiTTggNGgxM3YySDhWNHpNNC41IDYuNWExLjUgMS41IDAgMSAxIDAtMyAxLjUgMS41IDAgMCAxIDAgM3ptMCA3YTEuNSAxLjUgMCAxIDEgMC0zIDEuNSAxLjUgMCAwIDEgMCAzem0wIDYuOWExLjUgMS41IDAgMSAxIDAtMyAxLjUgMS41IDAgMCAxIDAgM3pNOCAxMWgxM3YySDh2LTJ6bTAgN2gxM3YySDh2LTJ6XCIgfSB9XSB9XSB9KShlKTtcbn1cbmZ1bmN0aW9uIFdyKGUpIHtcbiAgcmV0dXJuIGooeyB0YWc6IFwic3ZnXCIsIGF0dHI6IHsgdmlld0JveDogXCIwIDAgMjQgMjRcIiB9LCBjaGlsZDogW3sgdGFnOiBcImdcIiwgYXR0cjoge30sIGNoaWxkOiBbeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGZpbGw6IFwibm9uZVwiLCBkOiBcIk0wIDBoMjR2MjRIMHpcIiB9IH0sIHsgdGFnOiBcInBhdGhcIiwgYXR0cjogeyBkOiBcIk0xNy4xNTQgMTRjLjIzLjUxNi4zNDYgMS4wOS4zNDYgMS43MiAwIDEuMzQyLS41MjQgMi4zOTItMS41NzEgMy4xNDdDMTQuODggMTkuNjIyIDEzLjQzMyAyMCAxMS41ODYgMjBjLTEuNjQgMC0zLjI2My0uMzgxLTQuODctMS4xNDRWMTYuNmMxLjUyLjg3NyAzLjA3NSAxLjMxNiA0LjY2NiAxLjMxNiAyLjU1MSAwIDMuODMtLjczMiAzLjgzOS0yLjE5N2EyLjIxIDIuMjEgMCAwIDAtLjY0OC0xLjYwM2wtLjEyLS4xMTdIM3YtMmgxOHYyaC0zLjg0NnptLTQuMDc4LTNINy42MjlhNC4wODYgNC4wODYgMCAwIDEtLjQ4MS0uNTIyQzYuNzE2IDkuOTIgNi41IDkuMjQ2IDYuNSA4LjQ1MmMwLTEuMjM2LjQ2Ni0yLjI4NyAxLjM5Ny0zLjE1M0M4LjgzIDQuNDMzIDEwLjI3MSA0IDEyLjIyMiA0YzEuNDcxIDAgMi44NzkuMzI4IDQuMjIyLjk4NHYyLjE1MmMtMS4yLS42ODctMi41MTUtMS4wMy0zLjk0Ni0xLjAzLTIuNDggMC0zLjcxOS43ODItMy43MTkgMi4zNDYgMCAuNDIuMjE4Ljc4Ni42NTQgMS4wOTkuNDM2LjMxMy45NzQuNTYyIDEuNjEzLjc1LjYyLjE4IDEuMjk3LjQxNCAyLjAzLjY5OXpcIiB9IH1dIH1dIH0pKGUpO1xufVxuZnVuY3Rpb24gaWUoZSkge1xuICByZXR1cm4gaih7IHRhZzogXCJzdmdcIiwgYXR0cjogeyB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiIH0sIGNoaWxkOiBbeyB0YWc6IFwiZ1wiLCBhdHRyOiB7fSwgY2hpbGQ6IFt7IHRhZzogXCJwYXRoXCIsIGF0dHI6IHsgZmlsbDogXCJub25lXCIsIGQ6IFwiTTAgMGgyNHYyNEgwelwiIH0gfSwgeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGQ6IFwiTTEzIDZ2MTVoLTJWNkg1VjRoMTR2MnpcIiB9IH1dIH1dIH0pKGUpO1xufVxuZnVuY3Rpb24gWXIoZSkge1xuICByZXR1cm4gaih7IHRhZzogXCJzdmdcIiwgYXR0cjogeyB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiIH0sIGNoaWxkOiBbeyB0YWc6IFwiZ1wiLCBhdHRyOiB7fSwgY2hpbGQ6IFt7IHRhZzogXCJwYXRoXCIsIGF0dHI6IHsgZmlsbDogXCJub25lXCIsIGQ6IFwiTTAgMGgyNHYyNEgwelwiIH0gfSwgeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGQ6IFwiTTggM3Y5YTQgNCAwIDEgMCA4IDBWM2gydjlhNiA2IDAgMSAxLTEyIDBWM2gyek00IDIwaDE2djJINHYtMnpcIiB9IH1dIH1dIH0pKGUpO1xufVxuZnVuY3Rpb24gcXIoZSkge1xuICByZXR1cm4gaih7IHRhZzogXCJzdmdcIiwgYXR0cjogeyB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiIH0sIGNoaWxkOiBbeyB0YWc6IFwiZ1wiLCBhdHRyOiB7fSwgY2hpbGQ6IFt7IHRhZzogXCJwYXRoXCIsIGF0dHI6IHsgZmlsbDogXCJub25lXCIsIGQ6IFwiTTAgMGgyNHYyNEgwelwiIH0gfSwgeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGQ6IFwiTTUgMTEuMWwyLTIgNS41IDUuNSAzLjUtMy41IDMgM1Y1SDV2Ni4xek00IDNoMTZhMSAxIDAgMCAxIDEgMXYxNmExIDEgMCAwIDEtMSAxSDRhMSAxIDAgMCAxLTEtMVY0YTEgMSAwIDAgMSAxLTF6bTExLjUgN2ExLjUgMS41IDAgMSAxIDAtMyAxLjUgMS41IDAgMCAxIDAgM3pcIiB9IH1dIH1dIH0pKGUpO1xufVxuZnVuY3Rpb24gS3IoZSkge1xuICByZXR1cm4gaih7IHRhZzogXCJzdmdcIiwgYXR0cjogeyB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiIH0sIGNoaWxkOiBbeyB0YWc6IFwiZ1wiLCBhdHRyOiB7fSwgY2hpbGQ6IFt7IHRhZzogXCJwYXRoXCIsIGF0dHI6IHsgZmlsbDogXCJub25lXCIsIGQ6IFwiTTAgMEgyNFYyNEgwelwiIH0gfSwgeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGQ6IFwiTTIwIDNjLjU1MiAwIDEgLjQ0OCAxIDF2MS43NTdsLTIgMlY1SDV2OC4xbDQtNCA0LjMyOCA0LjMyOS0xLjMyNyAxLjMyNy0uMDA2IDQuMjM5IDQuMjQ2LjAwNiAxLjMzLTEuMzNMMTguODk5IDE5SDE5di0yLjc1OGwyLTJWMjBjMCAuNTUyLS40NDggMS0xIDFINGMtLjU1MiAwLTEtLjQ0OC0xLTFWNGMwLS41NTIuNDQ4LTEgMS0xaDE2em0xLjc3OCA0LjgwOGwxLjQxNCAxLjQxNEwxNS40MTQgMTdsLTEuNDE2LS4wMDIuMDAyLTEuNDEyIDcuNzc4LTcuNzc4ek0xNS41IDdjLjgyOCAwIDEuNS42NzIgMS41IDEuNXMtLjY3MiAxLjUtMS41IDEuNVMxNCA5LjMyOCAxNCA4LjUgMTQuNjcyIDcgMTUuNSA3elwiIH0gfV0gfV0gfSkoZSk7XG59XG5mdW5jdGlvbiBHcihlKSB7XG4gIHJldHVybiBqKHsgdGFnOiBcInN2Z1wiLCBhdHRyOiB7IHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIgfSwgY2hpbGQ6IFt7IHRhZzogXCJnXCIsIGF0dHI6IHt9LCBjaGlsZDogW3sgdGFnOiBcInBhdGhcIiwgYXR0cjogeyBmaWxsOiBcIm5vbmVcIiwgZDogXCJNMCAwaDI0djI0SDB6XCIgfSB9LCB7IHRhZzogXCJwYXRoXCIsIGF0dHI6IHsgZDogXCJNMTAgNnYySDV2MTFoMTF2LTVoMnY2YTEgMSAwIDAgMS0xIDFINGExIDEgMCAwIDEtMS0xVjdhMSAxIDAgMCAxIDEtMWg2em0xMS0zdjlsLTMuNzk0LTMuNzkzLTUuOTk5IDYtMS40MTQtMS40MTQgNS45OTktNkwxMiAzaDl6XCIgfSB9XSB9XSB9KShlKTtcbn1cbmZ1bmN0aW9uIFJlKGUpIHtcbiAgcmV0dXJuIGooeyB0YWc6IFwic3ZnXCIsIGF0dHI6IHsgdmVyc2lvbjogXCIxLjJcIiwgYmFzZVByb2ZpbGU6IFwidGlueVwiLCB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiIH0sIGNoaWxkOiBbeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGQ6IFwiTTE2Ljk3MiA2LjI1MWMtLjk2Ny0uNTM4LTIuMTg1LS4xODgtMi43Mi43NzdsLTMuNzEzIDYuNjgyLTIuMTI1LTIuMTI1Yy0uNzgxLS43ODEtMi4wNDctLjc4MS0yLjgyOCAwLS43ODEuNzgxLS43ODEgMi4wNDcgMCAyLjgyOGw0IDRjLjM3OC4zNzkuODg4LjU4NyAxLjQxNC41ODdsLjI3Ny0uMDJjLjYyMS0uMDg3IDEuMTY2LS40NiAxLjQ3MS0xLjAwOWw1LTljLjUzNy0uOTY2LjE4OS0yLjE4My0uNzc2LTIuNzJ6XCIgfSB9XSB9KShlKTtcbn1cbmZ1bmN0aW9uIEpyKGUpIHtcbiAgY29uc3QgbiA9IGUuaWNvbjtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyByLmpzeChcbiAgICB3Lkl0ZW0sXG4gICAge1xuICAgICAgb25DbGljazogZS5vbkNsaWNrLFxuICAgICAgaWNvbjogbiAmJiAvKiBAX19QVVJFX18gKi8gci5qc3gobiwgeyBzaXplOiAxNiB9KSxcbiAgICAgIHJpZ2h0U2VjdGlvbjogZS5pc1NlbGVjdGVkID8gLyogQF9fUFVSRV9fICovIHIuanN4KFJlLCB7IHNpemU6IDE2IH0pIDogKFxuICAgICAgICAvLyBFbnN1cmVzIHNwYWNlIGZvciB0aWNrIGV2ZW4gaWYgaXRlbSBpc24ndCBjdXJyZW50bHkgc2VsZWN0ZWQuXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyByLmpzeChcImRpdlwiLCB7IHN0eWxlOiB7IHdpZHRoOiBcIjE2cHhcIiwgcGFkZGluZzogXCIwXCIgfSB9KVxuICAgICAgKSxcbiAgICAgIGRpc2FibGVkOiBlLmlzRGlzYWJsZWQsXG4gICAgICBjaGlsZHJlbjogZS50ZXh0XG4gICAgfSxcbiAgICBlLnRleHRcbiAgKTtcbn1cbmZ1bmN0aW9uIFhyKGUpIHtcbiAgcmV0dXJuIGooeyB0YWc6IFwic3ZnXCIsIGF0dHI6IHsgdmlld0JveDogXCIwIDAgMjAgMjBcIiwgZmlsbDogXCJjdXJyZW50Q29sb3JcIiwgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIiB9LCBjaGlsZDogW3sgdGFnOiBcInBhdGhcIiwgYXR0cjogeyBmaWxsUnVsZTogXCJldmVub2RkXCIsIGQ6IFwiTTUuMjkzIDcuMjkzYTEgMSAwIDAxMS40MTQgMEwxMCAxMC41ODZsMy4yOTMtMy4yOTNhMSAxIDAgMTExLjQxNCAxLjQxNGwtNCA0YTEgMSAwIDAxLTEuNDE0IDBsLTQtNGExIDEgMCAwMTAtMS40MTR6XCIsIGNsaXBSdWxlOiBcImV2ZW5vZGRcIiB9IH1dIH0pKGUpO1xufVxuZnVuY3Rpb24gWnIoZSkge1xuICByZXR1cm4gaih7IHRhZzogXCJzdmdcIiwgYXR0cjogeyB2aWV3Qm94OiBcIjAgMCAyMCAyMFwiLCBmaWxsOiBcImN1cnJlbnRDb2xvclwiLCBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiIH0sIGNoaWxkOiBbeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGZpbGxSdWxlOiBcImV2ZW5vZGRcIiwgZDogXCJNNy4yOTMgMTQuNzA3YTEgMSAwIDAxMC0xLjQxNEwxMC41ODYgMTAgNy4yOTMgNi43MDdhMSAxIDAgMDExLjQxNC0xLjQxNGw0IDRhMSAxIDAgMDEwIDEuNDE0bC00IDRhMSAxIDAgMDEtMS40MTQgMHpcIiwgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiIH0gfV0gfSkoZSk7XG59XG5jb25zdCBRciA9IGFlKChlLCBuKSA9PiB7XG4gIGNvbnN0IG8gPSBlLmljb247XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gci5qc3goXG4gICAgSWUsXG4gICAge1xuICAgICAgbGVmdEljb246IG8gJiYgLyogQF9fUFVSRV9fICovIHIuanN4KG8sIHsgc2l6ZTogMTYgfSksXG4gICAgICByaWdodEljb246IC8qIEBfX1BVUkVfXyAqLyByLmpzeChYciwge30pLFxuICAgICAgc2l6ZTogXCJ4c1wiLFxuICAgICAgdmFyaWFudDogXCJzdWJ0bGVcIixcbiAgICAgIGRpc2FibGVkOiBlLmlzRGlzYWJsZWQsXG4gICAgICBvbkNsaWNrOiBlLm9uQ2xpY2ssXG4gICAgICByZWY6IG4sXG4gICAgICBjaGlsZHJlbjogZS50ZXh0XG4gICAgfVxuICApO1xufSk7XG5mdW5jdGlvbiB4ZSgpIHtcbiAgY29uc3QgZSA9IEwobnVsbCk7XG4gIHJldHVybiB7XG4gICAgcmVmOiBlLFxuICAgIHVwZGF0ZU1heEhlaWdodDogKCkgPT4ge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmIChlLmN1cnJlbnQgJiYgZS5jdXJyZW50LmNoaWxkRWxlbWVudENvdW50ID4gMCkge1xuICAgICAgICAgIGUuY3VycmVudC5maXJzdEVsZW1lbnRDaGlsZC5zdHlsZS5tYXhIZWlnaHQgPSBcIm5vbmVcIjtcbiAgICAgICAgICBjb25zdCBuID0gZS5jdXJyZW50LmZpcnN0RWxlbWVudENoaWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgIGUuY3VycmVudC5maXJzdEVsZW1lbnRDaGlsZC5zdHlsZS5tYXhIZWlnaHQgPSBgJHtNYXRoLm1pbihcbiAgICAgICAgICAgIG4udG9wID49IDAgPyB3aW5kb3cuaW5uZXJIZWlnaHQgLSBuLnRvcCAtIDIwIDogbi5ib3R0b20gLSAyMFxuICAgICAgICAgICl9cHhgO1xuICAgICAgICB9XG4gICAgICB9LCAxMCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZW4oZSkge1xuICBjb25zdCBuID0gZS5pdGVtcy5maWx0ZXIoKHMpID0+IHMuaXNTZWxlY3RlZClbMF0sIHsgcmVmOiBvLCB1cGRhdGVNYXhIZWlnaHQ6IGkgfSA9IHhlKCk7XG4gIHJldHVybiBuID8gLyogQF9fUFVSRV9fICovIHIuanN4cyhcbiAgICB3LFxuICAgIHtcbiAgICAgIGV4aXRUcmFuc2l0aW9uRHVyYXRpb246IDAsXG4gICAgICBkaXNhYmxlZDogZS5pc0Rpc2FibGVkLFxuICAgICAgb25PcGVuOiBpLFxuICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgLyogQF9fUFVSRV9fICovIHIuanN4KHcuVGFyZ2V0LCB7IGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gci5qc3goXG4gICAgICAgICAgUXIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgdGV4dDogbi50ZXh0LFxuICAgICAgICAgICAgaWNvbjogbi5pY29uLFxuICAgICAgICAgICAgaXNEaXNhYmxlZDogbi5pc0Rpc2FibGVkXG4gICAgICAgICAgfVxuICAgICAgICApIH0pLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8gci5qc3goXCJkaXZcIiwgeyByZWY6IG8sIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gci5qc3gody5Ecm9wZG93biwgeyBjaGlsZHJlbjogZS5pdGVtcy5tYXAoKHMpID0+IC8qIEBfX1BVUkVfXyAqLyByLmpzeChKciwgeyAuLi5zIH0sIHMudGV4dCkpIH0pIH0pXG4gICAgICBdXG4gICAgfVxuICApIDogbnVsbDtcbn1cbmZ1bmN0aW9uIHRuKGUsIG4pIHtcbiAgQigoKSA9PiAoZS5fdGlwdGFwRWRpdG9yLm9uKFwidXBkYXRlXCIsIG4pLCAoKSA9PiB7XG4gICAgZS5fdGlwdGFwRWRpdG9yLm9mZihcInVwZGF0ZVwiLCBuKTtcbiAgfSksIFtuLCBlLl90aXB0YXBFZGl0b3JdKTtcbn1cbmZ1bmN0aW9uIHJuKGUsIG4pIHtcbiAgQigoKSA9PiAoZS5fdGlwdGFwRWRpdG9yLm9uKFwic2VsZWN0aW9uVXBkYXRlXCIsIG4pLCAoKSA9PiB7XG4gICAgZS5fdGlwdGFwRWRpdG9yLm9mZihcInNlbGVjdGlvblVwZGF0ZVwiLCBuKTtcbiAgfSksIFtuLCBlLl90aXB0YXBFZGl0b3JdKTtcbn1cbmZ1bmN0aW9uIHEoZSwgbikge1xuICB0bihlLCBuKSwgcm4oZSwgbik7XG59XG5mdW5jdGlvbiBHKGUpIHtcbiAgY29uc3QgW24sIG9dID0geChcbiAgICAoKSA9PiB7XG4gICAgICB2YXIgaTtcbiAgICAgIHJldHVybiAoKGkgPSBlLmdldFNlbGVjdGlvbigpKSA9PSBudWxsID8gdm9pZCAwIDogaS5ibG9ja3MpIHx8IFtlLmdldFRleHRDdXJzb3JQb3NpdGlvbigpLmJsb2NrXTtcbiAgICB9XG4gICk7XG4gIHJldHVybiBxKFxuICAgIGUsXG4gICAgKCkgPT4ge1xuICAgICAgdmFyIGk7XG4gICAgICByZXR1cm4gbyhcbiAgICAgICAgKChpID0gZS5nZXRTZWxlY3Rpb24oKSkgPT0gbnVsbCA/IHZvaWQgMCA6IGkuYmxvY2tzKSB8fCBbZS5nZXRUZXh0Q3Vyc29yUG9zaXRpb24oKS5ibG9ja11cbiAgICAgICk7XG4gICAgfVxuICApLCBuO1xufVxuY29uc3Qgbm4gPSBbXG4gIHtcbiAgICBuYW1lOiBcIlBhcmFncmFwaFwiLFxuICAgIHR5cGU6IFwicGFyYWdyYXBoXCIsXG4gICAgaWNvbjogaWUsXG4gICAgaXNTZWxlY3RlZDogKGUpID0+IGUudHlwZSA9PT0gXCJwYXJhZ3JhcGhcIlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJIZWFkaW5nIDFcIixcbiAgICB0eXBlOiBcImhlYWRpbmdcIixcbiAgICBwcm9wczogeyBsZXZlbDogMSB9LFxuICAgIGljb246IGt0LFxuICAgIGlzU2VsZWN0ZWQ6IChlKSA9PiBlLnR5cGUgPT09IFwiaGVhZGluZ1wiICYmIFwibGV2ZWxcIiBpbiBlLnByb3BzICYmIGUucHJvcHMubGV2ZWwgPT09IDFcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiSGVhZGluZyAyXCIsXG4gICAgdHlwZTogXCJoZWFkaW5nXCIsXG4gICAgcHJvcHM6IHsgbGV2ZWw6IDIgfSxcbiAgICBpY29uOiB5dCxcbiAgICBpc1NlbGVjdGVkOiAoZSkgPT4gZS50eXBlID09PSBcImhlYWRpbmdcIiAmJiBcImxldmVsXCIgaW4gZS5wcm9wcyAmJiBlLnByb3BzLmxldmVsID09PSAyXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIkhlYWRpbmcgM1wiLFxuICAgIHR5cGU6IFwiaGVhZGluZ1wiLFxuICAgIHByb3BzOiB7IGxldmVsOiAzIH0sXG4gICAgaWNvbjogcHQsXG4gICAgaXNTZWxlY3RlZDogKGUpID0+IGUudHlwZSA9PT0gXCJoZWFkaW5nXCIgJiYgXCJsZXZlbFwiIGluIGUucHJvcHMgJiYgZS5wcm9wcy5sZXZlbCA9PT0gM1xuICB9LFxuICB7XG4gICAgbmFtZTogXCJCdWxsZXQgTGlzdFwiLFxuICAgIHR5cGU6IFwiYnVsbGV0TGlzdEl0ZW1cIixcbiAgICBpY29uOiBUdCxcbiAgICBpc1NlbGVjdGVkOiAoZSkgPT4gZS50eXBlID09PSBcImJ1bGxldExpc3RJdGVtXCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiTnVtYmVyZWQgTGlzdFwiLFxuICAgIHR5cGU6IFwibnVtYmVyZWRMaXN0SXRlbVwiLFxuICAgIGljb246IGp0LFxuICAgIGlzU2VsZWN0ZWQ6IChlKSA9PiBlLnR5cGUgPT09IFwibnVtYmVyZWRMaXN0SXRlbVwiXG4gIH1cbl0sIG9uID0gKGUpID0+IHtcbiAgY29uc3QgbiA9IEcoZS5lZGl0b3IpLCBbbywgaV0gPSB4KFxuICAgIGUuZWRpdG9yLmdldFRleHRDdXJzb3JQb3NpdGlvbigpLmJsb2NrXG4gICksIHMgPSBSKCgpID0+IChlLml0ZW1zIHx8IG5uKS5maWx0ZXIoKGcpID0+IHtcbiAgICBpZiAoIShnLnR5cGUgaW4gZS5lZGl0b3Iuc2NoZW1hKSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBmb3IgKGNvbnN0IFthLCB5XSBvZiBPYmplY3QuZW50cmllcyhnLnByb3BzIHx8IHt9KSkge1xuICAgICAgY29uc3QgaCA9IGUuZWRpdG9yLnNjaGVtYVtnLnR5cGVdLnByb3BTY2hlbWE7XG4gICAgICBpZiAoIShhIGluIGgpIHx8IGhbYV0udmFsdWVzICE9PSB2b2lkIDAgJiYgIWhbYV0udmFsdWVzLmluY2x1ZGVzKHkpKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgfVxuICAgIHJldHVybiAhMDtcbiAgfSksIFtlLmVkaXRvciwgZS5pdGVtc10pLCBjID0gUihcbiAgICAoKSA9PiBzLmZpbmQoKGcpID0+IGcudHlwZSA9PT0gby50eXBlKSAhPT0gdm9pZCAwLFxuICAgIFtvLnR5cGUsIHNdXG4gICksIHUgPSBSKCgpID0+IHtcbiAgICBjb25zdCBnID0gKGEpID0+IHtcbiAgICAgIGUuZWRpdG9yLmZvY3VzKCk7XG4gICAgICBmb3IgKGNvbnN0IHkgb2YgbilcbiAgICAgICAgZS5lZGl0b3IudXBkYXRlQmxvY2soeSwge1xuICAgICAgICAgIHR5cGU6IGEudHlwZSxcbiAgICAgICAgICBwcm9wczogYS5wcm9wc1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBzLm1hcCgoYSkgPT4gKHtcbiAgICAgIHRleHQ6IGEubmFtZSxcbiAgICAgIGljb246IGEuaWNvbixcbiAgICAgIG9uQ2xpY2s6ICgpID0+IGcoYSksXG4gICAgICBpc1NlbGVjdGVkOiBhLmlzU2VsZWN0ZWQobylcbiAgICB9KSk7XG4gIH0sIFtvLCBzLCBlLmVkaXRvciwgbl0pO1xuICByZXR1cm4gcShlLmVkaXRvciwgKCkgPT4ge1xuICAgIGkoZS5lZGl0b3IuZ2V0VGV4dEN1cnNvclBvc2l0aW9uKCkuYmxvY2spO1xuICB9KSwgYyA/IC8qIEBfX1BVUkVfXyAqLyByLmpzeChlbiwgeyBpdGVtczogdSB9KSA6IG51bGw7XG59LCBhbiA9IChlKSA9PiB7XG4gIGNvbnN0IHsgY2xhc3NlczogbiB9ID0gJCh7IHJvb3Q6IHt9IH0pKHZvaWQgMCwge1xuICAgIG5hbWU6IFwiVG9vbHRpcFwiXG4gIH0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIHIuanN4cyhCZSwgeyBzcGFjaW5nOiAwLCBjbGFzc05hbWU6IG4ucm9vdCwgY2hpbGRyZW46IFtcbiAgICAvKiBAX19QVVJFX18gKi8gci5qc3gob2UsIHsgc2l6ZTogXCJzbVwiLCBjaGlsZHJlbjogZS5tYWluVG9vbHRpcCB9KSxcbiAgICBlLnNlY29uZGFyeVRvb2x0aXAgJiYgLyogQF9fUFVSRV9fICovIHIuanN4KG9lLCB7IHNpemU6IFwieHNcIiwgY2hpbGRyZW46IGUuc2Vjb25kYXJ5VG9vbHRpcCB9KVxuICBdIH0pO1xufSwgUCA9IGFlKFxuICAoZSwgbikgPT4ge1xuICAgIGNvbnN0IG8gPSBlLmljb247XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyByLmpzeChcbiAgICAgIFksXG4gICAgICB7XG4gICAgICAgIGNvbnRlbnQ6IC8qIEBfX1BVUkVfXyAqLyByLmpzeChcbiAgICAgICAgICBhbixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtYWluVG9vbHRpcDogZS5tYWluVG9vbHRpcCxcbiAgICAgICAgICAgIHNlY29uZGFyeVRvb2x0aXA6IGUuc2Vjb25kYXJ5VG9vbHRpcFxuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgdHJpZ2dlcjogXCJtb3VzZWVudGVyXCIsXG4gICAgICAgIGNoaWxkcmVuOiBlLmNoaWxkcmVuID8gLyogQF9fUFVSRV9fICovIHIuanN4cyhcbiAgICAgICAgICBJZSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBvbkNsaWNrOiBlLm9uQ2xpY2ssXG4gICAgICAgICAgICBcImRhdGEtc2VsZWN0ZWRcIjogZS5pc1NlbGVjdGVkID8gXCJ0cnVlXCIgOiB2b2lkIDAsXG4gICAgICAgICAgICBcImRhdGEtdGVzdFwiOiBlLm1haW5Ub29sdGlwLnNsaWNlKDAsIDEpLnRvTG93ZXJDYXNlKCkgKyBlLm1haW5Ub29sdGlwLnJlcGxhY2UoL1xccysvZywgXCJcIikuc2xpY2UoMSksXG4gICAgICAgICAgICBzaXplOiBcInhzXCIsXG4gICAgICAgICAgICBkaXNhYmxlZDogZS5pc0Rpc2FibGVkIHx8ICExLFxuICAgICAgICAgICAgcmVmOiBuLFxuICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgbyAmJiAvKiBAX19QVVJFX18gKi8gci5qc3gobywge30pLFxuICAgICAgICAgICAgICBlLmNoaWxkcmVuXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgICAgICApIDogLyogQF9fUFVSRV9fICovIHIuanN4KFxuICAgICAgICAgIGd0LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG9uQ2xpY2s6IGUub25DbGljayxcbiAgICAgICAgICAgIFwiZGF0YS1zZWxlY3RlZFwiOiBlLmlzU2VsZWN0ZWQgPyBcInRydWVcIiA6IHZvaWQgMCxcbiAgICAgICAgICAgIFwiZGF0YS10ZXN0XCI6IGUubWFpblRvb2x0aXAuc2xpY2UoMCwgMSkudG9Mb3dlckNhc2UoKSArIGUubWFpblRvb2x0aXAucmVwbGFjZSgvXFxzKy9nLCBcIlwiKS5zbGljZSgxKSxcbiAgICAgICAgICAgIHNpemU6IDMwLFxuICAgICAgICAgICAgZGlzYWJsZWQ6IGUuaXNEaXNhYmxlZCB8fCAhMSxcbiAgICAgICAgICAgIHJlZjogbixcbiAgICAgICAgICAgIGNoaWxkcmVuOiBvICYmIC8qIEBfX1BVUkVfXyAqLyByLmpzeChvLCB7fSlcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIH1cbiAgICApO1xuICB9XG4pLCBsbiA9ICgpID0+IHR5cGVvZiBuYXZpZ2F0b3IgPCBcInVcIiAmJiAoL01hYy8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pIHx8IC9BcHBsZVdlYktpdC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAvTW9iaWxlXFwvXFx3Ky8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSk7XG5mdW5jdGlvbiBBKGUpIHtcbiAgcmV0dXJuIGxuKCkgPyBlLnJlcGxhY2UoXCJNb2RcIiwgXCLijJhcIikgOiBlLnJlcGxhY2UoXCJNb2RcIiwgXCJDdHJsXCIpO1xufVxuY29uc3QgY24gPSB7XG4gIGJvbGQ6IFwiTW9kK0JcIixcbiAgaXRhbGljOiBcIk1vZCtJXCIsXG4gIHVuZGVybGluZTogXCJNb2QrVVwiLFxuICBzdHJpa2U6IFwiTW9kK1NoaWZ0K1hcIixcbiAgY29kZTogXCJcIlxufSwgc24gPSB7XG4gIGJvbGQ6IExyLFxuICBpdGFsaWM6IE5yLFxuICB1bmRlcmxpbmU6IFlyLFxuICBzdHJpa2U6IFdyLFxuICBjb2RlOiBEclxufSwgaGUgPSAoZSkgPT4ge1xuICBjb25zdCBuID0gRyhlLmVkaXRvciksIFtvLCBpXSA9IHgoXG4gICAgZS50b2dnbGVkU3R5bGUgaW4gZS5lZGl0b3IuZ2V0QWN0aXZlU3R5bGVzKClcbiAgKTtcbiAgcShlLmVkaXRvciwgKCkgPT4ge1xuICAgIGkoZS50b2dnbGVkU3R5bGUgaW4gZS5lZGl0b3IuZ2V0QWN0aXZlU3R5bGVzKCkpO1xuICB9KTtcbiAgY29uc3QgcyA9ICh1KSA9PiB7XG4gICAgZS5lZGl0b3IuZm9jdXMoKSwgZS5lZGl0b3IudG9nZ2xlU3R5bGVzKHsgW3VdOiAhMCB9KTtcbiAgfTtcbiAgcmV0dXJuIFIoKCkgPT4gISFuLmZpbmQoKHUpID0+IHUuY29udGVudCAhPT0gdm9pZCAwKSwgW25dKSA/IC8qIEBfX1BVUkVfXyAqLyByLmpzeChcbiAgICBQLFxuICAgIHtcbiAgICAgIG9uQ2xpY2s6ICgpID0+IHMoZS50b2dnbGVkU3R5bGUpLFxuICAgICAgaXNTZWxlY3RlZDogbyxcbiAgICAgIG1haW5Ub29sdGlwOiBlLnRvZ2dsZWRTdHlsZS5zbGljZSgwLCAxKS50b1VwcGVyQ2FzZSgpICsgZS50b2dnbGVkU3R5bGUuc2xpY2UoMSksXG4gICAgICBzZWNvbmRhcnlUb29sdGlwOiBBKGNuW2UudG9nZ2xlZFN0eWxlXSksXG4gICAgICBpY29uOiBzbltlLnRvZ2dsZWRTdHlsZV1cbiAgICB9XG4gICkgOiBudWxsO1xufSwgZG4gPSB7XG4gIGxlZnQ6IEZyLFxuICBjZW50ZXI6IFByLFxuICByaWdodDogQXIsXG4gIGp1c3RpZnk6IE9yXG59LCBTZSA9IChlKSA9PiB7XG4gIGNvbnN0IG4gPSBHKGUuZWRpdG9yKSwgbyA9IFIoKCkgPT4ge1xuICAgIGNvbnN0IGMgPSBuWzBdO1xuICAgIGlmIChcInRleHRBbGlnbm1lbnRcIiBpbiBjLnByb3BzKVxuICAgICAgcmV0dXJuIGMucHJvcHMudGV4dEFsaWdubWVudDtcbiAgfSwgW25dKSwgaSA9IHooXG4gICAgKGMpID0+IHtcbiAgICAgIGUuZWRpdG9yLmZvY3VzKCk7XG4gICAgICBmb3IgKGNvbnN0IHUgb2YgbilcbiAgICAgICAgZS5lZGl0b3IudXBkYXRlQmxvY2sodSwge1xuICAgICAgICAgIHByb3BzOiB7IHRleHRBbGlnbm1lbnQ6IGMgfVxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIFtlLmVkaXRvciwgbl1cbiAgKTtcbiAgcmV0dXJuIFIoKCkgPT4gISFuLmZpbmQoKGMpID0+IFwidGV4dEFsaWdubWVudFwiIGluIGMucHJvcHMpLCBbbl0pID8gLyogQF9fUFVSRV9fICovIHIuanN4KFxuICAgIFAsXG4gICAge1xuICAgICAgb25DbGljazogKCkgPT4gaShlLnRleHRBbGlnbm1lbnQpLFxuICAgICAgaXNTZWxlY3RlZDogbyA9PT0gZS50ZXh0QWxpZ25tZW50LFxuICAgICAgbWFpblRvb2x0aXA6IGUudGV4dEFsaWdubWVudCA9PT0gXCJqdXN0aWZ5XCIgPyBcIkp1c3RpZnkgVGV4dFwiIDogXCJBbGlnbiBUZXh0IFwiICsgZS50ZXh0QWxpZ25tZW50LnNsaWNlKDAsIDEpLnRvVXBwZXJDYXNlKCkgKyBlLnRleHRBbGlnbm1lbnQuc2xpY2UoMSksXG4gICAgICBpY29uOiBkbltlLnRleHRBbGlnbm1lbnRdXG4gICAgfVxuICApIDogbnVsbDtcbn0sIEVlID0gKGUpID0+IHtcbiAgY29uc3QgeyBjbGFzc2VzOiBuIH0gPSAkKHsgcm9vdDoge30gfSkodm9pZCAwLCB7XG4gICAgbmFtZTogXCJDb2xvckljb25cIlxuICB9KSwgbyA9IGUudGV4dENvbG9yIHx8IFwiZGVmYXVsdFwiLCBpID0gZS5iYWNrZ3JvdW5kQ29sb3IgfHwgXCJkZWZhdWx0XCIsIHMgPSBlLnNpemUgfHwgMTY7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gci5qc3goXG4gICAgZnQsXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiBuLnJvb3QsXG4gICAgICBzeDogKGMpID0+ICh7XG4gICAgICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGMub3RoZXIuYmFja2dyb3VuZENvbG9yc1tpXSxcbiAgICAgICAgY29sb3I6IGMub3RoZXIudGV4dENvbG9yc1tvXSxcbiAgICAgICAgZm9udFNpemU6IChzICogMC43NSkudG9TdHJpbmcoKSArIFwicHhcIixcbiAgICAgICAgaGVpZ2h0OiBzLnRvU3RyaW5nKCkgKyBcInB4XCIsXG4gICAgICAgIGxpbmVIZWlnaHQ6IHMudG9TdHJpbmcoKSArIFwicHhcIixcbiAgICAgICAgdGV4dEFsaWduOiBcImNlbnRlclwiLFxuICAgICAgICB3aWR0aDogcy50b1N0cmluZygpICsgXCJweFwiXG4gICAgICB9KSxcbiAgICAgIGNoaWxkcmVuOiBcIkFcIlxuICAgIH1cbiAgKTtcbn0sIHd0ID0gKGUpID0+IHtcbiAgY29uc3QgbiA9ICgpID0+IGUudGV4dCA/IC8qIEBfX1BVUkVfXyAqLyByLmpzeHMoci5GcmFnbWVudCwgeyBjaGlsZHJlbjogW1xuICAgIC8qIEBfX1BVUkVfXyAqLyByLmpzeCh3LkxhYmVsLCB7IGNoaWxkcmVuOiBcIlRleHRcIiB9KSxcbiAgICBbXG4gICAgICBcImRlZmF1bHRcIixcbiAgICAgIFwiZ3JheVwiLFxuICAgICAgXCJicm93blwiLFxuICAgICAgXCJyZWRcIixcbiAgICAgIFwib3JhbmdlXCIsXG4gICAgICBcInllbGxvd1wiLFxuICAgICAgXCJncmVlblwiLFxuICAgICAgXCJibHVlXCIsXG4gICAgICBcInB1cnBsZVwiLFxuICAgICAgXCJwaW5rXCJcbiAgICBdLm1hcCgoaSkgPT4gLyogQF9fUFVSRV9fICovIHIuanN4KFxuICAgICAgdy5JdGVtLFxuICAgICAge1xuICAgICAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgZS5vbkNsaWNrICYmIGUub25DbGljaygpLCBlLnRleHQuc2V0Q29sb3IoaSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBvbmVudDogXCJkaXZcIixcbiAgICAgICAgXCJkYXRhLXRlc3RcIjogXCJ0ZXh0LWNvbG9yLVwiICsgaSxcbiAgICAgICAgaWNvbjogLyogQF9fUFVSRV9fICovIHIuanN4KEVlLCB7IHRleHRDb2xvcjogaSwgc2l6ZTogZS5pY29uU2l6ZSB9KSxcbiAgICAgICAgcmlnaHRTZWN0aW9uOiBlLnRleHQuY29sb3IgPT09IGkgPyAvKiBAX19QVVJFX18gKi8gci5qc3goUmUsIHsgc2l6ZTogMTYsIHN0eWxlOiB7IHBhZGRpbmdMZWZ0OiBcIjhweFwiIH0gfSkgOiAvKiBAX19QVVJFX18gKi8gci5qc3goXCJkaXZcIiwgeyBzdHlsZTogeyB3aWR0aDogXCIyNHB4XCIsIHBhZGRpbmc6IFwiMFwiIH0gfSksXG4gICAgICAgIGNoaWxkcmVuOiBpLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgaS5zbGljZSgxKVxuICAgICAgfSxcbiAgICAgIFwidGV4dC1jb2xvci1cIiArIGlcbiAgICApKVxuICBdIH0pIDogbnVsbCwgbyA9ICgpID0+IGUuYmFja2dyb3VuZCA/IC8qIEBfX1BVUkVfXyAqLyByLmpzeHMoci5GcmFnbWVudCwgeyBjaGlsZHJlbjogW1xuICAgIC8qIEBfX1BVUkVfXyAqLyByLmpzeCh3LkxhYmVsLCB7IGNoaWxkcmVuOiBcIkJhY2tncm91bmRcIiB9KSxcbiAgICBbXG4gICAgICBcImRlZmF1bHRcIixcbiAgICAgIFwiZ3JheVwiLFxuICAgICAgXCJicm93blwiLFxuICAgICAgXCJyZWRcIixcbiAgICAgIFwib3JhbmdlXCIsXG4gICAgICBcInllbGxvd1wiLFxuICAgICAgXCJncmVlblwiLFxuICAgICAgXCJibHVlXCIsXG4gICAgICBcInB1cnBsZVwiLFxuICAgICAgXCJwaW5rXCJcbiAgICBdLm1hcCgoaSkgPT4gLyogQF9fUFVSRV9fICovIHIuanN4KFxuICAgICAgdy5JdGVtLFxuICAgICAge1xuICAgICAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgZS5vbkNsaWNrICYmIGUub25DbGljaygpLCBlLmJhY2tncm91bmQuc2V0Q29sb3IoaSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBvbmVudDogXCJkaXZcIixcbiAgICAgICAgXCJkYXRhLXRlc3RcIjogXCJiYWNrZ3JvdW5kLWNvbG9yLVwiICsgaSxcbiAgICAgICAgaWNvbjogLyogQF9fUFVSRV9fICovIHIuanN4KEVlLCB7IGJhY2tncm91bmRDb2xvcjogaSwgc2l6ZTogZS5pY29uU2l6ZSB9KSxcbiAgICAgICAgcmlnaHRTZWN0aW9uOiBlLmJhY2tncm91bmQuY29sb3IgPT09IGkgPyAvKiBAX19QVVJFX18gKi8gci5qc3goUmUsIHsgc2l6ZTogMTYsIHN0eWxlOiB7IHBhZGRpbmdMZWZ0OiBcIjhweFwiIH0gfSkgOiAvKiBAX19QVVJFX18gKi8gci5qc3goXCJkaXZcIiwgeyBzdHlsZTogeyB3aWR0aDogXCIyNHB4XCIsIHBhZGRpbmc6IFwiMFwiIH0gfSksXG4gICAgICAgIGNoaWxkcmVuOiBpLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgaS5zbGljZSgxKVxuICAgICAgfSxcbiAgICAgIFwiYmFja2dyb3VuZC1jb2xvci1cIiArIGlcbiAgICApKVxuICBdIH0pIDogbnVsbDtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyByLmpzeHMoci5GcmFnbWVudCwgeyBjaGlsZHJlbjogW1xuICAgIC8qIEBfX1BVUkVfXyAqLyByLmpzeChuLCB7fSksXG4gICAgLyogQF9fUFVSRV9fICovIHIuanN4KG8sIHt9KVxuICBdIH0pO1xufSwgdW4gPSAoZSkgPT4ge1xuICBjb25zdCBuID0gRyhlLmVkaXRvciksIFtvLCBpXSA9IHgoXG4gICAgZS5lZGl0b3IuZ2V0QWN0aXZlU3R5bGVzKCkudGV4dENvbG9yIHx8IFwiZGVmYXVsdFwiXG4gICksIFtzLCBjXSA9IHgoXG4gICAgZS5lZGl0b3IuZ2V0QWN0aXZlU3R5bGVzKCkuYmFja2dyb3VuZENvbG9yIHx8IFwiZGVmYXVsdFwiXG4gICk7XG4gIHEoZS5lZGl0b3IsICgpID0+IHtcbiAgICBpKGUuZWRpdG9yLmdldEFjdGl2ZVN0eWxlcygpLnRleHRDb2xvciB8fCBcImRlZmF1bHRcIiksIGMoXG4gICAgICBlLmVkaXRvci5nZXRBY3RpdmVTdHlsZXMoKS5iYWNrZ3JvdW5kQ29sb3IgfHwgXCJkZWZhdWx0XCJcbiAgICApO1xuICB9KTtcbiAgY29uc3QgeyByZWY6IHUsIHVwZGF0ZU1heEhlaWdodDogZyB9ID0geGUoKSwgYSA9IHooXG4gICAgKHApID0+IHtcbiAgICAgIGUuZWRpdG9yLmZvY3VzKCksIHAgPT09IFwiZGVmYXVsdFwiID8gZS5lZGl0b3IucmVtb3ZlU3R5bGVzKHsgdGV4dENvbG9yOiBwIH0pIDogZS5lZGl0b3IuYWRkU3R5bGVzKHsgdGV4dENvbG9yOiBwIH0pO1xuICAgIH0sXG4gICAgW2UuZWRpdG9yXVxuICApLCB5ID0geihcbiAgICAocCkgPT4ge1xuICAgICAgZS5lZGl0b3IuZm9jdXMoKSwgcCA9PT0gXCJkZWZhdWx0XCIgPyBlLmVkaXRvci5yZW1vdmVTdHlsZXMoeyBiYWNrZ3JvdW5kQ29sb3I6IHAgfSkgOiBlLmVkaXRvci5hZGRTdHlsZXMoeyBiYWNrZ3JvdW5kQ29sb3I6IHAgfSk7XG4gICAgfSxcbiAgICBbZS5lZGl0b3JdXG4gICk7XG4gIHJldHVybiBSKCgpID0+IHtcbiAgICBmb3IgKGNvbnN0IHAgb2YgbilcbiAgICAgIGlmIChwLmNvbnRlbnQgIT09IHZvaWQgMClcbiAgICAgICAgcmV0dXJuICEwO1xuICAgIHJldHVybiAhMTtcbiAgfSwgW25dKSA/IC8qIEBfX1BVUkVfXyAqLyByLmpzeHModywgeyBvbk9wZW46IGcsIGNoaWxkcmVuOiBbXG4gICAgLyogQF9fUFVSRV9fICovIHIuanN4KHcuVGFyZ2V0LCB7IGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gci5qc3goXG4gICAgICBQLFxuICAgICAge1xuICAgICAgICBtYWluVG9vbHRpcDogXCJDb2xvcnNcIixcbiAgICAgICAgaWNvbjogKCkgPT4gLyogQF9fUFVSRV9fICovIHIuanN4KFxuICAgICAgICAgIEVlLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRleHRDb2xvcjogbyxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogcyxcbiAgICAgICAgICAgIHNpemU6IDIwXG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICB9XG4gICAgKSB9KSxcbiAgICAvKiBAX19QVVJFX18gKi8gci5qc3goXCJkaXZcIiwgeyByZWY6IHUsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gci5qc3gody5Ecm9wZG93biwgeyBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIHIuanN4KFxuICAgICAgd3QsXG4gICAgICB7XG4gICAgICAgIHRleHQ6IHtcbiAgICAgICAgICBjb2xvcjogbyxcbiAgICAgICAgICBzZXRDb2xvcjogYVxuICAgICAgICB9LFxuICAgICAgICBiYWNrZ3JvdW5kOiB7XG4gICAgICAgICAgY29sb3I6IHMsXG4gICAgICAgICAgc2V0Q29sb3I6IHlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICkgfSkgfSlcbiAgXSB9KSA6IG51bGw7XG59LCBnbiA9IChlKSA9PiB7XG4gIGNvbnN0IFtuLCBvXSA9IHgoKTtcbiAgcShlLmVkaXRvciwgKCkgPT4ge1xuICAgIG8oZS5lZGl0b3IuY2FuTmVzdEJsb2NrKCkpO1xuICB9KTtcbiAgY29uc3QgaSA9IHooKCkgPT4ge1xuICAgIGUuZWRpdG9yLmZvY3VzKCksIGUuZWRpdG9yLm5lc3RCbG9jaygpO1xuICB9LCBbZS5lZGl0b3JdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyByLmpzeChcbiAgICBQLFxuICAgIHtcbiAgICAgIG9uQ2xpY2s6IGksXG4gICAgICBpc0Rpc2FibGVkOiAhbixcbiAgICAgIG1haW5Ub29sdGlwOiBcIk5lc3QgQmxvY2tcIixcbiAgICAgIHNlY29uZGFyeVRvb2x0aXA6IEEoXCJUYWJcIiksXG4gICAgICBpY29uOiBVclxuICAgIH1cbiAgKTtcbn0sIGZuID0gKGUpID0+IHtcbiAgY29uc3QgW24sIG9dID0geCgpO1xuICBxKGUuZWRpdG9yLCAoKSA9PiB7XG4gICAgbyhlLmVkaXRvci5jYW5Vbm5lc3RCbG9jaygpKTtcbiAgfSk7XG4gIGNvbnN0IGkgPSB6KCgpID0+IHtcbiAgICBlLmVkaXRvci5mb2N1cygpLCBlLmVkaXRvci51bm5lc3RCbG9jaygpO1xuICB9LCBbZV0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIHIuanN4KFxuICAgIFAsXG4gICAge1xuICAgICAgb25DbGljazogaSxcbiAgICAgIGlzRGlzYWJsZWQ6ICFuLFxuICAgICAgbWFpblRvb2x0aXA6IFwiVW5uZXN0IEJsb2NrXCIsXG4gICAgICBzZWNvbmRhcnlUb29sdGlwOiBBKFwiU2hpZnQrVGFiXCIpLFxuICAgICAgaWNvbjogVnJcbiAgICB9XG4gICk7XG59LCBTdCA9IChlKSA9PiB7XG4gIGNvbnN0IFtuLCBvXSA9IHgoITEpLCBpID0geigoKSA9PiB7XG4gICAgbyghMSk7XG4gIH0sIFtdKSwgcyA9IHooKCkgPT4ge1xuICAgIG8oITApO1xuICB9LCBbXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gci5qc3goXG4gICAgWSxcbiAgICB7XG4gICAgICBvblNob3c6IChjKSA9PiB7XG4gICAgICAgIHZhciB1O1xuICAgICAgICBzKCksICh1ID0gZS5vblNob3cpID09IG51bGwgfHwgdS5jYWxsKGUsIGMpO1xuICAgICAgfSxcbiAgICAgIG9uSGlkZGVuOiAoYykgPT4ge1xuICAgICAgICB2YXIgdTtcbiAgICAgICAgaSgpLCAodSA9IGUub25TaG93KSA9PSBudWxsIHx8IHUuY2FsbChlLCBjKTtcbiAgICAgIH0sXG4gICAgICBjb250ZW50OiBuID8gZS5jaGlsZHJlblsxXSA6IG51bGwsXG4gICAgICB0cmlnZ2VyOiBlLnZpc2libGUgPT09IHZvaWQgMCA/IFwiY2xpY2tcIiA6IHZvaWQgMCxcbiAgICAgIGludGVyYWN0aXZlOiAhMCxcbiAgICAgIG1heFdpZHRoOiA1MDAsXG4gICAgICB6SW5kZXg6IDllMyxcbiAgICAgIC4uLmUsXG4gICAgICBjaGlsZHJlbjogZS5jaGlsZHJlblswXVxuICAgIH1cbiAgKTtcbn0sIE10ID0gYWUoKHsgY2xhc3NOYW1lOiBlLCAuLi5uIH0sIG8pID0+IHtcbiAgY29uc3QgeyBjbGFzc2VzOiBpIH0gPSAkKHsgcm9vdDoge30gfSkodm9pZCAwLCB7XG4gICAgbmFtZTogXCJUb29sYmFySW5wdXREcm9wZG93blwiXG4gIH0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIHIuanN4KFxuICAgIEJlLFxuICAgIHtcbiAgICAgIC4uLm4sXG4gICAgICBjbGFzc05hbWU6IGJlKGkucm9vdCwgZSB8fCBcIlwiKSxcbiAgICAgIHJlZjogbyxcbiAgICAgIGNoaWxkcmVuOiBuLmNoaWxkcmVuXG4gICAgfVxuICApO1xufSksIGhuID0ge1xuICB0ZXh0OiBodCxcbiAgZmlsZTogdnRcbn0sIHplID0gKGUpID0+IHtcbiAgY29uc3QgbiA9IGUuaWNvbiwgbyA9IGhuW2UudHlwZV07XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gci5qc3goSGUsIHsgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyByLmpzeChvLCB7IHNpemU6IFwieHNcIiwgaWNvbjogLyogQF9fUFVSRV9fICovIHIuanN4KG4sIHt9KSwgLi4uZS5pbnB1dFByb3BzIH0pIH0pO1xufSwgUnQgPSBhZSgoeyB1cmw6IGUsIHRleHQ6IG4sIHVwZGF0ZTogbywgLi4uaSB9LCBzKSA9PiB7XG4gIGNvbnN0IFtjLCB1XSA9IHgoZSksIFtnLCBhXSA9IHgobik7XG4gIEIoKCkgPT4ge1xuICAgIHUoZSksIGEobik7XG4gIH0sIFtuLCBlXSk7XG4gIGNvbnN0IHkgPSB6KFxuICAgIChUKSA9PiB7XG4gICAgICBULmtleSA9PT0gXCJFbnRlclwiICYmIChULnByZXZlbnREZWZhdWx0KCksIG8oYywgZykpO1xuICAgIH0sXG4gICAgW28sIGMsIGddXG4gICksIGggPSB6KFxuICAgIChUKSA9PiB1KFQuY3VycmVudFRhcmdldC52YWx1ZSksXG4gICAgW11cbiAgKSwgcCA9IHooXG4gICAgKFQpID0+IGEoVC5jdXJyZW50VGFyZ2V0LnZhbHVlKSxcbiAgICBbXVxuICApLCBTID0geihcbiAgICAoKSA9PiBvKGMsIGcpLFxuICAgIFtvLCBjLCBnXVxuICApO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIHIuanN4cyhNdCwgeyAuLi5pLCByZWY6IHMsIGNoaWxkcmVuOiBbXG4gICAgLyogQF9fUFVSRV9fICovIHIuanN4KFxuICAgICAgemUsXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICBpY29uOiBDdCxcbiAgICAgICAgaW5wdXRQcm9wczoge1xuICAgICAgICAgIGF1dG9Gb2N1czogITAsXG4gICAgICAgICAgcGxhY2Vob2xkZXI6IFwiRWRpdCBVUkxcIixcbiAgICAgICAgICB2YWx1ZTogYyxcbiAgICAgICAgICBvbktleURvd246IHksXG4gICAgICAgICAgb25DaGFuZ2U6IGgsXG4gICAgICAgICAgb25TdWJtaXQ6IFNcbiAgICAgICAgfVxuICAgICAgfVxuICAgICksXG4gICAgLyogQF9fUFVSRV9fICovIHIuanN4KFxuICAgICAgemUsXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICBpY29uOiBpZSxcbiAgICAgICAgaW5wdXRQcm9wczoge1xuICAgICAgICAgIHBsYWNlaG9sZGVyOiBcIkVkaXQgVGl0bGVcIixcbiAgICAgICAgICB2YWx1ZTogZyxcbiAgICAgICAgICBvbktleURvd246IHksXG4gICAgICAgICAgb25DaGFuZ2U6IHAsXG4gICAgICAgICAgb25TdWJtaXQ6IFNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIClcbiAgXSB9KTtcbn0pLCB2biA9IChlKSA9PiB7XG4gIGNvbnN0IG4gPSBHKGUuZWRpdG9yKSwgW28sIGldID0geChcbiAgICBlLmVkaXRvci5nZXRTZWxlY3RlZExpbmtVcmwoKSB8fCBcIlwiXG4gICksIFtzLCBjXSA9IHgoZS5lZGl0b3IuZ2V0U2VsZWN0ZWRUZXh0KCkpO1xuICBxKGUuZWRpdG9yLCAoKSA9PiB7XG4gICAgYyhlLmVkaXRvci5nZXRTZWxlY3RlZFRleHQoKSB8fCBcIlwiKSwgaShlLmVkaXRvci5nZXRTZWxlY3RlZExpbmtVcmwoKSB8fCBcIlwiKTtcbiAgfSk7XG4gIGNvbnN0IHUgPSB6KFxuICAgIChhLCB5KSA9PiB7XG4gICAgICBlLmVkaXRvci5jcmVhdGVMaW5rKGEsIHkpLCBlLmVkaXRvci5mb2N1cygpO1xuICAgIH0sXG4gICAgW2UuZWRpdG9yXVxuICApO1xuICByZXR1cm4gUigoKSA9PiB7XG4gICAgZm9yIChjb25zdCBhIG9mIG4pXG4gICAgICBpZiAoYS5jb250ZW50ID09PSB2b2lkIDApXG4gICAgICAgIHJldHVybiAhMTtcbiAgICByZXR1cm4gITA7XG4gIH0sIFtuXSkgPyAvKiBAX19QVVJFX18gKi8gci5qc3hzKFN0LCB7IGNoaWxkcmVuOiBbXG4gICAgLyogQF9fUFVSRV9fICovIHIuanN4KFxuICAgICAgUCxcbiAgICAgIHtcbiAgICAgICAgbWFpblRvb2x0aXA6IFwiQ3JlYXRlIExpbmtcIixcbiAgICAgICAgc2Vjb25kYXJ5VG9vbHRpcDogQShcIk1vZCtLXCIpLFxuICAgICAgICBpY29uOiBDdFxuICAgICAgfVxuICAgICksXG4gICAgLyogQF9fUFVSRV9fICovIHIuanN4KFJ0LCB7IHVybDogbywgdGV4dDogcywgdXBkYXRlOiB1IH0pXG4gIF0gfSkgOiBudWxsO1xufSwgRXQgPSAoZSkgPT4ge1xuICBjb25zdCBbbiwgb10gPSB4KFxuICAgIGUuZWRpdG9yLnVwbG9hZEZpbGUgIT09IHZvaWQgMCA/IFwidXBsb2FkXCIgOiBcImVtYmVkXCJcbiAgKSwgW2ksIHNdID0geCghMSksIFtjLCB1XSA9IHgoITEpO1xuICBCKCgpID0+IHtcbiAgICBjICYmIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdSghMSk7XG4gICAgfSwgM2UzKTtcbiAgfSwgW2NdKTtcbiAgY29uc3QgZyA9IHooXG4gICAgYXN5bmMgKFQpID0+IHtcbiAgICAgIGlmIChzKCEwKSwgZS5lZGl0b3IudXBsb2FkRmlsZSAhPT0gdm9pZCAwKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IEQgPSBhd2FpdCBlLmVkaXRvci51cGxvYWRGaWxlKFQpO1xuICAgICAgICAgIGUuZWRpdG9yLnVwZGF0ZUJsb2NrKGUuYmxvY2ssIHtcbiAgICAgICAgICAgIHR5cGU6IFwiaW1hZ2VcIixcbiAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgIHVybDogRFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICB1KCEwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBzKCExKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgW2UuYmxvY2ssIGUuZWRpdG9yXVxuICApLCBbYSwgeV0gPSB4KFwiXCIpLCBoID0geihcbiAgICAoVCkgPT4ge1xuICAgICAgeShULmN1cnJlbnRUYXJnZXQudmFsdWUpO1xuICAgIH0sXG4gICAgW11cbiAgKSwgcCA9IHooXG4gICAgKFQpID0+IHtcbiAgICAgIFQua2V5ID09PSBcIkVudGVyXCIgJiYgKFQucHJldmVudERlZmF1bHQoKSwgZS5lZGl0b3IudXBkYXRlQmxvY2soZS5ibG9jaywge1xuICAgICAgICB0eXBlOiBcImltYWdlXCIsXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgdXJsOiBhXG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9LFxuICAgIFthLCBlLmJsb2NrLCBlLmVkaXRvcl1cbiAgKSwgUyA9IHooKCkgPT4ge1xuICAgIGUuZWRpdG9yLnVwZGF0ZUJsb2NrKGUuYmxvY2ssIHtcbiAgICAgIHR5cGU6IFwiaW1hZ2VcIixcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIHVybDogYVxuICAgICAgfVxuICAgIH0pO1xuICB9LCBbYSwgZS5ibG9jaywgZS5lZGl0b3JdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyByLmpzeChcbiAgICBfZSxcbiAgICB7XG4gICAgICBzdHlsZToge1xuICAgICAgICB3aWR0aDogXCI1MDBweFwiXG4gICAgICB9LFxuICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyByLmpzeHMoUSwgeyB2YWx1ZTogbiwgb25UYWJDaGFuZ2U6IG8sIGNoaWxkcmVuOiBbXG4gICAgICAgIGkgJiYgLyogQF9fUFVSRV9fICovIHIuanN4KENyLCB7IHZpc2libGU6IGkgfSksXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyByLmpzeHMoUS5MaXN0LCB7IGNoaWxkcmVuOiBbXG4gICAgICAgICAgZS5lZGl0b3IudXBsb2FkRmlsZSAhPT0gdm9pZCAwICYmIC8qIEBfX1BVUkVfXyAqLyByLmpzeChRLlRhYiwgeyB2YWx1ZTogXCJ1cGxvYWRcIiwgXCJkYXRhLXRlc3RcIjogXCJ1cGxvYWQtdGFiXCIsIGNoaWxkcmVuOiBcIlVwbG9hZFwiIH0pLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyByLmpzeChRLlRhYiwgeyB2YWx1ZTogXCJlbWJlZFwiLCBcImRhdGEtdGVzdFwiOiBcImVtYmVkLXRhYlwiLCBjaGlsZHJlbjogXCJFbWJlZFwiIH0pXG4gICAgICAgIF0gfSksXG4gICAgICAgIGUuZWRpdG9yLnVwbG9hZEZpbGUgIT09IHZvaWQgMCAmJiAvKiBAX19QVVJFX18gKi8gci5qc3goUS5QYW5lbCwgeyB2YWx1ZTogXCJ1cGxvYWRcIiwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyByLmpzeHMoXG4gICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICAgICAgICAgICAgZmxleERpcmVjdGlvbjogXCJjb2x1bW5cIixcbiAgICAgICAgICAgICAgYWxpZ25JdGVtczogXCJzdHJldGNoXCIsXG4gICAgICAgICAgICAgIGdhcDogXCI4cHhcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyByLmpzeChcbiAgICAgICAgICAgICAgICB2dCxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogXCJVcGxvYWQgSW1hZ2VcIixcbiAgICAgICAgICAgICAgICAgIHNpemU6IFwieHNcIixcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgb25DaGFuZ2U6IGcsXG4gICAgICAgICAgICAgICAgICBcImRhdGEtdGVzdFwiOiBcInVwbG9hZC1pbnB1dFwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBjICYmIC8qIEBfX1BVUkVfXyAqLyByLmpzeChvZSwgeyBjb2xvcjogXCJyZWRcIiwgc2l6ZTogMTIsIHN0eWxlOiB7IHRleHRBbGlnbjogXCJjZW50ZXJcIiB9LCBjaGlsZHJlbjogXCJFcnJvcjogVXBsb2FkIGZhaWxlZFwiIH0pXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgICAgICApIH0pLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8gci5qc3goUS5QYW5lbCwgeyB2YWx1ZTogXCJlbWJlZFwiLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIHIuanN4cyhcbiAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgIHdpZHRoOiBcIjEwMCVcIixcbiAgICAgICAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICAgICAgICAgIGZsZXhEaXJlY3Rpb246IFwiY29sdW1uXCIsXG4gICAgICAgICAgICAgIGFsaWduSXRlbXM6IFwiY2VudGVyXCIsXG4gICAgICAgICAgICAgIGdhcDogXCI4cHhcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyByLmpzeChcbiAgICAgICAgICAgICAgICBodCxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBzaXplOiBcInhzXCIsXG4gICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogXCJFbnRlciBVUkxcIixcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBhLFxuICAgICAgICAgICAgICAgICAgb25DaGFuZ2U6IGgsXG4gICAgICAgICAgICAgICAgICBvbktleURvd246IHAsXG4gICAgICAgICAgICAgICAgICBzdHlsZTogeyB3aWR0aDogXCIxMDAlXCIgfSxcbiAgICAgICAgICAgICAgICAgIFwiZGF0YS10ZXN0XCI6IFwiZW1iZWQtaW5wdXRcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIHIuanN4KFxuICAgICAgICAgICAgICAgIEllLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6IFMsXG4gICAgICAgICAgICAgICAgICBzaXplOiBcInhzXCIsXG4gICAgICAgICAgICAgICAgICBcImRhdGEtdGVzdFwiOiBcImVtYmVkLWlucHV0LWJ1dHRvblwiLFxuICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiRW1iZWQgSW1hZ2VcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH1cbiAgICAgICAgKSB9KVxuICAgICAgXSB9KVxuICAgIH1cbiAgKTtcbn0sIGJuID0gKGUpID0+IHtcbiAgY29uc3QgbiA9IEcoZS5lZGl0b3IpLCBbbywgaV0gPSB4KCExKTtcbiAgcmV0dXJuIEIoKCkgPT4ge1xuICAgIGkoITEpO1xuICB9LCBbbl0pLCAvLyBDaGVja3MgaWYgb25seSBvbmUgYmxvY2sgaXMgc2VsZWN0ZWQuXG4gIG4ubGVuZ3RoID09PSAxICYmIC8vIENoZWNrcyBpZiB0aGUgc2VsZWN0ZWQgYmxvY2sgaXMgYW4gaW1hZ2UuXG4gIG5bMF0udHlwZSA9PT0gXCJpbWFnZVwiID8gLyogQF9fUFVSRV9fICovIHIuanN4KFxuICAgIFksXG4gICAge1xuICAgICAgdmlzaWJsZTogbyxcbiAgICAgIGludGVyYWN0aXZlOiAhMCxcbiAgICAgIGNvbnRlbnQ6IC8qIEBfX1BVUkVfXyAqLyByLmpzeChcbiAgICAgICAgRXQsXG4gICAgICAgIHtcbiAgICAgICAgICBibG9jazogblswXSxcbiAgICAgICAgICBlZGl0b3I6IGUuZWRpdG9yXG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIHIuanN4KFxuICAgICAgICBQLFxuICAgICAgICB7XG4gICAgICAgICAgb25DbGljazogKCkgPT4gaSghbyksXG4gICAgICAgICAgaXNTZWxlY3RlZDogbyxcbiAgICAgICAgICBtYWluVG9vbHRpcDogXCJSZXBsYWNlIEltYWdlXCIsXG4gICAgICAgICAgaWNvbjogS3JcbiAgICAgICAgfVxuICAgICAgKVxuICAgIH1cbiAgKSA6IG51bGw7XG59LCB4biA9IChlKSA9PiB7XG4gIGNvbnN0IG4gPSBHKGUuZWRpdG9yKSwgbyA9IFIoXG4gICAgKCkgPT4gKFxuICAgICAgLy8gQ2hlY2tzIGlmIG9ubHkgb25lIGJsb2NrIGlzIHNlbGVjdGVkLlxuICAgICAgbi5sZW5ndGggPT09IDEgJiYgLy8gQ2hlY2tzIGlmIHRoZSBzZWxlY3RlZCBibG9jayBpcyBhbiBpbWFnZS5cbiAgICAgIG5bMF0udHlwZSA9PT0gXCJpbWFnZVwiICYmIC8vIENoZWNrcyBpZiB0aGUgYmxvY2sgaGFzIGEgYGNhcHRpb25gIHByb3Agd2hpY2ggY2FuIHRha2UgYW55IHN0cmluZ1xuICAgICAgLy8gdmFsdWUuXG4gICAgICBcImNhcHRpb25cIiBpbiBlLmVkaXRvci5zY2hlbWEuaW1hZ2UucHJvcFNjaGVtYSAmJiB0eXBlb2YgZS5lZGl0b3Iuc2NoZW1hLmltYWdlLnByb3BTY2hlbWEuY2FwdGlvbi5kZWZhdWx0ID09IFwic3RyaW5nXCIgJiYgZS5lZGl0b3Iuc2NoZW1hLmltYWdlLnByb3BTY2hlbWEuY2FwdGlvbi52YWx1ZXMgPT09IHZvaWQgMCAmJiAvLyBDaGVja3MgaWYgdGhlIGJsb2NrIGhhcyBhIGBzcmNgIHByb3Agd2hpY2ggY2FuIHRha2UgYW55IHN0cmluZyB2YWx1ZS5cbiAgICAgIFwic3JjXCIgaW4gZS5lZGl0b3Iuc2NoZW1hLmltYWdlLnByb3BTY2hlbWEgJiYgdHlwZW9mIGUuZWRpdG9yLnNjaGVtYS5pbWFnZS5wcm9wU2NoZW1hLnNyYy5kZWZhdWx0ID09IFwic3RyaW5nXCIgJiYgZS5lZGl0b3Iuc2NoZW1hLmltYWdlLnByb3BTY2hlbWEuc3JjLnZhbHVlcyA9PT0gdm9pZCAwICYmIC8vIENoZWNrcyBpZiB0aGUgYHNyY2AgcHJvcCBpcyBub3Qgc2V0IHRvIGFuIGVtcHR5IHN0cmluZy5cbiAgICAgIG5bMF0ucHJvcHMuc3JjICE9PSBcIlwiXG4gICAgKSxcbiAgICBbZS5lZGl0b3Iuc2NoZW1hLCBuXVxuICApLCBbaSwgc10gPSB4KFxuICAgIG8gPyBuWzBdLnByb3BzLmNhcHRpb24gOiBcIlwiXG4gICk7XG4gIEIoXG4gICAgKCkgPT4gcyhcbiAgICAgIG8gPyBuWzBdLnByb3BzLmNhcHRpb24gOiBcIlwiXG4gICAgKSxcbiAgICBbbiwgb11cbiAgKTtcbiAgY29uc3QgYyA9IHooXG4gICAgKGcpID0+IHtcbiAgICAgIGcua2V5ID09PSBcIkVudGVyXCIgJiYgKGcucHJldmVudERlZmF1bHQoKSwgZS5lZGl0b3IudXBkYXRlQmxvY2soblswXSwge1xuICAgICAgICB0eXBlOiBcImltYWdlXCIsXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgY2FwdGlvbjogaVxuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfSxcbiAgICBbaSwgZS5lZGl0b3IsIG5dXG4gICksIHUgPSB6KFxuICAgIChnKSA9PiBzKGcuY3VycmVudFRhcmdldC52YWx1ZSksXG4gICAgW11cbiAgKTtcbiAgcmV0dXJuIG8gPyAvKiBAX19QVVJFX18gKi8gci5qc3hzKFN0LCB7IGNoaWxkcmVuOiBbXG4gICAgLyogQF9fUFVSRV9fICovIHIuanN4KFxuICAgICAgUCxcbiAgICAgIHtcbiAgICAgICAgbWFpblRvb2x0aXA6IFwiRWRpdCBDYXB0aW9uXCIsXG4gICAgICAgIGljb246IGllLFxuICAgICAgICBpc1NlbGVjdGVkOiBuWzBdLnByb3BzLmNhcHRpb24gIT09IFwiXCJcbiAgICAgIH1cbiAgICApLFxuICAgIC8qIEBfX1BVUkVfXyAqLyByLmpzeChNdCwgeyBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIHIuanN4KFxuICAgICAgemUsXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICBpY29uOiBpZSxcbiAgICAgICAgaW5wdXRQcm9wczoge1xuICAgICAgICAgIGF1dG9Gb2N1czogITAsXG4gICAgICAgICAgcGxhY2Vob2xkZXI6IFwiRWRpdCBDYXB0aW9uXCIsXG4gICAgICAgICAgdmFsdWU6IGksXG4gICAgICAgICAgb25LZXlEb3duOiBjLFxuICAgICAgICAgIG9uQ2hhbmdlOiB1XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApIH0pXG4gIF0gfSkgOiBudWxsO1xufSwgbW4gPSAoZSkgPT4gLyogQF9fUFVSRV9fICovIHIuanN4cyhfZSwgeyBjaGlsZHJlbjogW1xuICAvKiBAX19QVVJFX18gKi8gci5qc3gob24sIHsgLi4uZSwgaXRlbXM6IGUuYmxvY2tUeXBlRHJvcGRvd25JdGVtcyB9KSxcbiAgLyogQF9fUFVSRV9fICovIHIuanN4KHhuLCB7IGVkaXRvcjogZS5lZGl0b3IgfSksXG4gIC8qIEBfX1BVUkVfXyAqLyByLmpzeChibiwgeyBlZGl0b3I6IGUuZWRpdG9yIH0pLFxuICAvKiBAX19QVVJFX18gKi8gci5qc3goaGUsIHsgZWRpdG9yOiBlLmVkaXRvciwgdG9nZ2xlZFN0eWxlOiBcImJvbGRcIiB9KSxcbiAgLyogQF9fUFVSRV9fICovIHIuanN4KGhlLCB7IGVkaXRvcjogZS5lZGl0b3IsIHRvZ2dsZWRTdHlsZTogXCJpdGFsaWNcIiB9KSxcbiAgLyogQF9fUFVSRV9fICovIHIuanN4KGhlLCB7IGVkaXRvcjogZS5lZGl0b3IsIHRvZ2dsZWRTdHlsZTogXCJ1bmRlcmxpbmVcIiB9KSxcbiAgLyogQF9fUFVSRV9fICovIHIuanN4KGhlLCB7IGVkaXRvcjogZS5lZGl0b3IsIHRvZ2dsZWRTdHlsZTogXCJzdHJpa2VcIiB9KSxcbiAgLyogQF9fUFVSRV9fICovIHIuanN4KFNlLCB7IGVkaXRvcjogZS5lZGl0b3IsIHRleHRBbGlnbm1lbnQ6IFwibGVmdFwiIH0pLFxuICAvKiBAX19QVVJFX18gKi8gci5qc3goU2UsIHsgZWRpdG9yOiBlLmVkaXRvciwgdGV4dEFsaWdubWVudDogXCJjZW50ZXJcIiB9KSxcbiAgLyogQF9fUFVSRV9fICovIHIuanN4KFNlLCB7IGVkaXRvcjogZS5lZGl0b3IsIHRleHRBbGlnbm1lbnQ6IFwicmlnaHRcIiB9KSxcbiAgLyogQF9fUFVSRV9fICovIHIuanN4KHVuLCB7IGVkaXRvcjogZS5lZGl0b3IgfSksXG4gIC8qIEBfX1BVUkVfXyAqLyByLmpzeChnbiwgeyBlZGl0b3I6IGUuZWRpdG9yIH0pLFxuICAvKiBAX19QVVJFX18gKi8gci5qc3goZm4sIHsgZWRpdG9yOiBlLmVkaXRvciB9KSxcbiAgLyogQF9fUFVSRV9fICovIHIuanN4KHZuLCB7IGVkaXRvcjogZS5lZGl0b3IgfSlcbl0gfSksIHN0ID0gKGUpID0+IHtcbiAgc3dpdGNoIChlKSB7XG4gICAgY2FzZSBcImxlZnRcIjpcbiAgICAgIHJldHVybiBcInRvcC1zdGFydFwiO1xuICAgIGNhc2UgXCJjZW50ZXJcIjpcbiAgICAgIHJldHVybiBcInRvcFwiO1xuICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgcmV0dXJuIFwidG9wLWVuZFwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gXCJ0b3Atc3RhcnRcIjtcbiAgfVxufSwga24gPSAoZSkgPT4ge1xuICBjb25zdCBbbiwgb10gPSB4KCExKSwgW2ksIHNdID0geChcbiAgICAoKSA9PiB7XG4gICAgICBjb25zdCBhID0gZS5lZGl0b3IuZ2V0VGV4dEN1cnNvclBvc2l0aW9uKCkuYmxvY2s7XG4gICAgICByZXR1cm4gXCJ0ZXh0QWxpZ25tZW50XCIgaW4gYS5wcm9wcyA/IHN0KFxuICAgICAgICBhLnByb3BzLnRleHRBbGlnbm1lbnRcbiAgICAgICkgOiBcInRvcC1zdGFydFwiO1xuICAgIH1cbiAgKSwgYyA9IEwoKTtcbiAgQigoKSA9PiAoYnQuc2V0RGVmYXVsdFByb3BzKHsgbWF4V2lkdGg6IFwiXCIgfSksIGUuZWRpdG9yLmZvcm1hdHRpbmdUb29sYmFyLm9uVXBkYXRlKChhKSA9PiB7XG4gICAgbyhhLnNob3cpLCBjLmN1cnJlbnQgPSBhLnJlZmVyZW5jZVBvcztcbiAgfSkpLCBbZS5lZGl0b3JdKSwgcShlLmVkaXRvciwgKCkgPT4ge1xuICAgIGNvbnN0IGEgPSBlLmVkaXRvci5nZXRUZXh0Q3Vyc29yUG9zaXRpb24oKS5ibG9jaztcbiAgICBcInRleHRBbGlnbm1lbnRcIiBpbiBhLnByb3BzID8gcyhcbiAgICAgIHN0KFxuICAgICAgICBhLnByb3BzLnRleHRBbGlnbm1lbnRcbiAgICAgIClcbiAgICApIDogcyhcInRvcC1zdGFydFwiKTtcbiAgfSk7XG4gIGNvbnN0IHUgPSBSKFxuICAgICgpID0+IHtcbiAgICAgIGlmIChjKVxuICAgICAgICByZXR1cm4gKCkgPT4gYy5jdXJyZW50O1xuICAgIH0sXG4gICAgW2MuY3VycmVudF1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICksIGcgPSBSKCgpID0+IHtcbiAgICBjb25zdCBhID0gZS5mb3JtYXR0aW5nVG9vbGJhciB8fCBtbjtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIHIuanN4KGEsIHsgZWRpdG9yOiBlLmVkaXRvciB9KTtcbiAgfSwgW2UuZWRpdG9yLCBlLmZvcm1hdHRpbmdUb29sYmFyXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gci5qc3goXG4gICAgWSxcbiAgICB7XG4gICAgICBhcHBlbmRUbzogZS5lZGl0b3IuZG9tRWxlbWVudC5wYXJlbnRFbGVtZW50LFxuICAgICAgY29udGVudDogZyxcbiAgICAgIGdldFJlZmVyZW5jZUNsaWVudFJlY3Q6IHUsXG4gICAgICBpbnRlcmFjdGl2ZTogITAsXG4gICAgICB2aXNpYmxlOiBuLFxuICAgICAgYW5pbWF0aW9uOiBcImZhZGVcIixcbiAgICAgIHBsYWNlbWVudDogaSxcbiAgICAgIHN0aWNreTogITAsXG4gICAgICBwbHVnaW5zOiB5bixcbiAgICAgIHpJbmRleDogM2UzXG4gICAgfVxuICApO1xufSwgeW4gPSBbenJdLCBwbiA9IChlKSA9PiB7XG4gIGNvbnN0IFtuLCBvXSA9IHgoITEpLCBpID0gTChudWxsKTtcbiAgcmV0dXJuIG4gPyAvKiBAX19QVVJFX18gKi8gci5qc3goXG4gICAgUnQsXG4gICAge1xuICAgICAgdXJsOiBlLnVybCxcbiAgICAgIHRleHQ6IGUudGV4dCxcbiAgICAgIHVwZGF0ZTogZS5lZGl0SHlwZXJsaW5rLFxuICAgICAgb25CbHVyOiAocykgPT4gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHZhciBjO1xuICAgICAgICAoYyA9IGkuY3VycmVudCkgIT0gbnVsbCAmJiBjLmNvbnRhaW5zKHMucmVsYXRlZFRhcmdldCkgfHwgbyghMSk7XG4gICAgICB9LCA1MDApLFxuICAgICAgcmVmOiBpXG4gICAgfVxuICApIDogLyogQF9fUFVSRV9fICovIHIuanN4cyhcbiAgICBfZSxcbiAgICB7XG4gICAgICBvbk1vdXNlRW50ZXI6IGUuc3RvcEhpZGVUaW1lcixcbiAgICAgIG9uTW91c2VMZWF2ZTogZS5zdGFydEhpZGVUaW1lcixcbiAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyByLmpzeChcbiAgICAgICAgICBQLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1haW5Ub29sdGlwOiBcIkVkaXRcIixcbiAgICAgICAgICAgIGlzU2VsZWN0ZWQ6ICExLFxuICAgICAgICAgICAgb25DbGljazogKCkgPT4gbyghMCksXG4gICAgICAgICAgICBjaGlsZHJlbjogXCJFZGl0IExpbmtcIlxuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgLyogQF9fUFVSRV9fICovIHIuanN4KFxuICAgICAgICAgIFAsXG4gICAgICAgICAge1xuICAgICAgICAgICAgbWFpblRvb2x0aXA6IFwiT3BlbiBpbiBuZXcgdGFiXCIsXG4gICAgICAgICAgICBpc1NlbGVjdGVkOiAhMSxcbiAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgd2luZG93Lm9wZW4oZS51cmwsIFwiX2JsYW5rXCIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGljb246IEdyXG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8gci5qc3goXG4gICAgICAgICAgUCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtYWluVG9vbHRpcDogXCJSZW1vdmUgbGlua1wiLFxuICAgICAgICAgICAgaXNTZWxlY3RlZDogITEsXG4gICAgICAgICAgICBvbkNsaWNrOiBlLmRlbGV0ZUh5cGVybGluayxcbiAgICAgICAgICAgIGljb246ICRyXG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICBdXG4gICAgfVxuICApO1xufSwgQ24gPSAoZSkgPT4ge1xuICBjb25zdCBbbiwgb10gPSB4KCExKSwgW2ksIHNdID0geCgpLCBbYywgdV0gPSB4KCksIGcgPSBMKCk7XG4gIEIoKCkgPT4gZS5lZGl0b3IuaHlwZXJsaW5rVG9vbGJhci5vbihcbiAgICBcInVwZGF0ZVwiLFxuICAgIChoKSA9PiB7XG4gICAgICBvKGguc2hvdyksIHMoaC51cmwpLCB1KGgudGV4dCksIGcuY3VycmVudCA9IGgucmVmZXJlbmNlUG9zO1xuICAgIH1cbiAgKSwgW2UuZWRpdG9yXSk7XG4gIGNvbnN0IGEgPSBSKFxuICAgICgpID0+IHtcbiAgICAgIGlmIChnLmN1cnJlbnQpXG4gICAgICAgIHJldHVybiAoKSA9PiBnLmN1cnJlbnQ7XG4gICAgfSxcbiAgICBbZy5jdXJyZW50XVxuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgKSwgeSA9IFIoKCkgPT4ge1xuICAgIGlmICghaSB8fCAhYylcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGggPSBlLmh5cGVybGlua1Rvb2xiYXIgfHwgcG47XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyByLmpzeChcbiAgICAgIGgsXG4gICAgICB7XG4gICAgICAgIHVybDogaSxcbiAgICAgICAgdGV4dDogYyxcbiAgICAgICAgZWRpdEh5cGVybGluazogZS5lZGl0b3IuaHlwZXJsaW5rVG9vbGJhci5lZGl0SHlwZXJsaW5rLFxuICAgICAgICBkZWxldGVIeXBlcmxpbms6IGUuZWRpdG9yLmh5cGVybGlua1Rvb2xiYXIuZGVsZXRlSHlwZXJsaW5rLFxuICAgICAgICBzdGFydEhpZGVUaW1lcjogZS5lZGl0b3IuaHlwZXJsaW5rVG9vbGJhci5zdGFydEhpZGVUaW1lcixcbiAgICAgICAgc3RvcEhpZGVUaW1lcjogZS5lZGl0b3IuaHlwZXJsaW5rVG9vbGJhci5zdG9wSGlkZVRpbWVyXG4gICAgICB9XG4gICAgKTtcbiAgfSwgW2UuaHlwZXJsaW5rVG9vbGJhciwgZS5lZGl0b3IsIGMsIGldKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyByLmpzeChcbiAgICBZLFxuICAgIHtcbiAgICAgIGFwcGVuZFRvOiBlLmVkaXRvci5kb21FbGVtZW50LnBhcmVudEVsZW1lbnQsXG4gICAgICBjb250ZW50OiB5LFxuICAgICAgZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdDogYSxcbiAgICAgIGludGVyYWN0aXZlOiAhMCxcbiAgICAgIHZpc2libGU6IG4sXG4gICAgICBhbmltYXRpb246IFwiZmFkZVwiLFxuICAgICAgcGxhY2VtZW50OiBcInRvcC1zdGFydFwiLFxuICAgICAgekluZGV4OiA0ZTNcbiAgICB9XG4gICk7XG59LCBqbiA9IChlKSA9PiB7XG4gIGNvbnN0IHsgY2xhc3NlczogbiB9ID0gJCh7IHJvb3Q6IHt9IH0pKHZvaWQgMCwge1xuICAgIG5hbWU6IFwiU2lkZU1lbnVcIlxuICB9KTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyByLmpzeChIZSwgeyBjbGFzc05hbWU6IG4ucm9vdCwgc3BhY2luZzogMCwgY2hpbGRyZW46IGUuY2hpbGRyZW4gfSk7XG59O1xuZnVuY3Rpb24gVG4oZSkge1xuICByZXR1cm4gaih7IHRhZzogXCJzdmdcIiwgYXR0cjogeyB0OiBcIjE1NTEzMjIzMTIyOTRcIiwgc3R5bGU6IFwiXCIsIHZpZXdCb3g6IFwiMCAwIDEwMjQgMTAyNFwiLCB2ZXJzaW9uOiBcIjEuMVwiIH0sIGNoaWxkOiBbeyB0YWc6IFwiZGVmc1wiLCBhdHRyOiB7fSwgY2hpbGQ6IFtdIH0sIHsgdGFnOiBcInBhdGhcIiwgYXR0cjogeyBkOiBcIk00NzQgMTUybTggMGw2MCAwcTggMCA4IDhsMCA3MDRxMCA4LTggOGwtNjAgMHEtOCAwLTgtOGwwLTcwNHEwLTggOC04WlwiIH0gfSwgeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGQ6IFwiTTE2OCA0NzRtOCAwbDY3MiAwcTggMCA4IDhsMCA2MHEwIDgtOCA4bC02NzIgMHEtOCAwLTgtOGwwLTYwcTAtOCA4LThaXCIgfSB9XSB9KShlKTtcbn1cbmNvbnN0IHp0ID0gKGUpID0+IC8qIEBfX1BVUkVfXyAqLyByLmpzeChndCwgeyBzaXplOiAyNCwgY2hpbGRyZW46IGUuY2hpbGRyZW4gfSksIHduID0gKGUpID0+IC8qIEBfX1BVUkVfXyAqLyByLmpzeCh6dCwgeyBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIHIuanN4KFxuICBUbixcbiAge1xuICAgIHNpemU6IDI0LFxuICAgIG9uQ2xpY2s6IGUuYWRkQmxvY2ssXG4gICAgXCJkYXRhLXRlc3RcIjogXCJkcmFnSGFuZGxlQWRkXCJcbiAgfVxuKSB9KTtcbmZ1bmN0aW9uIFNuKGUpIHtcbiAgcmV0dXJuIGooeyB0YWc6IFwic3ZnXCIsIGF0dHI6IHsgdmlld0JveDogXCIwIDAgMjQgMjRcIiB9LCBjaGlsZDogW3sgdGFnOiBcInBhdGhcIiwgYXR0cjogeyBmaWxsOiBcIm5vbmVcIiwgZDogXCJNMCAwaDI0djI0SDBWMHpcIiB9IH0sIHsgdGFnOiBcInBhdGhcIiwgYXR0cjogeyBkOiBcIk0xMSAxOGMwIDEuMS0uOSAyLTIgMnMtMi0uOS0yLTIgLjktMiAyLTIgMiAuOSAyIDJ6bS0yLThjLTEuMSAwLTIgLjktMiAycy45IDIgMiAyIDItLjkgMi0yLS45LTItMi0yem0wLTZjLTEuMSAwLTIgLjktMiAycy45IDIgMiAyIDItLjkgMi0yLS45LTItMi0yem02IDRjMS4xIDAgMi0uOSAyLTJzLS45LTItMi0yLTIgLjktMiAyIC45IDIgMiAyem0wIDJjLTEuMSAwLTIgLjktMiAycy45IDIgMiAyIDItLjkgMi0yLS45LTItMi0yem0wIDZjLTEuMSAwLTIgLjktMiAycy45IDIgMiAyIDItLjkgMi0yLS45LTItMi0yelwiIH0gfV0gfSkoZSk7XG59XG5jb25zdCBNbiA9IChlKSA9PiB7XG4gIGNvbnN0IHsgY2xhc3NlczogbiB9ID0gJCh7IHJvb3Q6IHt9IH0pKHZvaWQgMCwge1xuICAgIG5hbWU6IFwiRHJhZ0hhbmRsZU1lbnVcIlxuICB9KTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyByLmpzeCh3LkRyb3Bkb3duLCB7IGNsYXNzTmFtZTogbi5yb290LCBzdHlsZTogeyBvdmVyZmxvdzogXCJ2aXNpYmxlXCIgfSwgY2hpbGRyZW46IGUuY2hpbGRyZW4gfSk7XG59LCBIdCA9IChlKSA9PiB7XG4gIGNvbnN0IHsgY2hpbGRyZW46IG4sIC4uLm8gfSA9IGU7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gci5qc3gody5JdGVtLCB7IC4uLm8sIGNoaWxkcmVuOiBuIH0pO1xufSwgUm4gPSAoZSkgPT4gLyogQF9fUFVSRV9fICovIHIuanN4KFxuICBIdCxcbiAge1xuICAgIG9uQ2xpY2s6ICgpID0+IGUuZWRpdG9yLnJlbW92ZUJsb2NrcyhbZS5ibG9ja10pLFxuICAgIGNoaWxkcmVuOiBlLmNoaWxkcmVuXG4gIH1cbiksIEVuID0gKGUpID0+IHtcbiAgY29uc3QgW24sIG9dID0geCghMSksIHsgcmVmOiBpLCB1cGRhdGVNYXhIZWlnaHQ6IHMgfSA9IHhlKCksIGMgPSBMKCksIHUgPSB6KCgpID0+IHtcbiAgICBjLmN1cnJlbnQgJiYgY2xlYXJUaW1lb3V0KGMuY3VycmVudCksIGMuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgbyghMSk7XG4gICAgfSwgMjUwKTtcbiAgfSwgW10pLCBnID0geigoKSA9PiB7XG4gICAgYy5jdXJyZW50ICYmIGNsZWFyVGltZW91dChjLmN1cnJlbnQpLCBuIHx8IHMoKSwgbyghMCk7XG4gIH0sIFtuLCBzXSk7XG4gIHJldHVybiAhKFwidGV4dENvbG9yXCIgaW4gZS5ibG9jay5wcm9wcykgJiYgIShcImJhY2tncm91bmRDb2xvclwiIGluIGUuYmxvY2sucHJvcHMpID8gbnVsbCA6IC8qIEBfX1BVUkVfXyAqLyByLmpzeChcbiAgICBIdCxcbiAgICB7XG4gICAgICBvbk1vdXNlTGVhdmU6IHUsXG4gICAgICBvbk1vdXNlT3ZlcjogZyxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gci5qc3hzKHcsIHsgb3BlbmVkOiBuLCBwb3NpdGlvbjogXCJyaWdodFwiLCBjaGlsZHJlbjogW1xuICAgICAgICAvKiBAX19QVVJFX18gKi8gci5qc3gody5UYXJnZXQsIHsgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyByLmpzeHMoXCJkaXZcIiwgeyBzdHlsZTogeyBkaXNwbGF5OiBcImZsZXhcIiwgYWxpZ25JdGVtczogXCJjZW50ZXJcIiB9LCBjaGlsZHJlbjogW1xuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyByLmpzeChcImRpdlwiLCB7IHN0eWxlOiB7IGZsZXg6IDEgfSwgY2hpbGRyZW46IGUuY2hpbGRyZW4gfSksXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovIHIuanN4KGZ0LCB7IHN0eWxlOiB7IGRpc3BsYXk6IFwiZmxleFwiLCBhbGlnbkl0ZW1zOiBcImNlbnRlclwiIH0sIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gci5qc3goWnIsIHsgc2l6ZTogMTUgfSkgfSlcbiAgICAgICAgXSB9KSB9KSxcbiAgICAgICAgLyogQF9fUFVSRV9fICovIHIuanN4KFwiZGl2XCIsIHsgcmVmOiBpLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIHIuanN4KFxuICAgICAgICAgIHcuRHJvcGRvd24sXG4gICAgICAgICAge1xuICAgICAgICAgICAgb25Nb3VzZUxlYXZlOiB1LFxuICAgICAgICAgICAgb25Nb3VzZU92ZXI6IGcsXG4gICAgICAgICAgICBzdHlsZTogeyBtYXJnaW5MZWZ0OiBcIjVweFwiIH0sXG4gICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIHIuanN4KFxuICAgICAgICAgICAgICB3dCxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGljb25TaXplOiAxOCxcbiAgICAgICAgICAgICAgICB0ZXh0OiBcInRleHRDb2xvclwiIGluIGUuYmxvY2sucHJvcHMgJiYgdHlwZW9mIGUuYmxvY2sucHJvcHMudGV4dENvbG9yID09IFwic3RyaW5nXCIgPyB7XG4gICAgICAgICAgICAgICAgICBjb2xvcjogZS5ibG9jay5wcm9wcy50ZXh0Q29sb3IsXG4gICAgICAgICAgICAgICAgICBzZXRDb2xvcjogKGEpID0+IGUuZWRpdG9yLnVwZGF0ZUJsb2NrKGUuYmxvY2ssIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHM6IHsgdGV4dENvbG9yOiBhIH1cbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSA6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiBcImJhY2tncm91bmRDb2xvclwiIGluIGUuYmxvY2sucHJvcHMgJiYgdHlwZW9mIGUuYmxvY2sucHJvcHMuYmFja2dyb3VuZENvbG9yID09IFwic3RyaW5nXCIgPyB7XG4gICAgICAgICAgICAgICAgICBjb2xvcjogZS5ibG9jay5wcm9wcy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICAgICAgICBzZXRDb2xvcjogKGEpID0+IGUuZWRpdG9yLnVwZGF0ZUJsb2NrKGUuYmxvY2ssIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHM6IHsgYmFja2dyb3VuZENvbG9yOiBhIH1cbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSA6IHZvaWQgMFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICApIH0pXG4gICAgICBdIH0pXG4gICAgfVxuICApO1xufSwgem4gPSAoZSkgPT4gLyogQF9fUFVSRV9fICovIHIuanN4cyhNbiwgeyBjaGlsZHJlbjogW1xuICAvKiBAX19QVVJFX18gKi8gci5qc3goUm4sIHsgLi4uZSwgY2hpbGRyZW46IFwiRGVsZXRlXCIgfSksXG4gIC8qIEBfX1BVUkVfXyAqLyByLmpzeChFbiwgeyAuLi5lLCBjaGlsZHJlbjogXCJDb2xvcnNcIiB9KVxuXSB9KSwgSG4gPSAoZSkgPT4ge1xuICBjb25zdCBuID0gZS5kcmFnSGFuZGxlTWVudSB8fCB6bjtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyByLmpzeHMoXG4gICAgdyxcbiAgICB7XG4gICAgICB0cmlnZ2VyOiBcImNsaWNrXCIsXG4gICAgICBvbk9wZW46IGUuZnJlZXplTWVudSxcbiAgICAgIG9uQ2xvc2U6IGUudW5mcmVlemVNZW51LFxuICAgICAgd2lkdGg6IDEwMCxcbiAgICAgIHBvc2l0aW9uOiBcImxlZnRcIixcbiAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyByLmpzeCh3LlRhcmdldCwgeyBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIHIuanN4KFxuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgZHJhZ2dhYmxlOiBcInRydWVcIixcbiAgICAgICAgICAgIG9uRHJhZ1N0YXJ0OiBlLmJsb2NrRHJhZ1N0YXJ0LFxuICAgICAgICAgICAgb25EcmFnRW5kOiBlLmJsb2NrRHJhZ0VuZCxcbiAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gci5qc3goenQsIHsgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyByLmpzeChTbiwgeyBzaXplOiAyNCwgXCJkYXRhLXRlc3RcIjogXCJkcmFnSGFuZGxlXCIgfSkgfSlcbiAgICAgICAgICB9XG4gICAgICAgICkgfSksXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyByLmpzeChuLCB7IGVkaXRvcjogZS5lZGl0b3IsIGJsb2NrOiBlLmJsb2NrIH0pXG4gICAgICBdXG4gICAgfVxuICApO1xufSwgSW4gPSAoZSkgPT4gLyogQF9fUFVSRV9fICovIHIuanN4cyhqbiwgeyBjaGlsZHJlbjogW1xuICAvKiBAX19QVVJFX18gKi8gci5qc3god24sIHsgLi4uZSB9KSxcbiAgLyogQF9fUFVSRV9fICovIHIuanN4KEhuLCB7IC4uLmUgfSlcbl0gfSksIEJuID0gKGUpID0+IHtcbiAgY29uc3QgW24sIG9dID0geCghMSksIFtpLCBzXSA9IHgoKSwgYyA9IEwoKTtcbiAgQigoKSA9PiBlLmVkaXRvci5zaWRlTWVudS5vblVwZGF0ZSgoYSkgPT4ge1xuICAgIG8oYS5zaG93KSwgcyhhLmJsb2NrKSwgYy5jdXJyZW50ID0gYS5yZWZlcmVuY2VQb3M7XG4gIH0pLCBbZS5lZGl0b3JdKTtcbiAgY29uc3QgdSA9IFIoXG4gICAgKCkgPT4ge1xuICAgICAgaWYgKGMuY3VycmVudClcbiAgICAgICAgcmV0dXJuICgpID0+IGMuY3VycmVudDtcbiAgICB9LFxuICAgIFtjLmN1cnJlbnRdXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICApLCBnID0gUigoKSA9PiB7XG4gICAgaWYgKCFpKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgYSA9IGUuc2lkZU1lbnUgfHwgSW47XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyByLmpzeChcbiAgICAgIGEsXG4gICAgICB7XG4gICAgICAgIGJsb2NrOiBpLFxuICAgICAgICBlZGl0b3I6IGUuZWRpdG9yLFxuICAgICAgICBibG9ja0RyYWdTdGFydDogZS5lZGl0b3Iuc2lkZU1lbnUuYmxvY2tEcmFnU3RhcnQsXG4gICAgICAgIGJsb2NrRHJhZ0VuZDogZS5lZGl0b3Iuc2lkZU1lbnUuYmxvY2tEcmFnRW5kLFxuICAgICAgICBhZGRCbG9jazogZS5lZGl0b3Iuc2lkZU1lbnUuYWRkQmxvY2ssXG4gICAgICAgIGZyZWV6ZU1lbnU6IGUuZWRpdG9yLnNpZGVNZW51LmZyZWV6ZU1lbnUsXG4gICAgICAgIHVuZnJlZXplTWVudTogZS5lZGl0b3Iuc2lkZU1lbnUudW5mcmVlemVNZW51XG4gICAgICB9XG4gICAgKTtcbiAgfSwgW2ksIGUuZWRpdG9yLCBlLnNpZGVNZW51XSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gci5qc3goXG4gICAgWSxcbiAgICB7XG4gICAgICBhcHBlbmRUbzogZS5lZGl0b3IuZG9tRWxlbWVudC5wYXJlbnRFbGVtZW50LFxuICAgICAgY29udGVudDogZyxcbiAgICAgIGdldFJlZmVyZW5jZUNsaWVudFJlY3Q6IHUsXG4gICAgICBpbnRlcmFjdGl2ZTogITAsXG4gICAgICB2aXNpYmxlOiBuLFxuICAgICAgYW5pbWF0aW9uOiBcImZhZGVcIixcbiAgICAgIG9mZnNldDogX24sXG4gICAgICBwbGFjZW1lbnQ6IFwibGVmdFwiLFxuICAgICAgcG9wcGVyT3B0aW9uczogRG4sXG4gICAgICB6SW5kZXg6IDFlM1xuICAgIH1cbiAgKTtcbn0sIF9uID0gWzAsIDBdLCBEbiA9IHtcbiAgbW9kaWZpZXJzOiBbXG4gICAge1xuICAgICAgbmFtZTogXCJmbGlwXCIsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIGZhbGxiYWNrUGxhY2VtZW50czogW11cbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6IFwicHJldmVudE92ZXJmbG93XCIsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIG1haW5BeGlzOiAhMSxcbiAgICAgICAgYWx0QXhpczogITFcbiAgICAgIH1cbiAgICB9XG4gIF1cbn0sIFBuID0gNTtcbmZ1bmN0aW9uIE9uKGUpIHtcbiAgY29uc3QgbiA9IEwobnVsbCksIHsgY2xhc3NlczogbyB9ID0gJCh7IHJvb3Q6IHt9IH0pKHZvaWQgMCwge1xuICAgIG5hbWU6IFwiU3VnZ2VzdGlvbkxpc3RJdGVtXCJcbiAgfSk7XG4gIGZ1bmN0aW9uIGkoKSB7XG4gICAgdmFyIGc7XG4gICAgY29uc3QgYyA9IGUuaXNTZWxlY3RlZCwgdSA9IChnID0gbi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogZy5tYXRjaGVzKFwiOmhvdmVyXCIpO1xuICAgIHJldHVybiBjIHx8IHU7XG4gIH1cbiAgZnVuY3Rpb24gcygpIHtcbiAgICB2YXIgYywgdTtcbiAgICBpKCkgPyAoYyA9IG4uY3VycmVudCkgPT0gbnVsbCB8fCBjLnNldEF0dHJpYnV0ZShcImRhdGEtaG92ZXJlZFwiLCBcInRydWVcIikgOiAodSA9IG4uY3VycmVudCkgPT0gbnVsbCB8fCB1LnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtaG92ZXJlZFwiKTtcbiAgfVxuICByZXR1cm4gQigoKSA9PiB7XG4gICAgcygpLCBpKCkgJiYgbi5jdXJyZW50ICYmIG4uY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0ID4gUG4gJiYgbi5jdXJyZW50LnNjcm9sbEludG9WaWV3KHtcbiAgICAgIGJlaGF2aW9yOiBcInNtb290aFwiLFxuICAgICAgYmxvY2s6IFwibmVhcmVzdFwiXG4gICAgfSk7XG4gIH0pLCAvKiBAX19QVVJFX18gKi8gci5qc3goXG4gICAgdy5JdGVtLFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogby5yb290LFxuICAgICAgaWNvbjogZS5pY29uLFxuICAgICAgb25DbGljazogZS5zZXQsXG4gICAgICBjbG9zZU1lbnVPbkNsaWNrOiAhMSxcbiAgICAgIG9uTW91c2VMZWF2ZTogKCkgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBzKCk7XG4gICAgICAgIH0sIDEpO1xuICAgICAgfSxcbiAgICAgIHJlZjogbixcbiAgICAgIHJpZ2h0U2VjdGlvbjogZS5zaG9ydGN1dCAmJiAvKiBAX19QVVJFX18gKi8gci5qc3goanIsIHsgc2l6ZTogXCJ4c1wiLCBjaGlsZHJlbjogZS5zaG9ydGN1dCB9KSxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gci5qc3hzKEJlLCB7IGNoaWxkcmVuOiBbXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyByLmpzeChvZSwgeyBzaXplOiAxNCwgd2VpZ2h0OiA1MDAsIGNoaWxkcmVuOiBlLm5hbWUgfSksXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyByLmpzeChvZSwgeyBzaXplOiAxMCwgY2hpbGRyZW46IGUuaGludCB9KVxuICAgICAgXSB9KVxuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIEZuKGUpIHtcbiAgY29uc3QgeyBjbGFzc2VzOiBuIH0gPSAkKHsgcm9vdDoge30gfSkodm9pZCAwLCB7XG4gICAgbmFtZTogXCJTbGFzaE1lbnVcIlxuICB9KSwgbyA9IFtdO1xuICBsZXQgaSA9IDA7XG4gIGNvbnN0IHMgPSBpdC5ncm91cEJ5KGUuZmlsdGVyZWRJdGVtcywgKGMpID0+IGMuZ3JvdXApO1xuICByZXR1cm4gaXQuZm9yRWFjaChzLCAoYykgPT4ge1xuICAgIG8ucHVzaChcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyByLmpzeCh3LkxhYmVsLCB7IGNoaWxkcmVuOiBjWzBdLmdyb3VwIH0sIGNbMF0uZ3JvdXApXG4gICAgKTtcbiAgICBmb3IgKGNvbnN0IHUgb2YgYylcbiAgICAgIG8ucHVzaChcbiAgICAgICAgLyogQF9fUFVSRV9fICovIHIuanN4KFxuICAgICAgICAgIE9uLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IHUubmFtZSxcbiAgICAgICAgICAgIGljb246IHUuaWNvbixcbiAgICAgICAgICAgIGhpbnQ6IHUuaGludCxcbiAgICAgICAgICAgIHNob3J0Y3V0OiB1LnNob3J0Y3V0LFxuICAgICAgICAgICAgaXNTZWxlY3RlZDogZS5rZXlib2FyZEhvdmVyZWRJdGVtSW5kZXggPT09IGksXG4gICAgICAgICAgICBzZXQ6ICgpID0+IGUuaXRlbUNhbGxiYWNrKHUpXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1Lm5hbWVcbiAgICAgICAgKVxuICAgICAgKSwgaSsrO1xuICB9KSwgLyogQF9fUFVSRV9fICovIHIuanN4KFxuICAgIHcsXG4gICAge1xuICAgICAgZGVmYXVsdE9wZW5lZDogITAsXG4gICAgICB0cmlnZ2VyOiBcImhvdmVyXCIsXG4gICAgICBjbG9zZURlbGF5OiAxZTcsXG4gICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIHIuanN4KFxuICAgICAgICB3LkRyb3Bkb3duLFxuICAgICAgICB7XG4gICAgICAgICAgb25Nb3VzZURvd246IChjKSA9PiBjLnByZXZlbnREZWZhdWx0KCksXG4gICAgICAgICAgY2xhc3NOYW1lOiBuLnJvb3QsXG4gICAgICAgICAgY2hpbGRyZW46IG8ubGVuZ3RoID4gMCA/IG8gOiAvKiBAX19QVVJFX18gKi8gci5qc3gody5JdGVtLCB7IGNoaWxkcmVuOiBcIk5vIG1hdGNoIGZvdW5kXCIgfSlcbiAgICAgICAgfVxuICAgICAgKVxuICAgIH1cbiAgKTtcbn1cbmNvbnN0IEFuID0gKGUpID0+IHtcbiAgY29uc3QgW24sIG9dID0geCghMSksIFtpLCBzXSA9IHgoKSwgW2MsIHVdID0geCgpLCBnID0gTCgpO1xuICBCKCgpID0+IGUuZWRpdG9yLnNsYXNoTWVudS5vblVwZGF0ZSgoUykgPT4ge1xuICAgIG8oUy5zaG93KSwgcyhTLmZpbHRlcmVkSXRlbXMpLCB1KFMua2V5Ym9hcmRIb3ZlcmVkSXRlbUluZGV4KSwgZy5jdXJyZW50ID0gUy5yZWZlcmVuY2VQb3M7XG4gIH0pLCBbZS5lZGl0b3JdKTtcbiAgY29uc3QgYSA9IFIoXG4gICAgKCkgPT4ge1xuICAgICAgaWYgKGcuY3VycmVudClcbiAgICAgICAgcmV0dXJuICgpID0+IGcuY3VycmVudDtcbiAgICB9LFxuICAgIFtnLmN1cnJlbnRdXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICApLCB7IHJlZjogeSwgdXBkYXRlTWF4SGVpZ2h0OiBoIH0gPSB4ZSgpLCBwID0gUigoKSA9PiB7XG4gICAgaWYgKCFpIHx8IGMgPT09IHZvaWQgMClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IFMgPSBlLnNsYXNoTWVudSB8fCBGbjtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIHIuanN4KFwiZGl2XCIsIHsgcmVmOiB5LCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIHIuanN4KFxuICAgICAgUyxcbiAgICAgIHtcbiAgICAgICAgZmlsdGVyZWRJdGVtczogaSxcbiAgICAgICAgaXRlbUNhbGxiYWNrOiAoVCkgPT4gZS5lZGl0b3Iuc2xhc2hNZW51Lml0ZW1DYWxsYmFjayhUKSxcbiAgICAgICAga2V5Ym9hcmRIb3ZlcmVkSXRlbUluZGV4OiBjXG4gICAgICB9XG4gICAgKSB9KTtcbiAgfSwgW1xuICAgIGksXG4gICAgYyxcbiAgICBlLmVkaXRvci5zbGFzaE1lbnUsXG4gICAgZS5zbGFzaE1lbnUsXG4gICAgeVxuICBdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyByLmpzeChcbiAgICBZLFxuICAgIHtcbiAgICAgIG9uU2hvdzogaCxcbiAgICAgIGFwcGVuZFRvOiBlLmVkaXRvci5kb21FbGVtZW50LnBhcmVudEVsZW1lbnQsXG4gICAgICBjb250ZW50OiBwLFxuICAgICAgZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdDogYSxcbiAgICAgIGludGVyYWN0aXZlOiAhMCxcbiAgICAgIHZpc2libGU6IG4sXG4gICAgICBhbmltYXRpb246IFwiZmFkZVwiLFxuICAgICAgcGxhY2VtZW50OiBcImJvdHRvbS1zdGFydFwiLFxuICAgICAgekluZGV4OiAyZTNcbiAgICB9XG4gICk7XG59LCBrID0gW1xuICBcIiNGRkZGRkZcIixcbiAgXCIjRUZFRkVGXCIsXG4gIFwiI0NGQ0ZDRlwiLFxuICBcIiNBRkFGQUZcIixcbiAgXCIjN0Y3RjdGXCIsXG4gIFwiIzNGM0YzRlwiLFxuICBcIiMxRjFGMUZcIixcbiAgXCIjMTYxNjE2XCIsXG4gIFwiIzBGMEYwRlwiLFxuICBcIiMwMDAwMDBcIlxuXSwgdmUgPSB7XG4gIGNvbG9yczoge1xuICAgIGVkaXRvcjoge1xuICAgICAgdGV4dDoga1s1XSxcbiAgICAgIGJhY2tncm91bmQ6IGtbMF1cbiAgICB9LFxuICAgIG1lbnU6IHtcbiAgICAgIHRleHQ6IGtbNV0sXG4gICAgICBiYWNrZ3JvdW5kOiBrWzBdXG4gICAgfSxcbiAgICB0b29sdGlwOiB7XG4gICAgICB0ZXh0OiBrWzVdLFxuICAgICAgYmFja2dyb3VuZDoga1sxXVxuICAgIH0sXG4gICAgaG92ZXJlZDoge1xuICAgICAgdGV4dDoga1s1XSxcbiAgICAgIGJhY2tncm91bmQ6IGtbMV1cbiAgICB9LFxuICAgIHNlbGVjdGVkOiB7XG4gICAgICB0ZXh0OiBrWzBdLFxuICAgICAgYmFja2dyb3VuZDoga1s1XVxuICAgIH0sXG4gICAgZGlzYWJsZWQ6IHtcbiAgICAgIHRleHQ6IGtbM10sXG4gICAgICBiYWNrZ3JvdW5kOiBrWzFdXG4gICAgfSxcbiAgICBzaGFkb3c6IGtbMl0sXG4gICAgYm9yZGVyOiBrWzFdLFxuICAgIHNpZGVNZW51OiBrWzJdLFxuICAgIGhpZ2hsaWdodENvbG9yczoge1xuICAgICAgZ3JheToge1xuICAgICAgICB0ZXh0OiBcIiM5YjlhOTdcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjZWJlY2VkXCJcbiAgICAgIH0sXG4gICAgICBicm93bjoge1xuICAgICAgICB0ZXh0OiBcIiM2NDQ3M2FcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjZTllNWUzXCJcbiAgICAgIH0sXG4gICAgICByZWQ6IHtcbiAgICAgICAgdGV4dDogXCIjZTAzZTNlXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI2ZiZTRlNFwiXG4gICAgICB9LFxuICAgICAgb3JhbmdlOiB7XG4gICAgICAgIHRleHQ6IFwiI2Q5NzMwZFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNmNmU5ZDlcIlxuICAgICAgfSxcbiAgICAgIHllbGxvdzoge1xuICAgICAgICB0ZXh0OiBcIiNkZmFiMDFcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjZmJmM2RiXCJcbiAgICAgIH0sXG4gICAgICBncmVlbjoge1xuICAgICAgICB0ZXh0OiBcIiM0ZDY0NjFcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjZGRlZGVhXCJcbiAgICAgIH0sXG4gICAgICBibHVlOiB7XG4gICAgICAgIHRleHQ6IFwiIzBiNmU5OVwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNkZGViZjFcIlxuICAgICAgfSxcbiAgICAgIHB1cnBsZToge1xuICAgICAgICB0ZXh0OiBcIiM2OTQwYTVcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjZWFlNGYyXCJcbiAgICAgIH0sXG4gICAgICBwaW5rOiB7XG4gICAgICAgIHRleHQ6IFwiI2FkMWE3MlwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNmNGRmZWJcIlxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgYm9yZGVyUmFkaXVzOiA2LFxuICBmb250RmFtaWx5OiAnXCJJbnRlclwiLCBcIlNGIFBybyBEaXNwbGF5XCIsIC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgXCJPcGVuIFNhbnNcIiwgXCJTZWdvZSBVSVwiLCBcIlJvYm90b1wiLCBcIk94eWdlblwiLCBcIlVidW50dVwiLCBcIkNhbnRhcmVsbFwiLCBcIkZpcmEgU2Fuc1wiLCBcIkRyb2lkIFNhbnNcIiwgXCJIZWx2ZXRpY2EgTmV1ZVwiLCBzYW5zLXNlcmlmJ1xufSwgZHQgPSB7XG4gIGNvbG9yczoge1xuICAgIGVkaXRvcjoge1xuICAgICAgdGV4dDoga1syXSxcbiAgICAgIGJhY2tncm91bmQ6IGtbNl1cbiAgICB9LFxuICAgIG1lbnU6IHtcbiAgICAgIHRleHQ6IGtbMl0sXG4gICAgICBiYWNrZ3JvdW5kOiBrWzZdXG4gICAgfSxcbiAgICB0b29sdGlwOiB7XG4gICAgICB0ZXh0OiBrWzJdLFxuICAgICAgYmFja2dyb3VuZDoga1s3XVxuICAgIH0sXG4gICAgaG92ZXJlZDoge1xuICAgICAgdGV4dDoga1syXSxcbiAgICAgIGJhY2tncm91bmQ6IGtbN11cbiAgICB9LFxuICAgIHNlbGVjdGVkOiB7XG4gICAgICB0ZXh0OiBrWzJdLFxuICAgICAgYmFja2dyb3VuZDoga1s4XVxuICAgIH0sXG4gICAgZGlzYWJsZWQ6IHtcbiAgICAgIHRleHQ6IGtbNV0sXG4gICAgICBiYWNrZ3JvdW5kOiBrWzddXG4gICAgfSxcbiAgICBzaGFkb3c6IGtbOF0sXG4gICAgYm9yZGVyOiBrWzddLFxuICAgIHNpZGVNZW51OiBrWzRdLFxuICAgIGhpZ2hsaWdodENvbG9yczoge1xuICAgICAgZ3JheToge1xuICAgICAgICB0ZXh0OiBcIiNiZWJkYjhcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjOWI5YTk3XCJcbiAgICAgIH0sXG4gICAgICBicm93bjoge1xuICAgICAgICB0ZXh0OiBcIiM4ZTY1NTJcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjNjQ0NzNhXCJcbiAgICAgIH0sXG4gICAgICByZWQ6IHtcbiAgICAgICAgdGV4dDogXCIjZWM0MDQwXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI2JlMzQzNFwiXG4gICAgICB9LFxuICAgICAgb3JhbmdlOiB7XG4gICAgICAgIHRleHQ6IFwiI2UzNzkwZFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNiNzYwMGFcIlxuICAgICAgfSxcbiAgICAgIHllbGxvdzoge1xuICAgICAgICB0ZXh0OiBcIiNkZmFiMDFcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjYjU4YjAwXCJcbiAgICAgIH0sXG4gICAgICBncmVlbjoge1xuICAgICAgICB0ZXh0OiBcIiM2YjhiODdcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjNGQ2NDYxXCJcbiAgICAgIH0sXG4gICAgICBibHVlOiB7XG4gICAgICAgIHRleHQ6IFwiIzBlODdiY1wiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiMwYjZlOTlcIlxuICAgICAgfSxcbiAgICAgIHB1cnBsZToge1xuICAgICAgICB0ZXh0OiBcIiM4NTUyZDdcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjNjk0MGE1XCJcbiAgICAgIH0sXG4gICAgICBwaW5rOiB7XG4gICAgICAgIHRleHQ6IFwiI2RhMjA4ZlwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNhZDFhNzJcIlxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgYm9yZGVyUmFkaXVzOiB2ZS5ib3JkZXJSYWRpdXMsXG4gIGZvbnRGYW1pbHk6IHZlLmZvbnRGYW1pbHlcbn0sIExuID0gKGUpID0+IHtcbiAgY29uc3QgW24sIG9dID0geCghMSksIFtpLCBzXSA9IHgoKSwgYyA9IEwoKTtcbiAgQigoKSA9PiAoYnQuc2V0RGVmYXVsdFByb3BzKHsgbWF4V2lkdGg6IFwiXCIgfSksIGUuZWRpdG9yLmltYWdlVG9vbGJhci5vblVwZGF0ZSgoYSkgPT4ge1xuICAgIG8oYS5zaG93KSwgcyhhLmJsb2NrKSwgYy5jdXJyZW50ID0gYS5yZWZlcmVuY2VQb3M7XG4gIH0pKSwgW2UuZWRpdG9yXSk7XG4gIGNvbnN0IHUgPSBSKFxuICAgICgpID0+IHtcbiAgICAgIGlmIChjKVxuICAgICAgICByZXR1cm4gKCkgPT4gYy5jdXJyZW50O1xuICAgIH0sXG4gICAgW2MuY3VycmVudF1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICksIGcgPSBSKCgpID0+IHtcbiAgICBjb25zdCBhID0gZS5pbWFnZVRvb2xiYXIgfHwgRXQ7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyByLmpzeChhLCB7IGVkaXRvcjogZS5lZGl0b3IsIGJsb2NrOiBpIH0pO1xuICB9LCBbaSwgZS5lZGl0b3IsIGUuaW1hZ2VUb29sYmFyXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gci5qc3goXG4gICAgWSxcbiAgICB7XG4gICAgICBhcHBlbmRUbzogZS5lZGl0b3IuZG9tRWxlbWVudC5wYXJlbnRFbGVtZW50LFxuICAgICAgY29udGVudDogZyxcbiAgICAgIGdldFJlZmVyZW5jZUNsaWVudFJlY3Q6IHUsXG4gICAgICBpbnRlcmFjdGl2ZTogITAsXG4gICAgICB2aXNpYmxlOiBuLFxuICAgICAgYW5pbWF0aW9uOiBcImZhZGVcIixcbiAgICAgIHBsYWNlbWVudDogXCJib3R0b21cIixcbiAgICAgIHpJbmRleDogNWUzXG4gICAgfVxuICApO1xufTtcbmZ1bmN0aW9uIFZuKGUpIHtcbiAgdmFyIHU7XG4gIGNvbnN0IHsgY2xhc3NlczogbiB9ID0gJCh7IHJvb3Q6IHt9IH0pKHZvaWQgMCwge1xuICAgIG5hbWU6IFwiRWRpdG9yXCJcbiAgfSksIHsgZWRpdG9yOiBvLCBjaGlsZHJlbjogaSwgY2xhc3NOYW1lOiBzLCAuLi5jIH0gPSBlO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIHIuanN4KFxuICAgIHdyLFxuICAgIHtcbiAgICAgIGVkaXRvcjogKHUgPSBlLmVkaXRvcikgPT0gbnVsbCA/IHZvaWQgMCA6IHUuX3RpcHRhcEVkaXRvcixcbiAgICAgIGNsYXNzTmFtZTogYmUobi5yb290LCBlLmNsYXNzTmFtZSB8fCBcIlwiKSxcbiAgICAgIC4uLmMsXG4gICAgICBjaGlsZHJlbjogZS5jaGlsZHJlbiB8fCAvKiBAX19QVVJFX18gKi8gci5qc3hzKHIuRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtcbiAgICAgICAgLyogQF9fUFVSRV9fICovIHIuanN4KGtuLCB7IGVkaXRvcjogZS5lZGl0b3IgfSksXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyByLmpzeChDbiwgeyBlZGl0b3I6IGUuZWRpdG9yIH0pLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8gci5qc3goQW4sIHsgZWRpdG9yOiBlLmVkaXRvciB9KSxcbiAgICAgICAgLyogQF9fUFVSRV9fICovIHIuanN4KEJuLCB7IGVkaXRvcjogZS5lZGl0b3IgfSksXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyByLmpzeChMbiwgeyBlZGl0b3I6IGUuZWRpdG9yIH0pXG4gICAgICBdIH0pXG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gZW8oZSkge1xuICBjb25zdCB7XG4gICAgdGhlbWU6IG4gPSB7IGxpZ2h0OiB2ZSwgZGFyazogZHQgfSxcbiAgICAuLi5vXG4gIH0gPSBlLCBpID0gRXIoKSwgcyA9IFIoKCkgPT4gbiA9PT0gXCJsaWdodFwiID8gZmUodmUpIDogbiA9PT0gXCJkYXJrXCIgPyBmZShkdCkgOiBcImxpZ2h0XCIgaW4gbiAmJiBcImRhcmtcIiBpbiBuID8gZmUoXG4gICAgbltpID09PSBcImRhcmtcIiA/IFwiZGFya1wiIDogXCJsaWdodFwiXVxuICApIDogZmUobiksIFtpLCBuXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gci5qc3goVHIsIHsgdGhlbWU6IHMsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gci5qc3goVm4sIHsgLi4ubyB9KSB9KTtcbn1cbmNvbnN0IFVuID0ge1xuICBIZWFkaW5nOiB7XG4gICAgZ3JvdXA6IFwiSGVhZGluZ3NcIixcbiAgICBpY29uOiAvKiBAX19QVVJFX18gKi8gci5qc3goa3QsIHsgc2l6ZTogMTggfSksXG4gICAgaGludDogXCJVc2VkIGZvciBhIHRvcC1sZXZlbCBoZWFkaW5nXCIsXG4gICAgc2hvcnRjdXQ6IEEoXCJNb2QtQWx0LTFcIilcbiAgfSxcbiAgXCJIZWFkaW5nIDJcIjoge1xuICAgIGdyb3VwOiBcIkhlYWRpbmdzXCIsXG4gICAgaWNvbjogLyogQF9fUFVSRV9fICovIHIuanN4KHl0LCB7IHNpemU6IDE4IH0pLFxuICAgIGhpbnQ6IFwiVXNlZCBmb3Iga2V5IHNlY3Rpb25zXCIsXG4gICAgc2hvcnRjdXQ6IEEoXCJNb2QtQWx0LTJcIilcbiAgfSxcbiAgXCJIZWFkaW5nIDNcIjoge1xuICAgIGdyb3VwOiBcIkhlYWRpbmdzXCIsXG4gICAgaWNvbjogLyogQF9fUFVSRV9fICovIHIuanN4KHB0LCB7IHNpemU6IDE4IH0pLFxuICAgIGhpbnQ6IFwiVXNlZCBmb3Igc3Vic2VjdGlvbnMgYW5kIGdyb3VwIGhlYWRpbmdzXCIsXG4gICAgc2hvcnRjdXQ6IEEoXCJNb2QtQWx0LTNcIilcbiAgfSxcbiAgXCJOdW1iZXJlZCBMaXN0XCI6IHtcbiAgICBncm91cDogXCJCYXNpYyBibG9ja3NcIixcbiAgICBpY29uOiAvKiBAX19QVVJFX18gKi8gci5qc3goanQsIHsgc2l6ZTogMTggfSksXG4gICAgaGludDogXCJVc2VkIHRvIGRpc3BsYXkgYSBudW1iZXJlZCBsaXN0XCIsXG4gICAgc2hvcnRjdXQ6IEEoXCJNb2QtQWx0LTdcIilcbiAgfSxcbiAgXCJCdWxsZXQgTGlzdFwiOiB7XG4gICAgZ3JvdXA6IFwiQmFzaWMgYmxvY2tzXCIsXG4gICAgaWNvbjogLyogQF9fUFVSRV9fICovIHIuanN4KFR0LCB7IHNpemU6IDE4IH0pLFxuICAgIGhpbnQ6IFwiVXNlZCB0byBkaXNwbGF5IGFuIHVub3JkZXJlZCBsaXN0XCIsXG4gICAgc2hvcnRjdXQ6IEEoXCJNb2QtQWx0LTlcIilcbiAgfSxcbiAgUGFyYWdyYXBoOiB7XG4gICAgZ3JvdXA6IFwiQmFzaWMgYmxvY2tzXCIsXG4gICAgaWNvbjogLyogQF9fUFVSRV9fICovIHIuanN4KGllLCB7IHNpemU6IDE4IH0pLFxuICAgIGhpbnQ6IFwiVXNlZCBmb3IgdGhlIGJvZHkgb2YgeW91ciBkb2N1bWVudFwiLFxuICAgIHNob3J0Y3V0OiBBKFwiTW9kLUFsdC0wXCIpXG4gIH0sXG4gIEltYWdlOiB7XG4gICAgZ3JvdXA6IFwiTWVkaWFcIixcbiAgICBpY29uOiAvKiBAX19QVVJFX18gKi8gci5qc3gocXIsIHt9KSxcbiAgICBoaW50OiBcIkluc2VydCBhbiBpbWFnZVwiXG4gIH1cbn07XG5mdW5jdGlvbiBObihlID0gdXQpIHtcbiAgcmV0dXJuIHZyKGUpLm1hcCgobykgPT4gKHtcbiAgICAuLi5vLFxuICAgIC4uLlVuW28ubmFtZV1cbiAgfSkpO1xufVxuY29uc3QgJG4gPSAoZSkgPT4gbmV3IGJyKHtcbiAgc2xhc2hNZW51SXRlbXM6IE5uKFxuICAgIGUuYmxvY2tTY2hlbWEgfHwgdXRcbiAgKSxcbiAgLi4uZVxufSksIHRvID0gKGUgPSB7fSwgbiA9IFtdKSA9PiB7XG4gIGNvbnN0IG8gPSBMKCk7XG4gIHJldHVybiBSKCgpID0+IChvLmN1cnJlbnQgJiYgby5jdXJyZW50Ll90aXB0YXBFZGl0b3IuZGVzdHJveSgpLCBvLmN1cnJlbnQgPSAkbihlKSwgby5jdXJyZW50KSwgbik7XG59O1xuZnVuY3Rpb24gV24oKSB7XG4gIGNvbnN0IFssIGVdID0geCgwKTtcbiAgcmV0dXJuICgpID0+IGUoKG4pID0+IG4gKyAxKTtcbn1cbmNvbnN0IHJvID0gKGUpID0+IHtcbiAgY29uc3QgbiA9IFduKCk7XG4gIEIoKCkgPT4ge1xuICAgIGNvbnN0IG8gPSAoKSA9PiB7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgIG4oKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBlLm9uKFwidHJhbnNhY3Rpb25cIiwgbyksICgpID0+IHtcbiAgICAgIGUub2ZmKFwidHJhbnNhY3Rpb25cIiwgbyk7XG4gICAgfTtcbiAgfSwgW2VdKTtcbn0sIEl0ID0gZnIoe30pLCBubyA9IChlKSA9PiB7XG4gIGNvbnN0IG4gPSBocihJdCkuaW5saW5lQ29udGVudCB8fCB7fSwgbyA9IGJlKFxuICAgIGUuY2xhc3NOYW1lIHx8IFwiXCIsXG4gICAgRi5pbmxpbmVDb250ZW50LFxuICAgIG4uY2xhc3NcbiAgKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyByLmpzeChcbiAgICBTcixcbiAgICB7XG4gICAgICAuLi5PYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKG4pLmZpbHRlcihcbiAgICAgICAgICAoW2ldKSA9PiBpICE9PSBcImNsYXNzXCJcbiAgICAgICAgKVxuICAgICAgKSxcbiAgICAgIC4uLmUsXG4gICAgICBjbGFzc05hbWU6IG9cbiAgICB9XG4gICk7XG59O1xuZnVuY3Rpb24gb28oZSkge1xuICByZXR1cm4ge1xuICAgIG5vZGU6IHhyKHtcbiAgICAgIG5hbWU6IGUudHlwZSxcbiAgICAgIGNvbnRlbnQ6IGUuY29udGFpbnNJbmxpbmVDb250ZW50ID8gXCJpbmxpbmUqXCIgOiBcIlwiLFxuICAgICAgc2VsZWN0YWJsZTogITAsXG4gICAgICBhZGRBdHRyaWJ1dGVzKCkge1xuICAgICAgICByZXR1cm4gbXIoZSk7XG4gICAgICB9LFxuICAgICAgcGFyc2VIVE1MKCkge1xuICAgICAgICByZXR1cm4ga3IoZSk7XG4gICAgICB9LFxuICAgICAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzOiBvIH0pIHtcbiAgICAgICAgcmV0dXJuIHlyKGUsIG8pO1xuICAgICAgfSxcbiAgICAgIGFkZE5vZGVWaWV3KCkge1xuICAgICAgICByZXR1cm4gTXIoKGkpID0+IHtcbiAgICAgICAgICB2YXIgVDtcbiAgICAgICAgICBjb25zdCBzID0gZS5yZW5kZXIsIGMgPSAoKFQgPSB0aGlzLm9wdGlvbnMuZG9tQXR0cmlidXRlcykgPT0gbnVsbCA/IHZvaWQgMCA6IFQuYmxvY2tDb250ZW50KSB8fCB7fSwgdSA9IHt9O1xuICAgICAgICAgIGZvciAoY29uc3QgW0QsIGxlXSBvZiBPYmplY3QuZW50cmllcyhpLm5vZGUuYXR0cnMpKVxuICAgICAgICAgICAgRCBpbiBlLnByb3BTY2hlbWEgJiYgbGUgIT09IGUucHJvcFNjaGVtYVtEXS5kZWZhdWx0ICYmICh1W3ByKEQpXSA9IGxlKTtcbiAgICAgICAgICBjb25zdCBnID0gdGhpcy5vcHRpb25zLmVkaXRvciwgYSA9IHR5cGVvZiBpLmdldFBvcyA9PSBcImZ1bmN0aW9uXCIgPyBpLmdldFBvcygpIDogdm9pZCAwLCBwID0gZy5fdGlwdGFwRWRpdG9yLnN0YXRlLmRvYy5yZXNvbHZlKGEpLm5vZGUoKS5hdHRycy5pZCwgUyA9IGcuZ2V0QmxvY2socCk7XG4gICAgICAgICAgaWYgKFMudHlwZSAhPT0gZS50eXBlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmxvY2sgdHlwZSBkb2VzIG5vdCBtYXRjaFwiKTtcbiAgICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIHIuanN4KFxuICAgICAgICAgICAgUnIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC4uLk9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICAgICAgICBPYmplY3QuZW50cmllcyhjKS5maWx0ZXIoXG4gICAgICAgICAgICAgICAgICAoW0RdKSA9PiBEICE9PSBcImNsYXNzXCJcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogYmUoXG4gICAgICAgICAgICAgICAgRi5ibG9ja0NvbnRlbnQsXG4gICAgICAgICAgICAgICAgYy5jbGFzc1xuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBcImRhdGEtY29udGVudC10eXBlXCI6IGUudHlwZSxcbiAgICAgICAgICAgICAgLi4udSxcbiAgICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyByLmpzeChcbiAgICAgICAgICAgICAgICBJdC5Qcm92aWRlcixcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5vcHRpb25zLmRvbUF0dHJpYnV0ZXMgfHwge30sXG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIHIuanN4KHMsIHsgYmxvY2s6IFMsIGVkaXRvcjogZyB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjbGFzc05hbWU6IEYucmVhY3ROb2RlVmlld1JlbmRlcmVyXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pLFxuICAgIHByb3BTY2hlbWE6IGUucHJvcFNjaGVtYVxuICB9O1xufVxuZXhwb3J0IHtcbiAgd24gYXMgQWRkQmxvY2tCdXR0b24sXG4gIEVuIGFzIEJsb2NrQ29sb3JzQnV0dG9uLFxuICBlbyBhcyBCbG9ja05vdGVWaWV3LFxuICBvbiBhcyBCbG9ja1R5cGVEcm9wZG93bixcbiAgdW4gYXMgQ29sb3JTdHlsZUJ1dHRvbixcbiAgdm4gYXMgQ3JlYXRlTGlua0J1dHRvbixcbiAgem4gYXMgRGVmYXVsdERyYWdIYW5kbGVNZW51LFxuICBtbiBhcyBEZWZhdWx0Rm9ybWF0dGluZ1Rvb2xiYXIsXG4gIEV0IGFzIERlZmF1bHRJbWFnZVRvb2xiYXIsXG4gIEluIGFzIERlZmF1bHRTaWRlTWVudSxcbiAgRm4gYXMgRGVmYXVsdFNsYXNoTWVudSxcbiAgSG4gYXMgRHJhZ0hhbmRsZSxcbiAgTW4gYXMgRHJhZ0hhbmRsZU1lbnUsXG4gIEh0IGFzIERyYWdIYW5kbGVNZW51SXRlbSxcbiAga24gYXMgRm9ybWF0dGluZ1Rvb2xiYXJQb3NpdGlvbmVyLFxuICBDbiBhcyBIeXBlcmxpbmtUb29sYmFyUG9zaXRpb25lcixcbiAgTG4gYXMgSW1hZ2VUb29sYmFyUG9zaXRpb25lcixcbiAgbm8gYXMgSW5saW5lQ29udGVudCxcbiAgZ24gYXMgTmVzdEJsb2NrQnV0dG9uLFxuICBSbiBhcyBSZW1vdmVCbG9ja0J1dHRvbixcbiAgam4gYXMgU2lkZU1lbnUsXG4gIHp0IGFzIFNpZGVNZW51QnV0dG9uLFxuICBCbiBhcyBTaWRlTWVudVBvc2l0aW9uZXIsXG4gIE9uIGFzIFNsYXNoTWVudUl0ZW0sXG4gIEFuIGFzIFNsYXNoTWVudVBvc2l0aW9uZXIsXG4gIFNlIGFzIFRleHRBbGlnbkJ1dHRvbixcbiAgaGUgYXMgVG9nZ2xlZFN0eWxlQnV0dG9uLFxuICBfZSBhcyBUb29sYmFyLFxuICBQIGFzIFRvb2xiYXJCdXR0b24sXG4gIGVuIGFzIFRvb2xiYXJEcm9wZG93bixcbiAgZm4gYXMgVW5uZXN0QmxvY2tCdXR0b24sXG4gIGZlIGFzIGJsb2NrTm90ZVRvTWFudGluZVRoZW1lLFxuICBvbyBhcyBjcmVhdGVSZWFjdEJsb2NrU3BlYyxcbiAgZHQgYXMgZGFya0RlZmF1bHRUaGVtZSxcbiAgbm4gYXMgZGVmYXVsdEJsb2NrVHlwZURyb3Bkb3duSXRlbXMsXG4gIGsgYXMgZGVmYXVsdENvbG9yU2NoZW1lLFxuICBObiBhcyBnZXREZWZhdWx0UmVhY3RTbGFzaE1lbnVJdGVtcyxcbiAgdmUgYXMgbGlnaHREZWZhdWx0VGhlbWUsXG4gIHRvIGFzIHVzZUJsb2NrTm90ZSxcbiAgcSBhcyB1c2VFZGl0b3JDaGFuZ2UsXG4gIHRuIGFzIHVzZUVkaXRvckNvbnRlbnRDaGFuZ2UsXG4gIHJvIGFzIHVzZUVkaXRvckZvcmNlVXBkYXRlLFxuICBybiBhcyB1c2VFZGl0b3JTZWxlY3Rpb25DaGFuZ2UsXG4gIEcgYXMgdXNlU2VsZWN0ZWRCbG9ja3Ncbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ibG9ja25vdGUtcmVhY3QuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@blocknote/react/dist/blocknote-react.js\n");

/***/ })

};
;